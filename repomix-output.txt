This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)


================================================================
Directory Structure
================================================================
.husky/
  pre-commit
prisma/
  schema.prisma
  seed.js
src/
  config/
    database.js
    environment.js
    logger.js
    redis.js
    swagger.js
  middleware/
    audit.js
    auth.js
    errorHandler.js
    rateLimiter.js
    security.js
    upload.js
    validation.js
  modules/
    admin/
      controllers/
        adminController.js
      routes/
        adminRoutes.js
    analytics/
      controllers/
        analyticsController.js
      routes/
        analyticsRoutes.js
    auth/
      controllers/
        authController.js
      routes/
        authRoutes.js
    calendar/
      controllers/
        calendarController.js
      routes/
        calendarRoutes.js
    complaints/
      controllers/
        complaintController.js
      routes/
        complaintRoutes.js
    leases/
      controllers/
        leaseController.js
      routes/
        leaseRoutes.js
    maintenance/
      controllers/
        maintenanceController.js
      routes/
        maintenanceRoutes.js
    managers/
      controllers/
        managerController.js
      routes/
        managerRoutes.js
    notifications/
      controllers/
        notificationController.js
      routes/
        notificationRoutes.js
      services/
        emailService.js
        firebaseService.js
        socketService.js
    owners/
      controllers/
        ownerController.js
      routes/
        ownerRoutes.js
    payments/
      controllers/
        paymentController.js
      routes/
        paymentRoutes.js
    properties/
      controllers/
        propertyController.js
      routes/
        propertyRoutes.js
    reports/
      controllers/
        reportController.js
      routes/
        reportRoutes.js
    tenants/
      controllers/
        tenantController.js
      routes/
        tenantRoutes.js
  services/
    auditService.js
    backupService.js
    cronJobs.js
    featureFlags.js
    notificationService.js
  utils/
    cloudinary.js
    dateHelpers.js
    encryption.js
    helpers.js
    pdfGenerator.js
    responseHelpers.js
    validators.js
  index.js
tests/
  admin.test.js
  auth.test.js
  maintenance.test.js
  setup.js
.env.example
.eslintrc.json
.gitignore
.prettierrc
docker-compose.yml
Dockerfile
healthcheck.js
jest.config.js
package.json

================================================================
Files
================================================================

================
File: .husky/pre-commit
================
#!/usr/bin/env sh
. "$(dirname -- "$0")/_/husky.sh"

npx lint-staged

================
File: prisma/schema.prisma
================
// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                        String                @id @default(cuid())
  email                     String                @unique
  password                  String
  firstName                 String
  lastName                  String
  role                      UserRole                @default(TENANT)
  isActive                  Boolean               @default(true)
  lastLogin                 DateTime?
  createdAt                 DateTime              @default(now())
  updatedAt                 DateTime              @updatedAt

  // Relations
  tenant                    Tenant?
  owner                     Owner?
  manager                   Manager?
  sentMessages              Message[]             @relation("SentMessages")
  receivedMessages          Message[]             @relation("ReceivedMessages")
  notifications             Notification[]
  loginAttempts             LoginAttempt[]
  auditLogs                 AuditLog[]
  maintenanceRequests       MaintenanceRequest[]  @relation("MaintenanceRequester")
  assignedMaintenanceRequests MaintenanceRequest[] @relation("MaintenanceAssignee")
  maintenanceUpdates        MaintenanceUpdate[]
  calendarEvents            CalendarEvent[]       @relation("CalendarEventCreator")
  reports                  Report[]

  @@map("users")
}

model Owner {
  id        String   @id @default(cuid())
  userId    String   @unique
  companyName String?
  phone     String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user       User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  properties Property[]
  managers   Manager[]
  analytics  Analytics[]

  @@map("owners")
}

model Manager {
  id          String   @id @default(cuid())
  userId      String   @unique
  ownerId     String
  permissions Json     @default("{}")
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  owner Owner @relation(fields: [ownerId], references: [id], onDelete: Cascade)

  @@map("managers")
}

model Property {
  id                   String               @id @default(cuid())
  ownerId              String
  name                 String
  description          String?
  address              String
  type                 PropertyType         @default(APARTMENT)
  units                Int                  @default(1)
  rentAmount           Decimal              @db.Decimal(10, 2)
  status               PropertyStatus        @default(AVAILABLE)
  images               String[]             @default([])
  amenities            String[]             @default([])
  createdAt            DateTime             @default(now())
  updatedAt            DateTime             @updatedAt

  // Relations
  owner                Owner                @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  tenants              Tenant[]
  leases               Lease[]
  complaints           Complaint[]
  maintenanceRequests  MaintenanceRequest[]

  @@map("properties")
}

model Tenant {
  id             String   @id @default(cuid())
  userId         String   @unique
  propertyId     String
  firstName      String
  lastName       String
  phone          String
  emergencyContact Json?
  moveInDate     DateTime?
  isActive       Boolean  @default(true)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  // Relations
  user         User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  property     Property   @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  leases       Lease[]
  payments     Payment[]
  complaints   Complaint[]
  analytics    Analytics[]

  @@map("tenants")
}

model Lease {
  id             String      @id @default(cuid())
  propertyId     String
  tenantId       String
  startDate      DateTime
  endDate        DateTime
  rentAmount     Decimal     @db.Decimal(10, 2)
  securityDeposit Decimal?   @db.Decimal(10, 2)
  status         LeaseStatus @default(ACTIVE)
  terms          Json?
  documentUrl    String?
  createdAt      DateTime    @default(now())
  updatedAt      DateTime    @updatedAt

  // Relations
  property Property  @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  tenant   Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  payments Payment[]

  @@map("leases")
}

model Payment {
  id            String        @id @default(cuid())
  tenantId      String
  leaseId       String
  amount        Decimal       @db.Decimal(10, 2)
  dueDate       DateTime
  paidDate      DateTime?
  status        PaymentStatus @default(PENDING)
  method        PaymentMethod @default(ONLINE)
  transactionId String?
  notes         String?
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt

  // Relations
  tenant   Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  lease    Lease    @relation(fields: [leaseId], references: [id], onDelete: Cascade)
  receipts Receipt[]

  @@map("payments")
}

model Receipt {
  id        String   @id @default(cuid())
  paymentId String
  pdfUrl    String
  amount    Decimal  @db.Decimal(10, 2)
  generatedAt DateTime @default(now())

  // Relations
  payment Payment @relation(fields: [paymentId], references: [id], onDelete: Cascade)

  @@map("receipts")
}

model Message {
  id         String      @id @default(cuid())
  senderId   String
  receiverId String
  content    String
  type       MessageType @default(TEXT)
  isRead     Boolean     @default(false)
  createdAt  DateTime    @default(now())

  // Relations
  sender   User @relation("SentMessages", fields: [senderId], references: [id], onDelete: Cascade)
  receiver User @relation("ReceivedMessages", fields: [receiverId], references: [id], onDelete: Cascade)

  @@map("messages")
}

model Notification {
  id          String           @id @default(cuid())
  recipientId String
  title       String
  message     String
  type        NotificationType
  status      NotificationStatus @default(UNREAD)
  metadata    Json?
  scheduledAt DateTime?
  sentAt      DateTime?
  createdAt   DateTime         @default(now())

  // Relations
  recipient User @relation(fields: [recipientId], references: [id], onDelete: Cascade)

  @@map("notifications")
}

model Complaint {
  id         String          @id @default(cuid())
  propertyId String
  tenantId   String?
  subject    String
  message    String
  status     ComplaintStatus @default(OPEN)
  isAnonymous Boolean        @default(false)
  priority   Priority        @default(MEDIUM)
  response   String?
  respondedAt DateTime?
  createdAt  DateTime        @default(now())
  updatedAt  DateTime        @updatedAt

  // Relations
  property Property @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  tenant   Tenant?  @relation(fields: [tenantId], references: [id], onDelete: SetNull)

  @@map("complaints")
}

model Analytics {
  id        String        @id @default(cuid())
  ownerId   String?
  tenantId  String?
  type      AnalyticsType
  data      Json
  period    String        // e.g., "2024-01", "2024-Q1"
  createdAt DateTime      @default(now())

  // Relations
  owner  Owner?  @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  tenant Tenant? @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@map("analytics")
}

model LoginAttempt {
  id        String   @id @default(cuid())
  userId    String?
  email     String
  ipAddress String
  success   Boolean
  userAgent String?
  createdAt DateTime @default(now())

  // Relations
  user User? @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@map("login_attempts")
}

model AuditLog {
  id           String   @id @default(cuid())
  action       String
  userId       String?
  user         User?    @relation(fields: [userId], references: [id], onDelete: SetNull)
  resourceType String
  resourceId   String
  details      Json?
  ipAddress    String?
  userAgent    String?
  timestamp    DateTime @default(now())

  @@map("audit_logs")
}

model Report {
  id          String   @id @default(cuid())
  title       String
  type        String
  data        Json
  generatedBy String
  user        User     @relation(fields: [generatedBy], references: [id])
  createdAt   DateTime @default(now())
}

model MaintenanceRequest {
  id            String              @id @default(cuid())
  title         String
  description   String
  category      String // PLUMBING, ELECTRICAL, HVAC, APPLIANCE, STRUCTURAL, OTHER
  priority      String              @default("MEDIUM") // LOW, MEDIUM, HIGH, URGENT
  urgency       String              @default("MEDIUM") // LOW, MEDIUM, HIGH, CRITICAL
  status        String              @default("OPEN") // OPEN, IN_PROGRESS, COMPLETED, CANCELLED
  propertyId    String
  property      Property            @relation(fields: [propertyId], references: [id])
  requestedById String
  requestedBy   User                @relation(name: "MaintenanceRequester", fields: [requestedById], references: [id])
  assignedToId  String?
  assignedTo    User?               @relation(name: "MaintenanceAssignee", fields: [assignedToId], references: [id])
  resolution    String?
  assignedAt    DateTime?
  completedAt   DateTime?
  createdAt     DateTime            @default(now())
  updatedAt     DateTime            @updatedAt
  updates       MaintenanceUpdate[]
}

model MaintenanceUpdate {
  id                    String             @id @default(cuid())
  maintenanceRequestId  String
  maintenanceRequest    MaintenanceRequest @relation(fields: [maintenanceRequestId], references: [id], onDelete: Cascade)
  updatedById          String
  updatedBy            User               @relation(fields: [updatedById], references: [id])
  description          String
  changes              Json?
  createdAt            DateTime           @default(now())
}

model SystemSetting {
  id          String   @id @default(cuid())
  key         String   @unique
  value       String
  type        String   @default("STRING") // STRING, NUMBER, BOOLEAN, JSON
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model CalendarEvent {
  id          String   @id @default(cuid())
  title       String
  description String?
  startDate   DateTime
  endDate     DateTime
  type        String?
  relatedId   String?
  createdById String
  createdBy   User     @relation("CalendarEventCreator", fields: [createdById], references: [id])
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model FeatureFlag {
  id          String  @id @default(cuid())
  name        String  @unique
  isEnabled   Boolean @default(false)
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

// Enums
enum UserRole {
  SUPER_ADMIN
  OWNER
  MANAGER
  TENANT
}

enum PropertyType {
  APARTMENT
  HOUSE
  CONDO
  TOWNHOUSE
  STUDIO
  OTHER
}

enum PropertyStatus {
  AVAILABLE
  OCCUPIED
  MAINTENANCE
  UNAVAILABLE
}

enum LeaseStatus {
  ACTIVE
  EXPIRED
  TERMINATED
  PENDING
}

enum PaymentStatus {
  PENDING
  PAID
  OVERDUE
  CANCELLED
  REFUNDED
}

enum PaymentMethod {
  ONLINE
  CASH
  CHECK
  BANK_TRANSFER
}

enum MessageType {
  TEXT
  IMAGE
  DOCUMENT
  SYSTEM
}

enum NotificationType {
  PAYMENT_REMINDER
  LEASE_EXPIRY
  MAINTENANCE
  ALERT
  SYSTEM
  PUSH
}

enum NotificationStatus {
  UNREAD
  READ
  SENT
  FAILED
}

enum ComplaintStatus {
  OPEN
  IN_PROGRESS
  RESOLVED
  CLOSED
}

enum Priority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

enum AnalyticsType {
  REVENUE
  OCCUPANCY
  PAYMENT_HISTORY
  TENANT_METRICS
  PROPERTY_PERFORMANCE
}

================
File: prisma/seed.js
================
import { PrismaClient } from '@prisma/client';
import bcrypt from 'bcryptjs';

const prisma = new PrismaClient();

async function main() {
  console.log('ðŸŒ± Starting database seeding...');

  // Create Super Admin
  const hashedPassword = await bcrypt.hash('admin123', 12);
  
  const superAdmin = await prisma.user.upsert({
    where: { email: 'admin@rentalmanagement.com' },
    update: {},
    create: {
      email: 'admin@rentalmanagement.com',
      password: hashedPassword,
      role: 'SUPER_ADMIN',
      isActive: true,
    },
  });

  console.log('âœ… Super Admin created:', superAdmin.email);

  // Create Owner
  const ownerUser = await prisma.user.upsert({
    where: { email: 'owner@example.com' },
    update: {},
    create: {
      email: 'owner@example.com',
      password: hashedPassword,
      role: 'OWNER',
      isActive: true,
    },
  });

  const owner = await prisma.owner.upsert({
    where: { userId: ownerUser.id },
    update: {},
    create: {
      userId: ownerUser.id,
      firstName: 'John',
      lastName: 'Owner',
      phone: '+1234567890',
      company: 'ABC Properties LLC',
    },
  });

  console.log('âœ… Owner created:', ownerUser.email);

  // Create Manager
  const managerUser = await prisma.user.upsert({
    where: { email: 'manager@example.com' },
    update: {},
    create: {
      email: 'manager@example.com',
      password: hashedPassword,
      role: 'MANAGER',
      isActive: true,
    },
  });

  const manager = await prisma.manager.upsert({
    where: { userId: managerUser.id },
    update: {},
    create: {
      userId: managerUser.id,
      ownerId: owner.id,
      firstName: 'Jane',
      lastName: 'Manager',
      phone: '+1234567891',
    },
  });

  console.log('âœ… Manager created:', managerUser.email);

  // Create Tenant
  const tenantUser = await prisma.user.upsert({
    where: { email: 'tenant@example.com' },
    update: {},
    create: {
      email: 'tenant@example.com',
      password: hashedPassword,
      role: 'TENANT',
      isActive: true,
    },
  });

  const tenant = await prisma.tenant.upsert({
    where: { userId: tenantUser.id },
    update: {},
    create: {
      userId: tenantUser.id,
      firstName: 'Bob',
      lastName: 'Tenant',
      phone: '+1234567892',
      dateOfBirth: new Date('1990-01-01'),
      emergencyContact: 'Emergency Contact',
      emergencyPhone: '+1234567893',
    },
  });

  console.log('âœ… Tenant created:', tenantUser.email);

  // Create Properties
  const properties = await Promise.all([
    prisma.property.upsert({
      where: { id: '00000000-0000-0000-0000-000000000001' },
      update: {},
      create: {
        id: '00000000-0000-0000-0000-000000000001',
        ownerId: owner.id,
        name: 'Sunset Apartments',
        description: 'Beautiful apartment complex with modern amenities',
        address: '123 Main Street, City, State 12345',
        type: 'APARTMENT',
        units: 4,
        rentAmount: 1500.00,
        status: 'AVAILABLE',
        amenities: ['Parking', 'Pool', 'Gym', 'Laundry'],
        images: ['https://example.com/image1.jpg'],
      },
    }),
    prisma.property.upsert({
      where: { id: '00000000-0000-0000-0000-000000000002' },
      update: {},
      create: {
        id: '00000000-0000-0000-0000-000000000002',
        ownerId: owner.id,
        name: 'Ocean View House',
        description: 'Spacious house with ocean view',
        address: '456 Ocean Drive, Coastal City, State 12346',
        type: 'HOUSE',
        units: 1,
        rentAmount: 2500.00,
        status: 'OCCUPIED',
        amenities: ['Garden', 'Garage', 'Ocean View'],
        images: ['https://example.com/image2.jpg'],
      },
    }),
  ]);

  console.log('âœ… Properties created:', properties.length);

  // Create Lease
  const lease = await prisma.lease.upsert({
    where: { id: '00000000-0000-0000-0000-000000000001' },
    update: {},
    create: {
      id: '00000000-0000-0000-0000-000000000001',
      tenantId: tenant.id,
      propertyId: properties[1].id,
      startDate: new Date('2024-01-01'),
      endDate: new Date('2024-12-31'),
      rentAmount: 2500.00,
      securityDeposit: 2500.00,
      status: 'ACTIVE',
      terms: 'Standard lease terms and conditions',
    },
  });

  console.log('âœ… Lease created');

  // Create Payments
  const currentDate = new Date();
  const payments = [];

  for (let i = 0; i < 12; i++) {
    const dueDate = new Date(currentDate.getFullYear(), i, 1);
    const isPaid = i < 6; // First 6 months are paid

    const payment = await prisma.payment.create({
      data: {
        tenantId: tenant.id,
        leaseId: lease.id,
        amount: 2500.00,
        dueDate,
        status: isPaid ? 'PAID' : 'PENDING',
        paidDate: isPaid ? new Date(dueDate.getTime() + 24 * 60 * 60 * 1000) : null,
        paymentMethod: isPaid ? 'BANK_TRANSFER' : null,
        description: `Rent payment for ${dueDate.toLocaleString('default', { month: 'long', year: 'numeric' })}`,
      },
    });

    payments.push(payment);
  }

  console.log('âœ… Payments created:', payments.length);

  // Create Complaints
  const complaints = await Promise.all([
    prisma.complaint.create({
      data: {
        tenantId: tenant.id,
        propertyId: properties[1].id,
        managerId: manager.id,
        title: 'Heating Issue',
        description: 'The heating system is not working properly',
        category: 'MAINTENANCE',
        priority: 'HIGH',
        status: 'OPEN',
      },
    }),
    prisma.complaint.create({
      data: {
        tenantId: tenant.id,
        propertyId: properties[1].id,
        managerId: manager.id,
        title: 'Noise Complaint',
        description: 'Neighbors are too loud during night time',
        category: 'NOISE',
        priority: 'MEDIUM',
        status: 'IN_PROGRESS',
      },
    }),
  ]);

  console.log('âœ… Complaints created:', complaints.length);

  // Create Notifications
  const notifications = await Promise.all([
    prisma.notification.create({
      data: {
        userId: tenantUser.id,
        title: 'Payment Due Reminder',
        message: 'Your rent payment is due in 3 days',
        type: 'PAYMENT_REMINDER',
        isRead: false,
      },
    }),
    prisma.notification.create({
      data: {
        userId: managerUser.id,
        title: 'New Complaint Assigned',
        message: 'A new complaint has been assigned to you',
        type: 'COMPLAINT_ASSIGNED',
        isRead: false,
      },
    }),
  ]);

  console.log('âœ… Notifications created:', notifications.length);

  console.log('ðŸŽ‰ Database seeding completed successfully!');
  console.log('\nðŸ“§ Default user credentials:');
  console.log('Super Admin: admin@rentalmanagement.com / admin123');
  console.log('Owner: owner@example.com / admin123');
  console.log('Manager: manager@example.com / admin123');
  console.log('Tenant: tenant@example.com / admin123');
}

main()
  .catch((e) => {
    console.error('âŒ Error during seeding:', e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });

================
File: src/config/database.js
================
import { PrismaClient } from '@prisma/client';
import logger from './logger.js';

const prisma = new PrismaClient({
  log: [
    {
      emit: 'event',
      level: 'query',
    },
    {
      emit: 'event',
      level: 'error',
    },
    {
      emit: 'event',
      level: 'info',
    },
    {
      emit: 'event',
      level: 'warn',
    },
  ],
});

// Log database queries in development
if (process.env.NODE_ENV === 'development') {
  prisma.$on('query', (e) => {
    logger.debug(`Query: ${e.query}`);
    logger.debug(`Duration: ${e.duration}ms`);
  });
}

prisma.$on('error', (e) => {
  logger.error('Database error:', e);
});

// Graceful shutdown
process.on('SIGINT', async () => {
  logger.info('Shutting down gracefully...');
  await prisma.$disconnect();
  process.exit(0);
});

process.on('SIGTERM', async () => {
  logger.info('Shutting down gracefully...');
  await prisma.$disconnect();
  process.exit(0);
});

export default prisma;

================
File: src/config/environment.js
================
import dotenv from 'dotenv';
import { z } from 'zod';

dotenv.config();

// Environment validation schema
const envSchema = z.object({
  NODE_ENV: z.enum(['development', 'production', 'test']).default('development'),
  PORT: z.string().transform(Number).default('5000'),

  // Database
  DATABASE_URL: z.string().min(1, 'Database URL is required'),

  // JWT
  JWT_SECRET: z.string().min(32, 'JWT secret must be at least 32 characters'),
  JWT_EXPIRES_IN: z.string().default('7d'),

  // Email
  SMTP_HOST: z.string().optional(),
  SMTP_PORT: z.string().transform(Number).optional(),
  SMTP_USER: z.string().optional(),
  SMTP_PASS: z.string().optional(),

  // Cloudinary
  CLOUDINARY_CLOUD_NAME: z.string().optional(),
  CLOUDINARY_API_KEY: z.string().optional(),
  CLOUDINARY_API_SECRET: z.string().optional(),

  // Firebase
  FIREBASE_PROJECT_ID: z.string().optional(),
  FIREBASE_PRIVATE_KEY: z.string().optional(),
  FIREBASE_CLIENT_EMAIL: z.string().optional(),

  // Redis
  REDIS_URL: z.string().optional(),

  // Rate Limiting
  RATE_LIMIT_WINDOW_MS: z.string().transform(Number).default('900000'),
  RATE_LIMIT_MAX_REQUESTS: z.string().transform(Number).default('100'),

  // Frontend
  FRONTEND_URL: z.string().default('http://localhost:3000'),

  // Feature Flags
  ENABLE_SWAGGER: z.string().transform(Boolean).default('true'),
  ENABLE_RATE_LIMITING: z.string().transform(Boolean).default('true'),
  ENABLE_CORS: z.string().transform(Boolean).default('true'),
});

// Validate environment variables
let env;
try {
  env = envSchema.parse(process.env);
} catch (error) {
  console.error('âŒ Invalid environment variables:');
  console.error(error.errors);
  process.exit(1);
}

// Environment configuration object
export const config = {
  env: env.NODE_ENV,
  port: env.PORT,
  isDevelopment: env.NODE_ENV === 'development',
  isProduction: env.NODE_ENV === 'production',
  isTest: env.NODE_ENV === 'test',

  database: {
    url: env.DATABASE_URL,
  },

  jwt: {
    secret: env.JWT_SECRET,
    expiresIn: env.JWT_EXPIRES_IN,
  },

  email: {
    host: env.SMTP_HOST,
    port: env.SMTP_PORT,
    user: env.SMTP_USER,
    pass: env.SMTP_PASS,
    enabled: !!(env.SMTP_HOST && env.SMTP_USER && env.SMTP_PASS),
  },

  cloudinary: {
    cloudName: env.CLOUDINARY_CLOUD_NAME,
    apiKey: env.CLOUDINARY_API_KEY,
    apiSecret: env.CLOUDINARY_API_SECRET,
    enabled: !!(env.CLOUDINARY_CLOUD_NAME && env.CLOUDINARY_API_KEY && env.CLOUDINARY_API_SECRET),
  },

  firebase: {
    projectId: env.FIREBASE_PROJECT_ID,
    privateKey: env.FIREBASE_PRIVATE_KEY,
    clientEmail: env.FIREBASE_CLIENT_EMAIL,
    enabled: !!(env.FIREBASE_PROJECT_ID && env.FIREBASE_PRIVATE_KEY && env.FIREBASE_CLIENT_EMAIL),
  },

  redis: {
    url: env.REDIS_URL,
    enabled: !!env.REDIS_URL,
  },

  rateLimit: {
    windowMs: env.RATE_LIMIT_WINDOW_MS,
    maxRequests: env.RATE_LIMIT_MAX_REQUESTS,
  },

  frontend: {
    url: env.FRONTEND_URL,
  },

  features: {
    swagger: env.ENABLE_SWAGGER,
    rateLimiting: env.ENABLE_RATE_LIMITING,
    cors: env.ENABLE_CORS,
  },
};

export default config;

================
File: src/config/logger.js
================
import winston from 'winston';

const { combine, timestamp, printf, colorize, errors } = winston.format;

const logFormat = printf(({ level, message, timestamp, stack }) => {
  return `${timestamp} [${level}]: ${stack || message}`;
});

const logger = winston.createLogger({
  level: process.env.NODE_ENV === 'production' ? 'info' : 'debug',
  format: combine(
    errors({ stack: true }),
    timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),
    logFormat
  ),
  defaultMeta: { service: 'rental-management' },
  transports: [
    new winston.transports.File({ filename: 'logs/error.log', level: 'error' }),
    new winston.transports.File({ filename: 'logs/combined.log' }),
  ],
});

if (process.env.NODE_ENV !== 'production') {
  logger.add(
    new winston.transports.Console({
      format: combine(colorize(), logFormat),
    })
  );
}

export default logger;

================
File: src/config/redis.js
================
import redis from 'redis';
import logger from './logger.js';

let redisClient = null;

export const initializeRedis = async () => {
  try {
    redisClient = redis.createClient({
      url: process.env.REDIS_URL || 'redis://localhost:6379',
      socket: {
        connectTimeout: 60000,
        lazyConnect: true,
      },
    });

    redisClient.on('error', (err) => {
      logger.error('Redis Client Error:', err);
    });

    redisClient.on('connect', () => {
      logger.info('Redis client connected');
    });

    redisClient.on('ready', () => {
      logger.info('Redis client ready');
    });

    redisClient.on('end', () => {
      logger.info('Redis client disconnected');
    });

    await redisClient.connect();
    return redisClient;
  } catch (error) {
    logger.error('Failed to initialize Redis:', error);
    // Don't throw error to allow app to work without Redis
    return null;
  }
};

export const getRedisClient = () => {
  return redisClient;
};

export const closeRedis = async () => {
  if (redisClient) {
    await redisClient.quit();
    redisClient = null;
  }
};

// Cache helper functions
export const setCache = async (key, value, expiration = 3600) => {
  if (!redisClient) return false;
  
  try {
    await redisClient.setEx(key, expiration, JSON.stringify(value));
    return true;
  } catch (error) {
    logger.error('Redis set error:', error);
    return false;
  }
};

export const getCache = async (key) => {
  if (!redisClient) return null;
  
  try {
    const value = await redisClient.get(key);
    return value ? JSON.parse(value) : null;
  } catch (error) {
    logger.error('Redis get error:', error);
    return null;
  }
};

export const deleteCache = async (key) => {
  if (!redisClient) return false;
  
  try {
    await redisClient.del(key);
    return true;
  } catch (error) {
    logger.error('Redis delete error:', error);
    return false;
  }
};

export const flushCache = async () => {
  if (!redisClient) return false;
  
  try {
    await redisClient.flushAll();
    return true;
  } catch (error) {
    logger.error('Redis flush error:', error);
    return false;
  }
};

export default {
  initializeRedis,
  getRedisClient,
  closeRedis,
  setCache,
  getCache,
  deleteCache,
  flushCache,
};

================
File: src/config/swagger.js
================
import swaggerJsdoc from 'swagger-jsdoc';

const options = {
  definition: {
    openapi: '3.0.0',
    info: {
      title: 'Rental Management System API',
      version: '1.0.0',
      description: 'Production-ready rental management system backend API',
      contact: {
        name: 'API Support',
        email: 'support@rentalmanagement.com',
      },
    },
    servers: [
      {
        url: process.env.NODE_ENV === 'production' 
          ? 'https://your-domain.com/api/v1' 
          : `http://localhost:${process.env.PORT || 5000}/api/v1`,
        description: process.env.NODE_ENV === 'production' ? 'Production server' : 'Development server',
      },
    ],
    components: {
      securitySchemes: {
        bearerAuth: {
          type: 'http',
          scheme: 'bearer',
          bearerFormat: 'JWT',
        },
      },
    },
    security: [
      {
        bearerAuth: [],
      },
    ],
  },
  apis: ['./src/modules/*/routes/*.js', './src/modules/*/controllers/*.js'],
};

const specs = swaggerJsdoc(options);

export default specs;

================
File: src/middleware/audit.js
================
import { logActivity } from '../services/auditService.js';
import logger from '../config/logger.js';

export const auditMiddleware = (action, resourceType) => {
  return async (req, res, next) => {
    const originalSend = res.send;
    
    res.send = function(data) {
      // Only log on successful operations (2xx status codes)
      if (res.statusCode >= 200 && res.statusCode < 300) {
        setImmediate(async () => {
          try {
            const resourceId = req.params.id || req.body?.id || 'unknown';
            await logActivity(
              action,
              req.user?.userId,
              resourceType,
              resourceId,
              {
                ipAddress: req.ip || req.connection.remoteAddress,
                userAgent: req.get('User-Agent'),
                method: req.method,
                url: req.originalUrl,
                body: req.method !== 'GET' ? req.body : undefined
              }
            );
          } catch (error) {
            logger.error('Error in audit middleware:', error);
          }
        });
      }
      
      return originalSend.call(this, data);
    };
    
    next();
  };
};

export const auditLogin = async (req, res, next) => {
  const originalSend = res.send;
  
  res.send = function(data) {
    if (res.statusCode === 200) {
      setImmediate(async () => {
        try {
          const parsedData = JSON.parse(data);
          if (parsedData.user) {
            await logActivity(
              'LOGIN',
              parsedData.user.id,
              'USER',
              parsedData.user.id,
              {
                ipAddress: req.ip || req.connection.remoteAddress,
                userAgent: req.get('User-Agent'),
                email: parsedData.user.email
              }
            );
          }
        } catch (error) {
          logger.error('Error in login audit:', error);
        }
      });
    }
    
    return originalSend.call(this, data);
  };
  
  next();
};

================
File: src/middleware/auth.js
================
import jwt from 'jsonwebtoken';
import prisma from '../config/database.js';
import logger from '../config/logger.js';

export const authenticate = async (req, res, next) => {
  try {
    const token = req.header('Authorization')?.replace('Bearer ', '');

    if (!token) {
      return res.status(401).json({
        error: 'Access denied',
        message: 'No token provided',
      });
    }

    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    const user = await prisma.user.findUnique({
      where: { id: decoded.userId },
      include: {
        tenant: true,
        owner: true,
        manager: {
          include: {
            owner: true,
          },
        },
      },
    });

    if (!user || !user.isActive) {
      return res.status(401).json({
        error: 'Access denied',
        message: 'Invalid token or user inactive',
      });
    }

    req.user = {
      ...user,
      userId: user.id,
    };
    next();
  } catch (error) {
    logger.error('Authentication error:', error);
    return res.status(401).json({
      error: 'Access denied',
      message: 'Invalid token',
    });
  }
};

export const authorize = (...roles) => {
  return (req, res, next) => {
    if (!req.user) {
      return res.status(401).json({
        error: 'Access denied',
        message: 'User not authenticated',
      });
    }

    if (!roles.includes(req.user.role)) {
      return res.status(403).json({
        error: 'Forbidden',
        message: 'Insufficient permissions',
      });
    }

    next();
  };
};

export const checkPermissions = (requiredPermissions) => {
  return (req, res, next) => {
    if (!req.user) {
      return res.status(401).json({
        error: 'Access denied',
        message: 'User not authenticated',
      });
    }

    // Super admin and owners have all permissions
    if (['SUPER_ADMIN', 'OWNER'].includes(req.user.role)) {
      return next();
    }

    // Check manager permissions
    if (req.user.role === 'MANAGER' && req.user.manager) {
      const userPermissions = req.user.manager.permissions || {};
      const hasPermission = requiredPermissions.every(permission => 
        userPermissions[permission] === true
      );

      if (!hasPermission) {
        return res.status(403).json({
          error: 'Forbidden',
          message: 'Insufficient permissions',
        });
      }
    }

    next();
  };
};

================
File: src/middleware/errorHandler.js
================
import logger from '../config/logger.js';

export const errorHandler = (err, req, res, next) => {
  logger.error('Error occurred:', {
    error: err.message,
    stack: err.stack,
    url: req.url,
    method: req.method,
    ip: req.ip,
    userAgent: req.get('User-Agent'),
    userId: req.user?.id,
  });

  // Prisma errors
  if (err.code === 'P2002') {
    return res.status(409).json({
      error: 'Conflict',
      message: 'A record with this data already exists',
    });
  }

  if (err.code === 'P2025') {
    return res.status(404).json({
      error: 'Not found',
      message: 'The requested resource was not found',
    });
  }

  // JWT errors
  if (err.name === 'JsonWebTokenError') {
    return res.status(401).json({
      error: 'Invalid token',
      message: 'The provided token is invalid',
    });
  }

  if (err.name === 'TokenExpiredError') {
    return res.status(401).json({
      error: 'Token expired',
      message: 'The provided token has expired',
    });
  }

  // Validation errors
  if (err.name === 'ValidationError') {
    return res.status(400).json({
      error: 'Validation failed',
      message: err.message,
    });
  }

  // Multer errors
  if (err.code === 'LIMIT_FILE_SIZE') {
    return res.status(400).json({
      error: 'File too large',
      message: 'The uploaded file exceeds the size limit',
    });
  }

  // Default error
  const statusCode = err.statusCode || 500;
  const message = process.env.NODE_ENV === 'production' 
    ? 'Internal server error' 
    : err.message;

  res.status(statusCode).json({
    error: 'Internal server error',
    message,
    ...(process.env.NODE_ENV !== 'production' && { stack: err.stack }),
  });
};

export const notFoundHandler = (req, res) => {
  res.status(404).json({
    error: 'Not found',
    message: `Route ${req.originalUrl} not found`,
  });
};

export const asyncHandler = (fn) => {
  return (req, res, next) => {
    Promise.resolve(fn(req, res, next)).catch(next);
  };
};

================
File: src/middleware/rateLimiter.js
================
import rateLimit from 'express-rate-limit';
import slowDown from 'express-slow-down';
import ExpressBrute from 'express-brute';
import logger from '../config/logger.js';

// General API rate limiter
export const apiLimiter = rateLimit({
  windowMs: parseInt(process.env.RATE_LIMIT_WINDOW_MS) || 15 * 60 * 1000, // 15 minutes
  max: parseInt(process.env.RATE_LIMIT_MAX_REQUESTS) || 100,
  message: {
    error: 'Too many requests',
    message: 'Too many requests from this IP, please try again later.',
  },
  standardHeaders: true,
  legacyHeaders: false,
  handler: (req, res) => {
    logger.warn(`Rate limit exceeded for IP: ${req.ip}`);
    res.status(429).json({
      error: 'Too many requests',
      message: 'Too many requests from this IP, please try again later.',
    });
  },
});

// Strict rate limiter for auth endpoints
export const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 5, // limit each IP to 5 requests per windowMs
  message: {
    error: 'Too many authentication attempts',
    message: 'Too many authentication attempts, please try again later.',
  },
  skipSuccessfulRequests: true,
});

// Speed limiter for general API
export const speedLimiter = slowDown({
  windowMs: 15 * 60 * 1000, // 15 minutes
  delayAfter: 50, // allow 50 requests per windowMs without delay
  delayMs: () => 500, // add 500ms delay per request after delayAfter
});

// Brute force protection for login
const store = new ExpressBrute.MemoryStore();
export const bruteForce = new ExpressBrute(store, {
  freeRetries: 3,
  minWait: 5 * 60 * 1000, // 5 minutes
  maxWait: 60 * 60 * 1000, // 1 hour
  lifetime: 24 * 60 * 60, // 1 day (seconds)
  handleStoreError: (error) => {
    logger.error('Brute force store error:', error);
    throw error;
  },
});

================
File: src/middleware/security.js
================
import rateLimit from 'express-rate-limit';
import ExpressBrute from 'express-brute';
import helmet from 'helmet';
import logger from '../config/logger.js';

// Brute force protection for login attempts
const bruteStore = new ExpressBrute.MemoryStore();
export const loginBruteForce = new ExpressBrute(bruteStore, {
  freeRetries: 5,
  minWait: 5 * 60 * 1000, // 5 minutes
  maxWait: 60 * 60 * 1000, // 1 hour
  lifetime: 24 * 60 * 60, // 24 hours
  failCallback: (req, res, next, nextValidRequestDate) => {
    logger.warn(`Brute force attempt detected from IP: ${req.ip}`);
    res.status(429).json({
      error: 'Too many failed attempts',
      message: `Try again after ${new Date(nextValidRequestDate)}`,
      retryAfter: nextValidRequestDate
    });
  }
});

// Rate limiting for sensitive operations
export const sensitiveOperationLimit = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 10, // 10 requests per window
  message: {
    error: 'Too many requests',
    message: 'Rate limit exceeded for sensitive operations'
  },
  standardHeaders: true,
  legacyHeaders: false
});

// Parameter pollution prevention
export const preventParameterPollution = (req, res, next) => {
  const pollutionKeys = ['id', 'email', 'role'];
  
  // Check query parameters (safe for all requests)
  if (req.query) {
    for (const key of pollutionKeys) {
      if (Array.isArray(req.query[key])) {
        req.query[key] = req.query[key][0];
      }
    }
  }

  // **THE FIX**: Only check body parameters if the body exists.
  if (req.body) {
    for (const key of pollutionKeys) {
      if (Array.isArray(req.body[key])) {
        req.body[key] = req.body[key][0];
      }
    }
  }
  
  next();
};

// CSRF protection
export const csrfProtection = (req, res, next) => {
  if (['POST', 'PUT', 'DELETE', 'PATCH'].includes(req.method)) {
    const token = req.headers['x-csrf-token'] || req.body.csrfToken;
    const sessionToken = req.session?.csrfToken;
    
    if (!token || token !== sessionToken) {
      return res.status(403).json({
        error: 'CSRF token mismatch',
        message: 'Invalid or missing CSRF token'
      });
    }
  }
  
  next();
};

// Security headers
export const securityHeaders = helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      scriptSrc: ["'self'"],
      imgSrc: ["'self'", "data:", "https:"],
      connectSrc: ["'self'"],
      fontSrc: ["'self'"],
      objectSrc: ["'none'"],
      mediaSrc: ["'self'"],
      frameSrc: ["'none'"]
    }
  },
  hsts: {
    maxAge: 31536000,
    includeSubDomains: true,
    preload: true
  }
});

// Input sanitization
export const sanitizeInput = (req, res, next) => {
  const sanitize = (obj) => {
    for (const key in obj) {
      if (typeof obj[key] === 'string') {
        obj[key] = obj[key].trim();
        // Remove potential XSS patterns
        obj[key] = obj[key].replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '');
      } else if (typeof obj[key] === 'object' && obj[key] !== null) {
        sanitize(obj[key]);
      }
    }
  };

  if (req.body) sanitize(req.body);
  if (req.query) sanitize(req.query);
  if (req.params) sanitize(req.params);

  next();
};

================
File: src/middleware/upload.js
================
import multer from 'multer';
import { v4 as uuidv4 } from 'uuid';

// Configure multer for memory storage
const storage = multer.memoryStorage();

// File filter function
const fileFilter = (req, file, cb) => {
  // Allow images
  if (file.mimetype.startsWith('image/')) {
    cb(null, true);
  } else if (file.mimetype === 'application/pdf') {
    cb(null, true);
  } else if (file.mimetype.includes('document') || file.mimetype.includes('text')) {
    cb(null, true);
  } else {
    cb(new Error('Invalid file type. Only images, PDFs, and documents are allowed.'), false);
  }
};

// Configure multer
export const upload = multer({
  storage,
  fileFilter,
  limits: {
    fileSize: 10 * 1024 * 1024, // 10MB limit
    files: 10, // Maximum 10 files at once
  },
});

// Handle multer errors
export const handleUploadError = (error, req, res, next) => {
  if (error instanceof multer.MulterError) {
    if (error.code === 'LIMIT_FILE_SIZE') {
      return res.status(400).json({
        error: 'File too large',
        message: 'File size cannot exceed 10MB',
      });
    }
    if (error.code === 'LIMIT_FILE_COUNT') {
      return res.status(400).json({
        error: 'Too many files',
        message: 'Cannot upload more than 10 files at once',
      });
    }
    if (error.code === 'LIMIT_UNEXPECTED_FILE') {
      return res.status(400).json({
        error: 'Unexpected field',
        message: 'Unexpected file field',
      });
    }
  }
  
  if (error.message.includes('Invalid file type')) {
    return res.status(400).json({
      error: 'Invalid file type',
      message: error.message,
    });
  }
  
  next(error);
};

================
File: src/middleware/validation.js
================
import { validationResult, body, query } from 'express-validator';
import { ZodError } from 'zod';
import logger from '../config/logger.js';

export const handleValidationErrors = (req, res, next) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    logger.warn('Validation errors:', errors.array());
    return res.status(400).json({
      error: 'Validation failed',
      message: 'Invalid input data',
      details: errors.array(),
    });
  }
  next();
};

export const zodValidate = (schema) => {
  return (req, res, next) => {
    try {
      schema.parse(req.body);
      next();
    } catch (error) {
      if (error instanceof ZodError) {
        logger.warn('Zod validation errors:', error.errors);
        return res.status(400).json({
          error: 'Validation failed',
          message: 'Invalid input data',
          details: error.errors,
        });
      }
      next(error);
    }
  };
};

// Sanitize input to prevent parameter pollution
export const sanitizeInput = (req, res, next) => {
  const sanitize = (obj) => {
    for (const key in obj) {
      if (Array.isArray(obj[key]) && obj[key].length === 1) {
        obj[key] = obj[key][0];
      } else if (typeof obj[key] === 'object' && obj[key] !== null) {
        sanitize(obj[key]);
      }
    }
  };

  if (req.query) sanitize(req.query);
  if (req.body) sanitize(req.body);
  if (req.params) sanitize(req.params);

  next();
};

// Property validations
export const validateProperty = [
  body('name').trim().isLength({ min: 2, max: 100 }).withMessage('Property name must be between 2 and 100 characters'),
  body('address').trim().isLength({ min: 5, max: 200 }).withMessage('Address must be between 5 and 200 characters'),
  body('type').isIn(['APARTMENT', 'HOUSE', 'CONDO', 'TOWNHOUSE', 'STUDIO', 'OTHER']).withMessage('Invalid property type'),
  body('units').optional().isInt({ min: 1 }).withMessage('Units must be a positive integer'),
  body('rentAmount').isFloat({ min: 0 }).withMessage('Rent amount must be a positive number'),
  body('amenities').optional().isArray().withMessage('Amenities must be an array'),
  handleValidationErrors,
];

export const validatePropertyUpdate = [
  body('name').optional().trim().isLength({ min: 2, max: 100 }).withMessage('Property name must be between 2 and 100 characters'),
  body('address').optional().trim().isLength({ min: 5, max: 200 }).withMessage('Address must be between 5 and 200 characters'),
  body('type').optional().isIn(['APARTMENT', 'HOUSE', 'CONDO', 'TOWNHOUSE', 'STUDIO', 'OTHER']).withMessage('Invalid property type'),
  body('units').optional().isInt({ min: 1 }).withMessage('Units must be a positive integer'),
  body('rentAmount').optional().isFloat({ min: 0 }).withMessage('Rent amount must be a positive number'),
  body('status').optional().isIn(['AVAILABLE', 'OCCUPIED', 'MAINTENANCE', 'UNAVAILABLE']).withMessage('Invalid status'),
  body('amenities').optional().isArray().withMessage('Amenities must be an array'),
  handleValidationErrors,
];

// Tenant validations
export const validateTenant = [
  body('email').isEmail().normalizeEmail().withMessage('Please provide a valid email'),
  body('firstName').trim().isLength({ min: 2, max: 50 }).withMessage('First name must be between 2 and 50 characters'),
  body('lastName').trim().isLength({ min: 2, max: 50 }).withMessage('Last name must be between 2 and 50 characters'),
  body('phone').isMobilePhone().withMessage('Please provide a valid phone number'),
  body('propertyId').isUUID().withMessage('Property ID must be a valid UUID'),
  body('emergencyContact').optional().isObject().withMessage('Emergency contact must be an object'),
  body('moveInDate').optional().isISO8601().withMessage('Move in date must be a valid date'),
  handleValidationErrors,
];

export const validateTenantUpdate = [
  body('firstName').optional().trim().isLength({ min: 2, max: 50 }).withMessage('First name must be between 2 and 50 characters'),
  body('lastName').optional().trim().isLength({ min: 2, max: 50 }).withMessage('Last name must be between 2 and 50 characters'),
  body('phone').optional().isMobilePhone().withMessage('Please provide a valid phone number'),
  body('emergencyContact').optional().isObject().withMessage('Emergency contact must be an object'),
  body('moveInDate').optional().isISO8601().withMessage('Move in date must be a valid date'),
  handleValidationErrors,
];

// Manager validations
export const validateManager = [
  body('email').isEmail().normalizeEmail().withMessage('Please provide a valid email'),
  body('firstName').trim().isLength({ min: 2, max: 50 }).withMessage('First name must be between 2 and 50 characters'),
  body('lastName').trim().isLength({ min: 2, max: 50 }).withMessage('Last name must be between 2 and 50 characters'),
  body('phone').optional().isMobilePhone().withMessage('Please provide a valid phone number'),
  body('permissions').optional().isObject().withMessage('Permissions must be an object'),
  handleValidationErrors,
];

export const validateManagerUpdate = [
  body('firstName').optional().trim().isLength({ min: 2, max: 50 }).withMessage('First name must be between 2 and 50 characters'),
  body('lastName').optional().trim().isLength({ min: 2, max: 50 }).withMessage('Last name must be between 2 and 50 characters'),
  body('phone').optional().isMobilePhone().withMessage('Please provide a valid phone number'),
  body('permissions').optional().isObject().withMessage('Permissions must be an object'),
  handleValidationErrors,
];

// Lease validations
export const validateLease = [
  body('tenantId').isUUID().withMessage('Tenant ID must be a valid UUID'),
  body('propertyId').isUUID().withMessage('Property ID must be a valid UUID'),
  body('startDate').isISO8601().withMessage('Start date must be a valid date'),
  body('endDate').isISO8601().withMessage('End date must be a valid date'),
  body('rentAmount').isFloat({ min: 0 }).withMessage('Rent amount must be a positive number'),
  body('securityDeposit').optional().isFloat({ min: 0 }).withMessage('Security deposit must be a positive number'),
  body('terms').optional().isString().withMessage('Terms must be a string'),
  handleValidationErrors,
];

export const validateLeaseUpdate = [
  body('startDate').optional().isISO8601().withMessage('Start date must be a valid date'),
  body('endDate').optional().isISO8601().withMessage('End date must be a valid date'),
  body('rentAmount').optional().isFloat({ min: 0 }).withMessage('Rent amount must be a positive number'),
  body('securityDeposit').optional().isFloat({ min: 0 }).withMessage('Security deposit must be a positive number'),
  body('status').optional().isIn(['ACTIVE', 'EXPIRED', 'TERMINATED', 'PENDING']).withMessage('Invalid lease status'),
  body('terms').optional().isString().withMessage('Terms must be a string'),
  handleValidationErrors,
];

// Analytics validations
export const validateAnalyticsQuery = [
  query('startDate').optional().isISO8601().withMessage('Start date must be a valid date'),
  query('endDate').optional().isISO8601().withMessage('End date must be a valid date'),
  query('propertyId').optional().isUUID().withMessage('Property ID must be a valid UUID'),
  query('period').optional().isIn(['daily', 'weekly', 'monthly', 'yearly']).withMessage('Invalid period'),
  handleValidationErrors,
];

// Notification validations
export const validateNotification = [
  body('title').notEmpty().withMessage('Title is required'),
  body('message').notEmpty().withMessage('Message is required'),
  body('type').isIn(['PAYMENT_REMINDER', 'LEASE_EXPIRY', 'MAINTENANCE_UPDATE', 'COMPLAINT_UPDATE', 'GENERAL']).withMessage('Invalid notification type'),
  body('userId').optional().isUUID().withMessage('User ID must be a valid UUID'),
  body('recipientType').optional().isIn(['USER', 'ROLE', 'ALL']).withMessage('Invalid recipient type'),
  body('recipientValue').optional().isString().withMessage('Recipient value must be a string'),
  handleValidationErrors,
];

// Device token validation
export const validateDeviceToken = [
  body('token').notEmpty().withMessage('Device token is required'),
  body('platform').isIn(['ios', 'android', 'web']).withMessage('Invalid platform'),
  handleValidationErrors,
];

// Bulk operations validation
export const validateBulkOperation = [
  body('ids').isArray({ min: 1 }).withMessage('IDs array is required and must not be empty'),
  body('ids.*').isUUID().withMessage('Each ID must be a valid UUID'),
  body('action').notEmpty().withMessage('Action is required'),
  handleValidationErrors,
];

// Payment validations
export const validatePayment = [
  body('leaseId').isUUID().withMessage('Lease ID must be a valid UUID'),
  body('amount').isFloat({ min: 0 }).withMessage('Amount must be a positive number'),
  body('dueDate').isISO8601().withMessage('Due date must be a valid date'),
  body('method').optional().isIn(['ONLINE', 'CASH', 'CHECK', 'BANK_TRANSFER']).withMessage('Invalid payment method'),
  body('notes').optional().isString().withMessage('Notes must be a string'),
  handleValidationErrors,
];

export const validatePaymentUpdate = [
  body('amount').optional().isFloat({ min: 0 }).withMessage('Amount must be a positive number'),
  body('dueDate').optional().isISO8601().withMessage('Due date must be a valid date'),
  body('paidDate').optional().isISO8601().withMessage('Paid date must be a valid date'),
  body('method').optional().isIn(['ONLINE', 'CASH', 'CHECK', 'BANK_TRANSFER']).withMessage('Invalid payment method'),
  body('status').optional().isIn(['PENDING', 'PAID', 'OVERDUE', 'CANCELLED', 'REFUNDED']).withMessage('Invalid payment status'),
  body('transactionId').optional().isString().withMessage('Transaction ID must be a string'),
  body('notes').optional().isString().withMessage('Notes must be a string'),
  handleValidationErrors,
];

// Complaint validations
export const validateComplaint = [
  body('title').trim().isLength({ min: 5, max: 100 }).withMessage('Title must be between 5 and 100 characters'),
  body('description').trim().isLength({ min: 10, max: 1000 }).withMessage('Description must be between 10 and 1000 characters'),
  body('category').isIn(['MAINTENANCE', 'NOISE', 'PEST_CONTROL', 'SAFETY', 'OTHER']).withMessage('Invalid complaint category'),
  body('priority').optional().isIn(['LOW', 'MEDIUM', 'HIGH', 'URGENT']).withMessage('Invalid priority level'),
  body('propertyId').optional().isUUID().withMessage('Property ID must be a valid UUID'),
  handleValidationErrors,
];

export const validateComplaintUpdate = [
  body('title').optional().trim().isLength({ min: 5, max: 100 }).withMessage('Title must be between 5 and 100 characters'),
  body('description').optional().trim().isLength({ min: 10, max: 1000 }).withMessage('Description must be between 10 and 1000 characters'),
  body('category').optional().isIn(['MAINTENANCE', 'NOISE', 'PEST_CONTROL', 'SAFETY', 'OTHER']).withMessage('Invalid complaint category'),
  body('priority').optional().isIn(['LOW', 'MEDIUM', 'HIGH', 'URGENT']).withMessage('Invalid priority level'),
  body('status').optional().isIn(['OPEN', 'IN_PROGRESS', 'RESOLVED', 'CLOSED']).withMessage('Invalid complaint status'),
  handleValidationErrors,
];

export const validateMaintenanceRequest = (req, res, next) => {
  const maintenanceRequestSchema = z.object({
    title: z.string().min(1, 'Title is required').max(255),
    description: z.string().min(1, 'Description is required'),
    category: z.enum(['PLUMBING', 'ELECTRICAL', 'HVAC', 'APPLIANCE', 'STRUCTURAL', 'OTHER']),
    priority: z.enum(['LOW', 'MEDIUM', 'HIGH', 'URGENT']).optional(),
    urgency: z.enum(['LOW', 'MEDIUM', 'HIGH', 'CRITICAL']).optional(),
    propertyId: z.string().cuid(),
  });

  validateSchema(maintenanceRequestSchema)(req, res, next);
};

export const validateMaintenanceUpdate = (req, res, next) => {
  const maintenanceUpdateSchema = z.object({
    title: z.string().min(1).max(255).optional(),
    description: z.string().min(1).optional(),
    category: z.enum(['PLUMBING', 'ELECTRICAL', 'HVAC', 'APPLIANCE', 'STRUCTURAL', 'OTHER']).optional(),
    priority: z.enum(['LOW', 'MEDIUM', 'HIGH', 'URGENT']).optional(),
    urgency: z.enum(['LOW', 'MEDIUM', 'HIGH', 'CRITICAL']).optional(),
    status: z.enum(['OPEN', 'IN_PROGRESS', 'COMPLETED', 'CANCELLED']).optional(),
    resolution: z.string().optional(),
  });

  validateSchema(maintenanceUpdateSchema)(req, res, next);
};

export const validateSystemSetting = (req, res, next) => {
  const systemSettingSchema = z.object({
    value: z.string().min(1),
  });

  validateSchema(systemSettingSchema)(req, res, next);
};

export const validateUser = (req, res, next) => {
  const userSchema = z.object({
    email: z.string().email(),
    password: z.string().min(6),
    role: z.enum(['SUPER_ADMIN', 'OWNER', 'MANAGER', 'TENANT']),
    companyName: z.string().optional(),
    phone: z.string().optional(),
  });

  validateSchema(userSchema)(req, res, next);
};

export const validateUserUpdate = (req, res, next) => {
  const userUpdateSchema = z.object({
    email: z.string().email().optional(),
    password: z.string().min(6).optional(),
    role: z.enum(['SUPER_ADMIN', 'OWNER', 'MANAGER', 'TENANT']).optional(),
    companyName: z.string().optional(),
    phone: z.string().optional(),
  });

  validateSchema(userUpdateSchema)(req, res, next);
};

================
File: src/modules/admin/controllers/adminController.js
================
import prisma from '../../../config/database.js';
import logger from '../../../config/logger.js';
import { successResponse, errorResponse } from '../../../utils/responseHelpers.js';
import { hashPassword } from '../../../utils/helpers.js';

export const getDashboardStats = async (req, res) => {
  try {
    const [
      totalUsers,
      totalProperties,
      totalTenants,
      totalOwners,
      totalManagers,
      activeLeases,
      pendingPayments,
      openComplaints,
      openMaintenanceRequests,
    ] = await Promise.all([
      prisma.user.count(),
      prisma.property.count(),
      prisma.tenant.count({ where: { isActive: true } }),
      prisma.owner.count(),
      prisma.manager.count(),
      prisma.lease.count({ where: { status: 'ACTIVE' } }),
      prisma.payment.count({ where: { status: 'PENDING' } }),
      prisma.complaint.count({ where: { status: { in: ['OPEN', 'IN_PROGRESS'] } } }),
      prisma.maintenanceRequest.count({ where: { status: { in: ['OPEN', 'IN_PROGRESS'] } } }),
    ]);

    // Recent activities
    const recentActivities = await prisma.auditLog.findMany({
      take: 10,
      orderBy: { createdAt: 'desc' },
      include: {
        user: {
          select: {
            id: true,
            email: true,
            firstName: true,
            lastName: true,
          },
        },
      },
    });

    // Revenue data for last 12 months
    const twelveMonthsAgo = new Date();
    twelveMonthsAgo.setMonth(twelveMonthsAgo.getMonth() - 12);

    const revenueData = await prisma.payment.groupBy({
      by: ['createdAt'],
      where: {
        status: 'PAID',
        createdAt: {
          gte: twelveMonthsAgo,
        },
      },
      _sum: {
        amount: true,
      },
    });

    const stats = {
      overview: {
        totalUsers,
        totalProperties,
        totalTenants,
        totalOwners,
        totalManagers,
        activeLeases,
        pendingPayments,
        openComplaints,
        openMaintenanceRequests,
      },
      recentActivities,
      revenueData,
    };

    return successResponse(res, 'Dashboard stats retrieved successfully', stats);
  } catch (error) {
    logger.error('Error getting dashboard stats:', error);
    return errorResponse(res, 'Failed to retrieve dashboard stats');
  }
};

export const getAllUsers = async (req, res) => {
  try {
    const { page = 1, limit = 10, role, status, search } = req.query;
    const skip = (parseInt(page) - 1) * parseInt(limit);

    const where = {};
    if (role) where.role = role;
    if (status === 'active') where.isActive = true;
    if (status === 'inactive') where.isActive = false;
    if (search) {
      where.OR = [
        { firstName: { contains: search, mode: 'insensitive' } },
        { lastName: { contains: search, mode: 'insensitive' } },
        { email: { contains: search, mode: 'insensitive' } },
      ];
    }

    const [users, total] = await Promise.all([
      prisma.user.findMany({
        where,
        skip,
        take: parseInt(limit),
        select: {
          id: true,
          email: true,
          firstName: true,
          lastName: true,
          role: true,
          isActive: true,
          createdAt: true,
          lastLogin: true,
          tenant: {
            select: {
              id: true,
              phone: true,
            },
          },
          owner: {
            select: {
              id: true,
              phone: true,
            },
          },
          manager: {
            select: {
              id: true,
              phone: true,
            },
          },
        },
        orderBy: { createdAt: 'desc' },
      }),
      prisma.user.count({ where }),
    ]);

    return successResponse(res, 'Users retrieved successfully', {
      users,
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total,
        pages: Math.ceil(total / parseInt(limit)),
      },
    });
  } catch (error) {
    logger.error('Error getting users:', error);
    return errorResponse(res, 'Failed to retrieve users');
  }
};

export const createUser = async (req, res) => {
  try {
    const { email, password, firstName, lastName, role, phone, address } = req.body;

    // Check if user already exists
    const existingUser = await prisma.user.findUnique({
      where: { email },
    });

    if (existingUser) {
      return errorResponse(res, 'User with this email already exists', 400);
    }

    const hashedPassword = await hashPassword(password);

    const user = await prisma.user.create({
      data: {
        email,
        password: hashedPassword,
        firstName,
        lastName,
        role,
        isActive: true,
      },
      select: {
        id: true,
        email: true,
        firstName: true,
        lastName: true,
        role: true,
        isActive: true,
        createdAt: true,
      },
    });

    // Create role-specific record
    if (role === 'TENANT') {
      await prisma.tenant.create({
        data: {
          userId: user.id,
          firstName,
          lastName,
          phone: phone || '',
          address: address || '',
          isActive: true,
        },
      });
    } else if (role === 'OWNER') {
      await prisma.owner.create({
        data: {
          userId: user.id,
          firstName,
          lastName,
          phone: phone || '',
          address: address || '',
        },
      });
    } else if (role === 'MANAGER') {
      await prisma.manager.create({
        data: {
          userId: user.id,
          firstName,
          lastName,
          phone: phone || '',
          address: address || '',
          isActive: true,
        },
      });
    }

    logger.info(`User created by admin: ${user.email} (${user.role})`);

    return successResponse(res, 'User created successfully', user, 201);
  } catch (error) {
    logger.error('Error creating user:', error);
    return errorResponse(res, 'Failed to create user');
  }
};

export const updateUser = async (req, res) => {
  try {
    const { id } = req.params;
    const { firstName, lastName, email, isActive, phone, address } = req.body;

    const user = await prisma.user.findUnique({
      where: { id },
      include: {
        tenant: true,
        owner: true,
        manager: true,
      },
    });

    if (!user) {
      return errorResponse(res, 'User not found', 404);
    }

    // Update user
    const updatedUser = await prisma.user.update({
      where: { id },
      data: {
        ...(firstName && { firstName }),
        ...(lastName && { lastName }),
        ...(email && { email }),
        ...(typeof isActive === 'boolean' && { isActive }),
      },
      select: {
        id: true,
        email: true,
        firstName: true,
        lastName: true,
        role: true,
        isActive: true,
        updatedAt: true,
      },
    });

    // Update role-specific record
    const roleUpdateData = {};
    if (firstName) roleUpdateData.firstName = firstName;
    if (lastName) roleUpdateData.lastName = lastName;
    if (phone) roleUpdateData.phone = phone;
    if (address) roleUpdateData.address = address;

    if (Object.keys(roleUpdateData).length > 0) {
      if (user.tenant) {
        await prisma.tenant.update({
          where: { userId: id },
          data: roleUpdateData,
        });
      } else if (user.owner) {
        await prisma.owner.update({
          where: { userId: id },
          data: roleUpdateData,
        });
      } else if (user.manager) {
        await prisma.manager.update({
          where: { userId: id },
          data: roleUpdateData,
        });
      }
    }

    logger.info(`User updated by admin: ${updatedUser.email}`);

    return successResponse(res, 'User updated successfully', updatedUser);
  } catch (error) {
    logger.error('Error updating user:', error);
    return errorResponse(res, 'Failed to update user');
  }
};

export const deleteUser = async (req, res) => {
  try {
    const { id } = req.params;

    const user = await prisma.user.findUnique({
      where: { id },
      include: {
        tenant: true,
        owner: true,
        manager: true,
      },
    });

    if (!user) {
      return errorResponse(res, 'User not found', 404);
    }

    // Check if user can be deleted (no active relationships)
    if (user.role === 'OWNER') {
      const activeProperties = await prisma.property.count({
        where: { ownerId: user.owner?.id },
      });
      if (activeProperties > 0) {
        return errorResponse(res, 'Cannot delete owner with active properties', 400);
      }
    }

    if (user.role === 'TENANT') {
      const activeLeases = await prisma.lease.count({
        where: {
          tenantId: user.tenant?.id,
          status: 'ACTIVE',
        },
      });
      if (activeLeases > 0) {
        return errorResponse(res, 'Cannot delete tenant with active leases', 400);
      }
    }

    // Delete role-specific record first
    if (user.tenant) {
      await prisma.tenant.delete({ where: { userId: id } });
    } else if (user.owner) {
      await prisma.owner.delete({ where: { userId: id } });
    } else if (user.manager) {
      await prisma.manager.delete({ where: { userId: id } });
    }

    // Delete user
    await prisma.user.delete({ where: { id } });

    logger.info(`User deleted by admin: ${user.email}`);

    return successResponse(res, 'User deleted successfully');
  } catch (error) {
    logger.error('Error deleting user:', error);
    return errorResponse(res, 'Failed to delete user');
  }
};

export const getSystemSettings = async (req, res) => {
  try {
    const settings = await prisma.systemSetting.findMany({
      orderBy: { key: 'asc' },
    });

    const settingsMap = settings.reduce((acc, setting) => {
      acc[setting.key] = {
        value: setting.value,
        type: setting.type,
        description: setting.description,
      };
      return acc;
    }, {});

    return successResponse(res, 'System settings retrieved successfully', settingsMap);
  } catch (error) {
    logger.error('Error getting system settings:', error);
    return errorResponse(res, 'Failed to retrieve system settings');
  }
};

export const updateSystemSetting = async (req, res) => {
  try {
    const { key } = req.params;
    const { value } = req.body;

    const setting = await prisma.systemSetting.upsert({
      where: { key },
      update: { value },
      create: {
        key,
        value,
        type: 'STRING',
        description: '',
      },
    });

    logger.info(`System setting updated: ${key} by ${req.user.email}`);

    return successResponse(res, 'System setting updated successfully', setting);
  } catch (error) {
    logger.error('Error updating system setting:', error);
    return errorResponse(res, 'Failed to update system setting');
  }
};

export const getAuditLogs = async (req, res) => {
  try {
    const { page = 1, limit = 10, action, userId, startDate, endDate } = req.query;
    const skip = (parseInt(page) - 1) * parseInt(limit);

    const where = {};
    if (action) where.action = action;
    if (userId) where.userId = userId;
    if (startDate) where.createdAt = { ...where.createdAt, gte: new Date(startDate) };
    if (endDate) where.createdAt = { ...where.createdAt, lte: new Date(endDate) };

    const [logs, total] = await Promise.all([
      prisma.auditLog.findMany({
        where,
        skip,
        take: parseInt(limit),
        include: {
          user: {
            select: {
              id: true,
              email: true,
              firstName: true,
              lastName: true,
              role: true,
            },
          },
        },
        orderBy: { createdAt: 'desc' },
      }),
      prisma.auditLog.count({ where }),
    ]);

    return successResponse(res, 'Audit logs retrieved successfully', {
      logs,
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total,
        pages: Math.ceil(total / parseInt(limit)),
      },
    });
  } catch (error) {
    logger.error('Error getting audit logs:', error);
    return errorResponse(res, 'Failed to retrieve audit logs');
  }
};

================
File: src/modules/admin/routes/adminRoutes.js
================
import { Router } from 'express';
import { authenticate, authorize } from '../../../middleware/auth.js';
import { validateUser, validateUserUpdate, validateSystemSetting } from '../../../middleware/validation.js';
import {
  getDashboardStats,
  getAllUsers,
  createUser,
  updateUser,
  deleteUser,
  getSystemSettings,
  updateSystemSetting,
  getAuditLogs,
} from '../controllers/adminController.js';

const router = Router();

/**
 * @swagger
 * /admin/dashboard:
 *   get:
 *     tags: [Admin]
 *     summary: Get dashboard statistics
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: Dashboard statistics
 */
router.get('/dashboard', authenticate, authorize(['SUPER_ADMIN']), getDashboardStats);

/**
 * @swagger
 * /admin/users:
 *   get:
 *     tags: [Admin]
 *     summary: Get all users
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: query
 *         name: page
 *         schema:
 *           type: integer
 *           default: 1
 *       - in: query
 *         name: limit
 *         schema:
 *           type: integer
 *           default: 10
 *       - in: query
 *         name: role
 *         schema:
 *           type: string
 *           enum: [SUPER_ADMIN, OWNER, MANAGER, TENANT]
 *       - in: query
 *         name: status
 *         schema:
 *           type: string
 *           enum: [active, inactive]
 *       - in: query
 *         name: search
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: List of users
 */
router.get('/users', authenticate, authorize(['SUPER_ADMIN']), getAllUsers);

/**
 * @swagger
 * /admin/users:
 *   post:
 *     tags: [Admin]
 *     summary: Create a new user
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - email
 *               - password
 *               - firstName
 *               - lastName
 *               - role
 *             properties:
 *               email:
 *                 type: string
 *               password:
 *                 type: string
 *               firstName:
 *                 type: string
 *               lastName:
 *                 type: string
 *               role:
 *                 type: string
 *                 enum: [OWNER, MANAGER, TENANT]
 *               phone:
 *                 type: string
 *               address:
 *                 type: string
 *     responses:
 *       201:
 *         description: User created successfully
 */
router.post('/users', authenticate, authorize(['SUPER_ADMIN']), validateUser, createUser);

/**
 * @swagger
 * /admin/users/{id}:
 *   put:
 *     tags: [Admin]
 *     summary: Update user
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               firstName:
 *                 type: string
 *               lastName:
 *                 type: string
 *               email:
 *                 type: string
 *               isActive:
 *                 type: boolean
 *               phone:
 *                 type: string
 *               address:
 *                 type: string
 *     responses:
 *       200:
 *         description: User updated successfully
 */
router.put('/users/:id', authenticate, authorize(['SUPER_ADMIN']), validateUserUpdate, updateUser);

/**
 * @swagger
 * /admin/users/{id}:
 *   delete:
 *     tags: [Admin]
 *     summary: Delete user
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: User deleted successfully
 */
router.delete('/users/:id', authenticate, authorize(['SUPER_ADMIN']), deleteUser);

/**
 * @swagger
 * /admin/settings:
 *   get:
 *     tags: [Admin]
 *     summary: Get system settings
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: System settings
 */
router.get('/settings', authenticate, authorize(['SUPER_ADMIN']), getSystemSettings);

/**
 * @swagger
 * /admin/settings/{key}:
 *   put:
 *     tags: [Admin]
 *     summary: Update system setting
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: key
 *         required: true
 *         schema:
 *           type: string
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - value
 *             properties:
 *               value:
 *                 type: string
 *     responses:
 *       200:
 *         description: Setting updated successfully
 */
router.put('/settings/:key', authenticate, authorize(['SUPER_ADMIN']), validateSystemSetting, updateSystemSetting);

/**
 * @swagger
 * /admin/audit-logs:
 *   get:
 *     tags: [Admin]
 *     summary: Get audit logs
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: query
 *         name: page
 *         schema:
 *           type: integer
 *           default: 1
 *       - in: query
 *         name: limit
 *         schema:
 *           type: integer
 *           default: 10
 *       - in: query
 *         name: action
 *         schema:
 *           type: string
 *       - in: query
 *         name: userId
 *         schema:
 *           type: string
 *       - in: query
 *         name: startDate
 *         schema:
 *           type: string
 *           format: date
 *       - in: query
 *         name: endDate
 *         schema:
 *           type: string
 *           format: date
 *     responses:
 *       200:
 *         description: Audit logs
 */
router.get('/audit-logs', authenticate, authorize(['SUPER_ADMIN']), getAuditLogs);

export default router;

================
File: src/modules/analytics/controllers/analyticsController.js
================
import prisma from '../../../config/database.js';
import logger from '../../../config/logger.js';
import { asyncHandler } from '../../../middleware/errorHandler.js';
import { successResponse, errorResponse } from '../../../utils/responseHelpers.js';
import { generatePdfReport, generateCsvReport } from '../../../utils/pdfGenerator.js';

const buildScopeWhereClause = (user) => {
  const where = {};
  if (user.role === 'OWNER') {
    where.property = { ownerId: user.owner.id };
  } else if (user.role === 'MANAGER') {
    where.property = { ownerId: user.manager.ownerId };
  }
  return where;
};

export const getDashboardStats = asyncHandler(async (req, res) => {
  const scopeWhere = buildScopeWhereClause(req.user);

  const [
    totalProperties,
    activeTenants,
    activeLeases,
    openMaintenance,
    pendingPayments,
    totalRevenueLast30Days,
  ] = await prisma.$transaction([
    prisma.property.count({ where: scopeWhere.property }),
    prisma.tenant.count({ where: { property: scopeWhere.property, isActive: true } }),
    prisma.lease.count({ where: { ...scopeWhere, status: 'ACTIVE' } }),
    prisma.maintenanceRequest.count({ where: { ...scopeWhere, status: 'OPEN' } }),
    prisma.payment.aggregate({
      where: { lease: scopeWhere, status: 'PENDING' },
      _sum: { amount: true },
    }),
    prisma.payment.aggregate({
      where: {
        lease: scopeWhere,
        status: 'PAID',
        paidDate: { gte: new Date(new Date().setDate(new Date().getDate() - 30)) },
      },
      _sum: { amount: true },
    }),
  ]);

  const stats = {
    totalProperties,
    activeTenants,
    activeLeases,
    openMaintenance,
    pendingPayments: pendingPayments._sum.amount || 0,
    totalRevenueLast30Days: totalRevenueLast30Days._sum.amount || 0,
  };

  return successResponse(res, stats, 'Dashboard statistics retrieved successfully.');
});

export const getRevenueAnalytics = asyncHandler(async (req, res) => {
    const scopeWhere = buildScopeWhereClause(req.user);

    const revenue = await prisma.payment.aggregate({
        where: {
            lease: scopeWhere,
            status: 'PAID'
        },
        _sum: {
            amount: true,
        },
    });

    return successResponse(res, { totalRevenue: revenue._sum.amount || 0 }, 'Revenue analytics retrieved.');
});

export const getOccupancyAnalytics = asyncHandler(async (req, res) => {
    const scopeWhere = buildScopeWhereClause(req.user);

    const properties = await prisma.property.findMany({
        where: scopeWhere.property,
        include: {
            _count: {
                select: { leases: { where: { status: 'ACTIVE' } } }
            }
        }
    });

    const totalUnits = properties.reduce((sum, p) => sum + p.units, 0);
    const occupiedUnits = properties.reduce((sum, p) => sum + p._count.leases, 0);
    const occupancyRate = totalUnits > 0 ? (occupiedUnits / totalUnits) * 100 : 0;

    const data = {
        totalUnits,
        occupiedUnits,
        vacantUnits: totalUnits - occupiedUnits,
        occupancyRate: parseFloat(occupancyRate.toFixed(2)),
    };

    return successResponse(res, data, 'Occupancy analytics retrieved.');
});

export const getTenantAnalytics = asyncHandler(async (req, res) => {
    const scopeWhere = { property: buildScopeWhereClause(req.user).property };

    const totalTenants = await prisma.tenant.count({ where: scopeWhere });
    const activeTenants = await prisma.tenant.count({ where: { ...scopeWhere, isActive: true } });

    return successResponse(res, { totalTenants, activeTenants, inactiveTenants: totalTenants - activeTenants }, 'Tenant analytics retrieved.');
});

export const getPropertyAnalytics = asyncHandler(async (req, res) => {
    const scopeWhere = buildScopeWhereClause(req.user).property;
    const properties = await prisma.property.findMany({
        where: scopeWhere,
        select: {
            status: true,
            type: true,
        }
    });

    const statusCounts = properties.reduce((acc, property) => {
        acc[property.status] = (acc[property.status] || 0) + 1;
        return acc;
    }, {});

    const typeCounts = properties.reduce((acc, property) => {
        acc[property.type] = (acc[property.type] || 0) + 1;
        return acc;
    }, {});


    return successResponse(res, { totalProperties: properties.length, byStatus: statusCounts, byType: typeCounts }, 'Property analytics retrieved.');
});

export const getComplaintAnalytics = asyncHandler(async (req, res) => {
    const scopeWhere = buildScopeWhereClause(req.user);
    const complaints = await prisma.complaint.findMany({
        where: { property: scopeWhere.property },
        select: { status: true, priority: true }
    });

    const statusCounts = complaints.reduce((acc, complaint) => {
        acc[complaint.status] = (acc[complaint.status] || 0) + 1;
        return acc;
    }, {});

    const priorityCounts = complaints.reduce((acc, complaint) => {
        acc[complaint.priority] = (acc[complaint.priority] || 0) + 1;
        return acc;
    }, {});

    return successResponse(res, { totalComplaints: complaints.length, byStatus: statusCounts, byPriority: priorityCounts }, 'Complaint analytics retrieved.');
});

export const getPaymentAnalytics = asyncHandler(async (req, res) => {
    const scopeWhere = buildScopeWhereClause(req.user);
    const payments = await prisma.payment.findMany({
        where: { lease: scopeWhere },
        select: { status: true, amount: true, method: true }
    });

    const totalAmount = payments.reduce((sum, p) => sum + Number(p.amount), 0);
    const statusCounts = {};
    const methodCounts = {};
    
    for (const payment of payments) {
        statusCounts[payment.status] = (statusCounts[payment.status] || 0) + 1;
        if(payment.method) {
            methodCounts[payment.method] = (methodCounts[payment.method] || 0) + 1;
        }
    }

    return successResponse(res, { totalPayments: payments.length, totalAmount, byStatus: statusCounts, byMethod: methodCounts }, 'Payment analytics retrieved.');
});

export const exportAnalyticsReport = asyncHandler(async (req, res) => {
    const { type, format = 'pdf' } = req.query;
    const scopeWhere = buildScopeWhereClause(req.user);
    let data;
    let reportTitle = '';
    let headers = [];

    switch(type) {
        case 'revenue':
            data = await prisma.payment.findMany({ where: { lease: scopeWhere, status: 'PAID' }, select: { id: true, amount: true, paidDate: true, lease: { select: { property: { select: { name: true } } } } } });
            reportTitle = 'Revenue Report';
            headers = [
                { id: 'id', title: 'Payment ID' },
                { id: 'property', title: 'Property', path: 'lease.property.name' },
                { id: 'paidDate', title: 'Paid Date' },
                { id: 'amount', title: 'Amount' },
            ];
            break;
        case 'occupancy':
             const properties = await prisma.property.findMany({
                where: scopeWhere.property,
                include: { _count: { select: { leases: { where: { status: 'ACTIVE' } } } } }
            });
            data = properties.map(p => ({
                name: p.name,
                address: p.address,
                units: p.units,
                occupied: p.units > 0 ? (p._count.leases > 0 ? 'Yes' : 'No') : 'N/A'
            }));
            reportTitle = 'Occupancy Report';
            headers = [
                { id: 'name', title: 'Property Name' },
                { id: 'address', title: 'Address' },
                { id: 'units', title: 'Units' },
                { id: 'occupied', title: 'Occupied' },
            ];
            break;
        default:
            return errorResponse(res, 'Invalid report type', 400);
    }
    
    if (format === 'pdf') {
        const pdfBuffer = await generatePdfReport(data, reportTitle, headers);
        res.setHeader('Content-Type', 'application/pdf');
        res.setHeader('Content-Disposition', `attachment; filename=${type}-report.pdf`);
        return res.send(pdfBuffer);
    }

    if(format === 'csv') {
        const csv = await generateCsvReport(data, headers);
        res.setHeader('Content-Type', 'text/csv');
        res.setHeader('Content-Disposition', `attachment; filename=${type}-report.csv`);
        return res.send(csv);
    }

    return errorResponse(res, 'Invalid format specified', 400);
});

================
File: src/modules/analytics/routes/analyticsRoutes.js
================
import express from 'express';
import { authenticate, authorize } from '../../../middleware/auth.js';
import {
  getDashboardStats,
  getRevenueAnalytics,
  getOccupancyAnalytics,
  getTenantAnalytics,
  getPropertyAnalytics,
  getComplaintAnalytics,
  getPaymentAnalytics,
  exportAnalyticsReport,
} from '../controllers/analyticsController.js';

const router = express.Router();

/**
 * @swagger
 * /analytics/dashboard:
 *   get:
 *     summary: Get dashboard statistics
 *     tags: [Analytics]
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: Dashboard statistics
 */
router.get('/dashboard', authenticate, getDashboardStats);

/**
 * @swagger
 * /analytics/revenue:
 *   get:
 *     summary: Get revenue analytics
 *     tags: [Analytics]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: query
 *         name: period
 *         schema:
 *           type: string
 *           enum: [week, month, quarter, year]
 *           default: month
 *     responses:
 *       200:
 *         description: Revenue analytics data
 */
router.get('/revenue', authenticate, authorize(['SUPER_ADMIN', 'OWNER', 'MANAGER']), getRevenueAnalytics);

/**
 * @swagger
 * /analytics/occupancy:
 *   get:
 *     summary: Get occupancy analytics
 *     tags: [Analytics]
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: Occupancy analytics data
 */
router.get('/occupancy', authenticate, authorize(['SUPER_ADMIN', 'OWNER', 'MANAGER']), getOccupancyAnalytics);

/**
 * @swagger
 * /analytics/tenants:
 *   get:
 *     summary: Get tenant analytics
 *     tags: [Analytics]
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: Tenant analytics data
 */
router.get('/tenants', authenticate, authorize(['SUPER_ADMIN', 'OWNER', 'MANAGER']), getTenantAnalytics);

/**
 * @swagger
 * /analytics/properties:
 *   get:
 *     summary: Get property analytics
 *     tags: [Analytics]
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: Property analytics data
 */
router.get('/properties', authenticate, authorize(['SUPER_ADMIN', 'OWNER', 'MANAGER']), getPropertyAnalytics);

/**
 * @swagger
 * /analytics/complaints:
 *   get:
 *     summary: Get complaint analytics
 *     tags: [Analytics]
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: Complaint analytics data
 */
router.get('/complaints', authenticate, authorize(['SUPER_ADMIN', 'OWNER', 'MANAGER']), getComplaintAnalytics);

/**
 * @swagger
 * /analytics/payments:
 *   get:
 *     summary: Get payment analytics
 *     tags: [Analytics]
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: Payment analytics data
 */
router.get('/payments', authenticate, authorize(['SUPER_ADMIN', 'OWNER', 'MANAGER']), getPaymentAnalytics);

/**
 * @swagger
 * /analytics/export:
 *   get:
 *     summary: Export analytics report
 *     tags: [Analytics]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: query
 *         name: type
 *         schema:
 *           type: string
 *           enum: [revenue, occupancy, tenants, properties]
 *         required: true
 *       - in: query
 *         name: format
 *         schema:
 *           type: string
 *           enum: [pdf, csv]
 *           default: pdf
 *     responses:
 *       200:
 *         description: Analytics report file
 */
router.get('/export', authenticate, authorize(['SUPER_ADMIN', 'OWNER', 'MANAGER']), exportAnalyticsReport);

export default router;

================
File: src/modules/auth/controllers/authController.js
================
import bcrypt from 'bcryptjs';
import { hashPassword, comparePassword, generateToken, generateRandomPassword } from '../../../utils/helpers.js';
import prisma from '../../../config/database.js';
import logger from '../../../config/logger.js';
import { asyncHandler } from '../../../middleware/errorHandler.js';
import { sendWelcomeEmail } from '../../notifications/services/emailService.js';

/**
 * @swagger
 * components:
 *   schemas:
 *     User:
 *       type: object
 *       properties:
 *         id:
 *           type: string
 *         email:
 *           type: string
 *         role:
 *           type: string
 *           enum: [SUPER_ADMIN, OWNER, MANAGER, TENANT]
 *         isActive:
 *           type: boolean
 *         createdAt:
 *           type: string
 *           format: date-time
 */

/**
 * @swagger
 * /auth/register:
 *   post:
 *     tags: [Authentication]
 *     summary: Register a new user
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - email
 *               - password
 *               - role
 *             properties:
 *               email:
 *                 type: string
 *                 format: email
 *               password:
 *                 type: string
 *                 minLength: 6
 *               role:
 *                 type: string
 *                 enum: [SUPER_ADMIN, OWNER, MANAGER, TENANT]
 *               companyName:
 *                 type: string
 *               phone:
 *                 type: string
 *     responses:
 *       201:
 *         description: User registered successfully
 *       400:
 *         description: Invalid input data
 *       409:
 *         description: User already exists
 */
export const register = asyncHandler(async (req, res) => {
  const { email, password, role, companyName, firstName, lastName, phone } = req.body;

  // Check if user already exists
  const existingUser = await prisma.user.findUnique({
    where: { email: email.toLowerCase() },
  });

  if (existingUser) {
    return res.status(409).json({
      error: 'User already exists',
      message: 'A user with this email already exists',
    });
  }

  // Hash password
  const hashedPassword = await hashPassword(password);

  // Create user
  const user = await prisma.user.create({
    data: {
      email: email.toLowerCase(),
      password: hashedPassword,
      role,
      firstName,
      lastName,
    },
  });

  // Create role-specific profile
  if (role === 'OWNER') {
    await prisma.owner.create({
      data: {
        userId: user.id,
        companyName,
        phone,
      },
    });
  }

  // Log registration attempt
  await prisma.loginAttempt.create({
    data: {
      userId: user.id,
      email: user.email,
      ipAddress: req.ip,
      success: true,
      userAgent: req.get('User-Agent'),
    },
  });

  logger.info(`User registered: ${user.email} with role: ${role}`);

  // Send welcome email
  try {
    await sendWelcomeEmail(user.email, user.role);
  } catch (error) {
    logger.error('Failed to send welcome email:', error);
  }

  // Generate token
  const token = generateToken({ userId: user.id, role: user.role });

  res.status(201).json({
    message: 'User registered successfully',
    token,
    user: {
      id: user.id,
      email: user.email,
      firstName: user.firstName,
      lastName: user.lastName,
      role: user.role,
      isActive: user.isActive,
      createdAt: user.createdAt,
    },
  });
});

/**
 * @swagger
 * /auth/login:
 *   post:
 *     tags: [Authentication]
 *     summary: Login user
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - email
 *               - password
 *             properties:
 *               email:
 *                 type: string
 *                 format: email
 *               password:
 *                 type: string
 *     responses:
 *       200:
 *         description: Login successful
 *       401:
 *         description: Invalid credentials
 */
export const login = asyncHandler(async (req, res) => {
  const { email, password } = req.body;

  // Find user
  const user = await prisma.user.findUnique({
    where: { email: email.toLowerCase() },
    include: {
      tenant: true,
      owner: true,
      manager: {
        include: {
          owner: true,
        },
      },
    },
  });

  if (!user || !user.isActive) {
    // Log failed attempt
    await prisma.loginAttempt.create({
      data: {
        email: email.toLowerCase(),
        ipAddress: req.ip,
        success: false,
        userAgent: req.get('User-Agent'),
      },
    });

    return res.status(401).json({
      error: 'Invalid credentials',
      message: 'Invalid email or password',
    });
  }

  // Verify password
  const isValidPassword = await comparePassword(password, user.password);

  if (!isValidPassword) {
    // Log failed attempt
    await prisma.loginAttempt.create({
      data: {
        userId: user.id,
        email: user.email,
        ipAddress: req.ip,
        success: false,
        userAgent: req.get('User-Agent'),
      },
    });

    return res.status(401).json({
      error: 'Invalid credentials',
      message: 'Invalid email or password',
    });
  }

  // Update last login
  await prisma.user.update({
    where: { id: user.id },
    data: { lastLogin: new Date() },
  });

  // Log successful attempt
  await prisma.loginAttempt.create({
    data: {
      userId: user.id,
      email: user.email,
      ipAddress: req.ip,
      success: true,
      userAgent: req.get('User-Agent'),
    },
  });

  logger.info(`User logged in: ${user.email}`);

  // Generate token
  const token = generateToken({ userId: user.id, role: user.role });

  res.json({
    message: 'Login successful',
    token,
    user: {
      id: user.id,
      email: user.email,
      role: user.role,
      isActive: user.isActive,
      lastLogin: user.lastLogin,
      profile: user.tenant || user.owner || user.manager,
    },
  });
});

/**
 * @swagger
 * /auth/me:
 *   get:
 *     tags: [Authentication]
 *     summary: Get current user profile
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: User profile retrieved successfully
 *       401:
 *         description: Unauthorized
 */
export const getMe = asyncHandler(async (req, res) => {
  const user = await prisma.user.findUnique({
    where: { id: req.user.id },
    include: {
      tenant: {
        include: {
          property: true,
        },
      },
      owner: true,
      manager: {
        include: {
          owner: true,
        },
      },
    },
  });

  res.json({
    user: {
      id: user.id,
      email: user.email,
      role: user.role,
      isActive: user.isActive,
      lastLogin: user.lastLogin,
      createdAt: user.createdAt,
      profile: user.tenant || user.owner || user.manager,
    },
  });
});

/**
 * @swagger
 * /auth/change-password:
 *   put:
 *     tags: [Authentication]
 *     summary: Change user password
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - currentPassword
 *               - newPassword
 *             properties:
 *               currentPassword:
 *                 type: string
 *               newPassword:
 *                 type: string
 *                 minLength: 6
 *     responses:
 *       200:
 *         description: Password changed successfully
 *       401:
 *         description: Invalid current password
 */
export const changePassword = asyncHandler(async (req, res) => {
  const { currentPassword, newPassword } = req.body;

  // Get current user
  const user = await prisma.user.findUnique({
    where: { id: req.user.id },
  });

  // Verify current password
  const isValidPassword = await comparePassword(currentPassword, user.password);

  if (!isValidPassword) {
    return res.status(401).json({
      error: 'Invalid password',
      message: 'Current password is incorrect',
    });
  }

  // Hash new password
  const hashedPassword = await hashPassword(newPassword);

  // Update password
  await prisma.user.update({
    where: { id: user.id },
    data: { password: hashedPassword },
  });

  logger.info(`Password changed for user: ${user.email}`);

  res.json({
    message: 'Password changed successfully',
  });
});

/**
 * Create tenant user account (internal service method)
 */
export const createTenantUser = async (email, tenantData) => {
  try {
    // Generate random password
    const password = generateRandomPassword();
    const hashedPassword = await hashPassword(password);

    // Create user
    const user = await prisma.user.create({
      data: {
        email: email.toLowerCase(),
        password: hashedPassword,
        role: 'TENANT',
      },
    });

    logger.info(`Tenant user created: ${user.email}`);

    // Send welcome email with password
    try {
      await sendWelcomeEmail(user.email, 'TENANT', password);
    } catch (error) {
      logger.error('Failed to send tenant welcome email:', error);
    }

    return user;
  } catch (error) {
    logger.error('Error creating tenant user:', error);
    throw error;
  }
};

/**
 * @swagger
 * /auth/roles/{userId}:
 *   get:
 *     tags: [Authentication]
 *     summary: Get user roles and permissions
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: userId
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: User roles and permissions retrieved
 *       403:
 *         description: Forbidden
 *       404:
 *         description: User not found
 */
export const getUserRoles = asyncHandler(async (req, res) => {
  const { userId } = req.params;

  // Check if user can access this information
  if (req.user.id !== userId && !['SUPER_ADMIN', 'OWNER'].includes(req.user.role)) {
    return res.status(403).json({
      error: 'Forbidden',
      message: 'You can only access your own role information',
    });
  }

  const user = await prisma.user.findUnique({
    where: { id: userId },
    include: {
      manager: {
        include: {
          owner: true,
        },
      },
    },
  });

  if (!user) {
    return res.status(404).json({
      error: 'User not found',
      message: 'User with this ID does not exist',
    });
  }

  const roleData = {
    role: user.role,
    permissions: {},
  };

  if (user.role === 'MANAGER' && user.manager) {
    roleData.permissions = user.manager.permissions || {};
    roleData.ownerId = user.manager.ownerId;
  }

  res.json({
    userId: user.id,
    email: user.email,
    ...roleData,
  });
});

================
File: src/modules/auth/routes/authRoutes.js
================
import express from 'express';
import { body } from 'express-validator';
import { 
  register, 
  login, 
  getMe, 
  changePassword, 
  getUserRoles 
} from '../controllers/authController.js';
import { authenticate, authorize } from '../../../middleware/auth.js';
import { handleValidationErrors } from '../../../middleware/validation.js';
import { authLimiter, bruteForce } from '../../../middleware/rateLimiter.js';

const router = express.Router();

// Validation rules
const registerValidation = [
  body('email')
    .isEmail()
    .normalizeEmail()
    .withMessage('Please provide a valid email'),
  body('password')
    .isLength({ min: 6 })
    .withMessage('Password must be at least 6 characters long')
    .matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/)
    .withMessage('Password must contain at least one uppercase letter, one lowercase letter, and one number'),
  body('role')
    .isIn(['SUPER_ADMIN', 'OWNER', 'MANAGER', 'TENANT'])
    .withMessage('Invalid role'),
  body('companyName')
    .optional()
    .isLength({ min: 2, max: 100 })
    .withMessage('Company name must be between 2 and 100 characters'),
  body('phone')
    .optional()
    .isMobilePhone()
    .withMessage('Please provide a valid phone number'),
];

const loginValidation = [
  body('email')
    .isEmail()
    .normalizeEmail()
    .withMessage('Please provide a valid email'),
  body('password')
    .notEmpty()
    .withMessage('Password is required'),
];

const changePasswordValidation = [
  body('currentPassword')
    .notEmpty()
    .withMessage('Current password is required'),
  body('newPassword')
    .isLength({ min: 6 })
    .withMessage('New password must be at least 6 characters long')
    .matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/)
    .withMessage('New password must contain at least one uppercase letter, one lowercase letter, and one number'),
];

// Public routes
router.post('/register', authLimiter, registerValidation, handleValidationErrors, register);
router.post('/login', authLimiter, bruteForce.prevent, loginValidation, handleValidationErrors, login);

// Protected routes
router.get('/me', authenticate, getMe);
router.put('/change-password', authenticate, changePasswordValidation, handleValidationErrors, changePassword);
router.get('/roles/:userId', authenticate, authorize('SUPER_ADMIN', 'OWNER', 'MANAGER', 'TENANT'), getUserRoles);

export default router;

================
File: src/modules/calendar/controllers/calendarController.js
================
import prisma from '../../../config/database.js';
import logger from '../../../config/logger.js';
import { successResponse, errorResponse } from '../../../utils/responseHelpers.js';

export const getCalendarEvents = async (req, res) => {
  try {
    const { startDate, endDate, type } = req.query;
    const userId = req.user.userId;

    const start = startDate ? new Date(startDate) : new Date();
    const end = endDate ? new Date(endDate) : new Date(Date.now() + 30 * 24 * 60 * 60 * 1000); // 30 days from now

    const events = [];

    // Get payments due
    if (!type || type === 'payment') {
      const where = {
        dueDate: {
          gte: start,
          lte: end,
        },
        status: 'PENDING',
      };

      if (req.user.role === 'TENANT') {
        where.tenantId = req.user.tenant.id;
      } else if (req.user.role === 'OWNER') {
        where.lease = {
          property: {
            ownerId: req.user.owner.id,
          },
        };
      } else if (req.user.role === 'MANAGER') {
        const managerProperties = await prisma.property.findMany({
          where: {
            managers: {
              some: { userId },
            },
          },
          select: { id: true },
        });

        where.lease = {
          propertyId: {
            in: managerProperties.map(p => p.id),
          },
        };
      }

      const payments = await prisma.payment.findMany({
        where,
        include: {
          tenant: {
            include: {
              user: true,
            },
          },
          lease: {
            include: {
              property: true,
            },
          },
        },
      });

      payments.forEach(payment => {
        events.push({
          id: `payment-${payment.id}`,
          title: `Payment Due: $${payment.amount}`,
          description: `Payment due for ${payment.lease.property.name}`,
          start: payment.dueDate,
          end: payment.dueDate,
          type: 'payment',
          status: payment.status,
          allDay: true,
          data: payment,
        });
      });
    }

    // Get lease start/end dates
    if (!type || type === 'lease') {
      const leaseWhere = {
        OR: [
          {
            startDate: {
              gte: start,
              lte: end,
            },
          },
          {
            endDate: {
              gte: start,
              lte: end,
            },
          },
        ],
      };

      if (req.user.role === 'TENANT') {
        leaseWhere.tenantId = req.user.tenant.id;
      } else if (req.user.role === 'OWNER') {
        leaseWhere.property = {
          ownerId: req.user.owner.id,
        };
      } else if (req.user.role === 'MANAGER') {
        const managerProperties = await prisma.property.findMany({
          where: {
            managers: {
              some: { userId },
            },
          },
          select: { id: true },
        });

        leaseWhere.propertyId = {
          in: managerProperties.map(p => p.id),
        };
      }

      const leases = await prisma.lease.findMany({
        where: leaseWhere,
        include: {
          tenant: {
            include: {
              user: true,
            },
          },
          property: true,
        },
      });

      leases.forEach(lease => {
        // Lease start
        if (lease.startDate >= start && lease.startDate <= end) {
          events.push({
            id: `lease-start-${lease.id}`,
            title: `Lease Starts: ${lease.property.name}`,
            description: `Lease begins for ${lease.tenant.user.firstName} ${lease.tenant.user.lastName}`,
            start: lease.startDate,
            end: lease.startDate,
            type: 'lease-start',
            allDay: true,
            data: lease,
          });
        }

        // Lease end
        if (lease.endDate >= start && lease.endDate <= end) {
          events.push({
            id: `lease-end-${lease.id}`,
            title: `Lease Ends: ${lease.property.name}`,
            description: `Lease expires for ${lease.tenant.user.firstName} ${lease.tenant.user.lastName}`,
            start: lease.endDate,
            end: lease.endDate,
            type: 'lease-end',
            allDay: true,
            data: lease,
          });
        }
      });
    }

    // Get maintenance requests
    if (!type || type === 'maintenance') {
      const maintenanceWhere = {
        createdAt: {
          gte: start,
          lte: end,
        },
        status: {
          in: ['OPEN', 'IN_PROGRESS'],
        },
      };

      if (req.user.role === 'TENANT') {
        maintenanceWhere.requestedById = userId;
      } else if (req.user.role === 'MANAGER') {
        maintenanceWhere.assignedToId = userId;
      } else if (req.user.role === 'OWNER') {
        maintenanceWhere.property = {
          ownerId: req.user.owner.id,
        };
      }

      const maintenanceRequests = await prisma.maintenanceRequest.findMany({
        where: maintenanceWhere,
        include: {
          property: true,
          requestedBy: true,
        },
      });

      maintenanceRequests.forEach(request => {
        events.push({
          id: `maintenance-${request.id}`,
          title: `Maintenance: ${request.title}`,
          description: request.description,
          start: request.createdAt,
          end: request.createdAt,
          type: 'maintenance',
          priority: request.priority,
          status: request.status,
          allDay: true,
          data: request,
        });
      });
    }

    // Sort events by date
    events.sort((a, b) => new Date(a.start) - new Date(b.start));

    return successResponse(res, 'Calendar events retrieved successfully', events);
  } catch (error) {
    logger.error('Error getting calendar events:', error);
    return errorResponse(res, 'Failed to retrieve calendar events');
  }
};

export const getUpcomingEvents = async (req, res) => {
  try {
    const { days = 7 } = req.query;
    const userId = req.user.userId;

    const start = new Date();
    const end = new Date(Date.now() + parseInt(days) * 24 * 60 * 60 * 1000);

    const events = [];

    // Get upcoming payments
    const paymentWhere = {
      dueDate: {
        gte: start,
        lte: end,
      },
      status: 'PENDING',
    };

    if (req.user.role === 'TENANT') {
      paymentWhere.tenantId = req.user.tenant.id;
    } else if (req.user.role === 'OWNER') {
      paymentWhere.lease = {
        property: {
          ownerId: req.user.owner.id,
        },
      };
    }

    const upcomingPayments = await prisma.payment.findMany({
      where: paymentWhere,
      include: {
        tenant: {
          include: {
            user: true,
          },
        },
        lease: {
          include: {
            property: true,
          },
        },
      },
      orderBy: { dueDate: 'asc' },
      take: 5,
    });

    upcomingPayments.forEach(payment => {
      events.push({
        id: `payment-${payment.id}`,
        title: `Payment Due: $${payment.amount}`,
        description: `Payment due for ${payment.lease.property.name}`,
        date: payment.dueDate,
        type: 'payment',
        priority: 'high',
        data: payment,
      });
    });

    // Get upcoming lease expirations
    const leaseWhere = {
      endDate: {
        gte: start,
        lte: end,
      },
      status: 'ACTIVE',
    };

    if (req.user.role === 'TENANT') {
      leaseWhere.tenantId = req.user.tenant.id;
    } else if (req.user.role === 'OWNER') {
      leaseWhere.property = {
        ownerId: req.user.owner.id,
      };
    }

    const expiringLeases = await prisma.lease.findMany({
      where: leaseWhere,
      include: {
        tenant: {
          include: {
            user: true,
          },
        },
        property: true,
      },
      orderBy: { endDate: 'asc' },
      take: 5,
    });

    expiringLeases.forEach(lease => {
      events.push({
        id: `lease-end-${lease.id}`,
        title: `Lease Expiring: ${lease.property.name}`,
        description: `Lease expires for ${lease.tenant.user.firstName} ${lease.tenant.user.lastName}`,
        date: lease.endDate,
        type: 'lease-expiration',
        priority: 'medium',
        data: lease,
      });
    });

    // Sort events by date
    events.sort((a, b) => new Date(a.date) - new Date(b.date));

    return successResponse(res, 'Upcoming events retrieved successfully', events);
  } catch (error) {
    logger.error('Error getting upcoming events:', error);
    return errorResponse(res, 'Failed to retrieve upcoming events');
  }
};

export const createCalendarEvent = async (req, res) => {
  try {
    const { title, description, startDate, endDate, type, relatedId } = req.body;
    const userId = req.user.userId;

    const event = await prisma.calendarEvent.create({
      data: {
        title,
        description,
        startDate: new Date(startDate),
        endDate: new Date(endDate),
        type,
        relatedId,
        createdById: userId,
      },
      include: {
        createdBy: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            email: true,
          },
        },
      },
    });

    logger.info(`Calendar event created: ${event.id} by ${req.user.email}`);

    return successResponse(res, 'Calendar event created successfully', event, 201);
  } catch (error) {
    logger.error('Error creating calendar event:', error);
    return errorResponse(res, 'Failed to create calendar event');
  }
};

================
File: src/modules/calendar/routes/calendarRoutes.js
================
import { Router } from 'express';
import { authenticate, authorize } from '../../../middleware/auth.js';
import {
  createCalendarEvent,
  getCalendarEvents,
  // updateCalendarEvent,
  // deleteCalendarEvent,
} from '../controllers/calendarController.js';

const router = Router();

/**
 * @swagger
 * /calendar/events:
 *   get:
 *     tags: [Calendar]
 *     summary: Get calendar events
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: query
 *         name: startDate
 *         schema:
 *           type: string
 *           format: date
 *       - in: query
 *         name: endDate
 *         schema:
 *           type: string
 *           format: date
 *       - in: query
 *         name: type
 *         schema:
 *           type: string
 *           enum: [payment, lease, maintenance]
 *     responses:
 *       200:
 *         description: Calendar events
 */
router.get('/events', authenticate, authorize(['TENANT', 'MANAGER', 'OWNER', 'SUPER_ADMIN']), getCalendarEvents);

/**
 * @swagger
 * /calendar/upcoming:
 *   get:
 *     tags: [Calendar]
 *     summary: Get upcoming events
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: query
 *         name: days
 *         schema:
 *           type: integer
 *           default: 7
 *     responses:
 *       200:
 *         description: Upcoming events
 */
router.get('/upcoming', authenticate, authorize(['TENANT', 'MANAGER', 'OWNER', 'SUPER_ADMIN']), getCalendarEvents);

/**
 * @swagger
 * /calendar/events:
 *   post:
 *     tags: [Calendar]
 *     summary: Create calendar event
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - title
 *               - startDate
 *               - endDate
 *             properties:
 *               title:
 *                 type: string
 *               description:
 *                 type: string
 *               startDate:
 *                 type: string
 *                 format: date-time
 *               endDate:
 *                 type: string
 *                 format: date-time
 *               type:
 *                 type: string
 *               relatedId:
 *                 type: string
 *     responses:
 *       201:
 *         description: Calendar event created successfully
 */
router.post('/events', authenticate, authorize(['MANAGER', 'OWNER', 'SUPER_ADMIN']), createCalendarEvent);

export default router;

================
File: src/modules/complaints/controllers/complaintController.js
================
import prisma from '../../../config/database.js';
import logger from '../../../config/logger.js';
import { sendNotificationToUser } from '../../notifications/services/socketService.js';

export const createComplaint = async (req, res) => {
  try {
    const { title, description, category, priority, propertyId } = req.body;
    const userId = req.user.userId;

    // Verify property exists and check permissions for non-tenant users
    if (propertyId) {
      const property = await prisma.property.findUnique({
        where: { id: propertyId },
      });

      if (!property) {
        return res.status(404).json({
          error: 'Property not found',
          message: 'Property with this ID does not exist',
        });
      }

      // For tenants, verify they are associated with the property
      if (req.user.role === 'TENANT') {
        const tenantProperty = await prisma.tenant.findFirst({
          where: {
            id: req.user.tenant.id,
            properties: {
              some: { id: propertyId },
            },
          },
        });

        if (!tenantProperty) {
          return res.status(403).json({
            error: 'Forbidden',
            message: 'You can only create complaints for properties you are associated with',
          });
        }
      }
    }

    const complaint = await prisma.complaint.create({
      data: {
        title,
        description,
        category: category || 'GENERAL',
        priority: priority || 'MEDIUM',
        status: 'OPEN',
        reporterId: userId,
        ...(propertyId && { propertyId }),
      },
      include: {
        reporter: {
          select: {
            id: true,
            email: true,
            role: true,
          },
        },
        property: {
          select: {
            id: true,
            name: true,
            address: true,
            owner: {
              select: {
                id: true,
                user: {
                  select: {
                    id: true,
                    email: true,
                  },
                },
              },
            },
          },
        },
      },
    });

    // Send notification to property owner if complaint is for a specific property
    if (propertyId && complaint.property) {
      await sendNotificationToUser(complaint.property.owner.user.id, {
        title: 'New Complaint Received',
        body: `A new complaint has been submitted for ${complaint.property.name}: ${title}`,
        type: 'complaint',
        data: { complaintId: complaint.id },
      });
    }

    logger.info(`Complaint created: ${title} by ${req.user.email}`);

    res.status(201).json({
      message: 'Complaint created successfully',
      complaint,
    });
  } catch (error) {
    logger.error('Error creating complaint:', error);
    res.status(500).json({
      error: 'Internal server error',
      message: 'Failed to create complaint',
    });
  }
};

export const getComplaints = async (req, res) => {
  try {
    const { page = 1, limit = 10, status, category, priority, propertyId } = req.query;
    const skip = (parseInt(page) - 1) * parseInt(limit);

    let where = {};

    // Apply role-based filtering
    if (req.user.role === 'OWNER') {
      where.OR = [
        { reporterId: req.user.userId },
        { property: { ownerId: req.user.owner.id } },
      ];
    } else if (req.user.role === 'MANAGER') {
      where.OR = [
        { reporterId: req.user.userId },
        { assignedToId: req.user.userId },
        { property: { ownerId: req.user.manager.ownerId } },
      ];
    } else if (req.user.role === 'TENANT') {
      where.reporterId = req.user.userId;
    }

    // Apply filters
    if (status) where.status = status;
    if (category) where.category = category;
    if (priority) where.priority = priority;
    if (propertyId) where.propertyId = propertyId;

    const [complaints, total] = await Promise.all([
      prisma.complaint.findMany({
        where,
        skip,
        take: parseInt(limit),
        include: {
          reporter: {
            select: {
              id: true,
              email: true,
              role: true,
            },
          },
          assignedTo: {
            select: {
              id: true,
              email: true,
              role: true,
            },
          },
          property: {
            select: {
              id: true,
              name: true,
              address: true,
            },
          },
        },
        orderBy: { createdAt: 'desc' },
      }),
      prisma.complaint.count({ where }),
    ]);

    res.json({
      complaints,
      pagination: {
        total,
        page: parseInt(page),
        limit: parseInt(limit),
        pages: Math.ceil(total / parseInt(limit)),
      },
    });
  } catch (error) {
    logger.error('Error fetching complaints:', error);
    res.status(500).json({
      error: 'Internal server error',
      message: 'Failed to fetch complaints',
    });
  }
};

export const getComplaintById = async (req, res) => {
  try {
    const { id } = req.params;

    const complaint = await prisma.complaint.findUnique({
      where: { id },
      include: {
        reporter: {
          select: {
            id: true,
            email: true,
            role: true,
          },
        },
        assignedTo: {
          select: {
            id: true,
            email: true,
            role: true,
          },
        },
        property: {
          select: {
            id: true,
            name: true,
            address: true,
            owner: {
              select: {
                id: true,
                user: {
                  select: {
                    id: true,
                    email: true,
                  },
                },
              },
            },
          },
        },
      },
    });

    if (!complaint) {
      return res.status(404).json({
        error: 'Complaint not found',
        message: 'Complaint with this ID does not exist',
      });
    }

    // Check permissions
    const canAccess = 
      req.user.role === 'SUPER_ADMIN' ||
      complaint.reporterId === req.user.userId ||
      complaint.assignedToId === req.user.userId ||
      (req.user.role === 'OWNER' && complaint.property?.owner.user.id === req.user.userId) ||
      (req.user.role === 'MANAGER' && complaint.property?.owner.id === req.user.manager.ownerId);

    if (!canAccess) {
      return res.status(403).json({
        error: 'Forbidden',
        message: 'You do not have permission to access this complaint',
      });
    }

    res.json(complaint);
  } catch (error) {
    logger.error('Error fetching complaint:', error);
    res.status(500).json({
      error: 'Internal server error',
      message: 'Failed to fetch complaint',
    });
  }
};

export const updateComplaint = async (req, res) => {
  try {
    const { id } = req.params;
    const { title, description, category, priority, status } = req.body;

    const existingComplaint = await prisma.complaint.findUnique({
      where: { id },
      include: {
        property: {
          include: {
            owner: true,
          },
        },
      },
    });

    if (!existingComplaint) {
      return res.status(404).json({
        error: 'Complaint not found',
        message: 'Complaint with this ID does not exist',
      });
    }

    // Check permissions
    const canUpdate = 
      req.user.role === 'SUPER_ADMIN' ||
      existingComplaint.reporterId === req.user.userId ||
      existingComplaint.assignedToId === req.user.userId ||
      (req.user.role === 'OWNER' && existingComplaint.property?.ownerId === req.user.owner.id) ||
      (req.user.role === 'MANAGER' && existingComplaint.property?.ownerId === req.user.manager.ownerId);

    if (!canUpdate) {
      return res.status(403).json({
        error: 'Forbidden',
        message: 'You do not have permission to update this complaint',
      });
    }

    // Only allow reporter to update title and description, others can update status and priority
    const updateData = {};
    if (existingComplaint.reporterId === req.user.userId) {
      if (title) updateData.title = title;
      if (description) updateData.description = description;
    }

    if (category && req.user.role !== 'TENANT') updateData.category = category;
    if (priority && req.user.role !== 'TENANT') updateData.priority = priority;
    if (status && req.user.role !== 'TENANT') updateData.status = status;

    const updatedComplaint = await prisma.complaint.update({
      where: { id },
      data: updateData,
      include: {
        reporter: {
          select: {
            id: true,
            email: true,
            role: true,
          },
        },
        assignedTo: {
          select: {
            id: true,
            email: true,
            role: true,
          },
        },
        property: {
          select: {
            id: true,
            name: true,
            address: true,
          },
        },
      },
    });

    // Send notification if status changed
    if (status && status !== existingComplaint.status) {
      await sendNotificationToUser(existingComplaint.reporterId, {
        title: 'Complaint Status Updated',
        body: `Your complaint "${existingComplaint.title}" status has been updated to ${status}`,
        type: 'complaint',
        data: { complaintId: id },
      });
    }

    logger.info(`Complaint updated: ${id} by ${req.user.email}`);

    res.json({
      message: 'Complaint updated successfully',
      complaint: updatedComplaint,
    });
  } catch (error) {
    logger.error('Error updating complaint:', error);
    res.status(500).json({
      error: 'Internal server error',
      message: 'Failed to update complaint',
    });
  }
};

export const deleteComplaint = async (req, res) => {
  try {
    const { id } = req.params;

    const existingComplaint = await prisma.complaint.findUnique({
      where: { id },
      include: {
        property: true,
      },
    });

    if (!existingComplaint) {
      return res.status(404).json({
        error: 'Complaint not found',
        message: 'Complaint with this ID does not exist',
      });
    }

    // Check permissions
    const allowedOwnerId = req.user.role === 'OWNER' ? req.user.owner.id : req.user.manager.ownerId;
    if (existingComplaint.property && existingComplaint.property.ownerId !== allowedOwnerId) {
      return res.status(403).json({
        error: 'Forbidden',
        message: 'You can only delete complaints for properties you manage',
      });
    }

    await prisma.complaint.delete({
      where: { id },
    });

    logger.info(`Complaint deleted: ${id} by ${req.user.email}`);

    res.json({
      message: 'Complaint deleted successfully',
    });
  } catch (error) {
    logger.error('Error deleting complaint:', error);
    res.status(500).json({
      error: 'Internal server error',
      message: 'Failed to delete complaint',
    });
  }
};

export const assignComplaint = async (req, res) => {
  try {
    const { id } = req.params;
    const { managerId } = req.body;

    const complaint = await prisma.complaint.findUnique({
      where: { id },
      include: {
        property: true,
      },
    });

    if (!complaint) {
      return res.status(404).json({
        error: 'Complaint not found',
        message: 'Complaint with this ID does not exist',
      });
    }

    // Verify manager exists and belongs to the owner
    const manager = await prisma.manager.findUnique({
      where: { id: managerId },
    });

    if (!manager) {
      return res.status(404).json({
        error: 'Manager not found',
        message: 'Manager with this ID does not exist',
      });
    }

    const allowedOwnerId = req.user.role === 'OWNER' ? req.user.owner.id : req.user.manager.ownerId;
    if (manager.ownerId !== allowedOwnerId) {
      return res.status(403).json({
        error: 'Forbidden',
        message: 'You can only assign complaints to your own managers',
      });
    }

    const updatedComplaint = await prisma.complaint.update({
      where: { id },
      data: {
        assignedToId: managerId,
        status: 'IN_PROGRESS',
      },
      include: {
        assignedTo: {
          select: {
            id: true,
            email: true,
            role: true,
          },
        },
      },
    });

    // Send notification to assigned manager
    await sendNotificationToUser(managerId, {
      title: 'Complaint Assigned',
      body: `You have been assigned a new complaint: "${complaint.title}"`,
      type: 'complaint',
      data: { complaintId: id },
    });

    logger.info(`Complaint assigned: ${id} to ${managerId} by ${req.user.email}`);

    res.json({
      message: 'Complaint assigned successfully',
      complaint: updatedComplaint,
    });
  } catch (error) {
    logger.error('Error assigning complaint:', error);
    res.status(500).json({
      error: 'Internal server error',
      message: 'Failed to assign complaint',
    });
  }
};

export const updateComplaintStatus = async (req, res) => {
  try {
    const { id } = req.params;
    const { status, resolution } = req.body;

    const complaint = await prisma.complaint.findUnique({
      where: { id },
    });

    if (!complaint) {
      return res.status(404).json({
        error: 'Complaint not found',
        message: 'Complaint with this ID does not exist',
      });
    }

    const updateData = { status };
    if (status === 'RESOLVED' && resolution) {
      updateData.resolution = resolution;
      updateData.resolvedAt = new Date();
    }

    const updatedComplaint = await prisma.complaint.update({
      where: { id },
      data: updateData,
      include: {
        reporter: {
          select: {
            id: true,
            email: true,
            role: true,
          },
        },
        assignedTo: {
          select: {
            id: true,
            email: true,
            role: true,
          },
        },
        property: {
          select: {
            id: true,
            name: true,
            address: true,
          },
        },
      },
    });

    // Send notification to reporter
    await sendNotificationToUser(complaint.reporterId, {
      title: 'Complaint Status Updated',
      body: `Your complaint "${complaint.title}" status has been updated to ${status}`,
      type: 'complaint',
      data: { complaintId: id },
    });

    logger.info(`Complaint status updated: ${id} to ${status} by ${req.user.email}`);

    res.json({
      message: 'Complaint status updated successfully',
      complaint: updatedComplaint,
    });
  } catch (error) {
    logger.error('Error updating complaint status:', error);
    res.status(500).json({
      error: 'Internal server error',
      message: 'Failed to update complaint status',
    });
  }
};

export const resolveComplaint = async (req, res) => {
  try {
    const { id } = req.params;
    const { resolution } = req.body;

    const complaint = await prisma.complaint.findUnique({
      where: { id },
      include: {
        property: true,
      },
    });

    if (!complaint) {
      return res.status(404).json({
        error: 'Complaint not found',
        message: 'Complaint with this ID does not exist',
      });
    }

    // Check permissions
    const allowedOwnerId = req.user.role === 'OWNER' ? req.user.owner.id : req.user.manager.ownerId;
    if (complaint.property && complaint.property.ownerId !== allowedOwnerId) {
      return res.status(403).json({
        error: 'Forbidden',
        message: 'You can only resolve complaints for properties you manage',
      });
    }

    const updatedComplaint = await prisma.complaint.update({
      where: { id },
      data: {
        status: 'RESOLVED',
        resolution,
        resolvedAt: new Date(),
        resolvedById: req.user.id,
      },
      include: {
        reporter: {
          select: {
            id: true,
            email: true,
          },
        },
        resolvedBy: {
          select: {
            id: true,
            email: true,
            role: true,
          },
        },
      },
    });

    // Send notification to complaint reporter
    await sendNotificationToUser(complaint.reporterId, {
      title: 'Complaint Resolved',
      body: `Your complaint "${complaint.title}" has been resolved`,
      type: 'complaint',
      data: { complaintId: id },
    });

    logger.info(`Complaint resolved: ${id} by ${req.user.email}`);

    res.json({
      message: 'Complaint resolved successfully',
      complaint: updatedComplaint,
    });
  } catch (error) {
    logger.error('Error resolving complaint:', error);
    res.status(500).json({
      error: 'Internal server error',
      message: 'Failed to resolve complaint',
    });
  }
};

================
File: src/modules/complaints/routes/complaintRoutes.js
================
import { Router } from 'express';
import { authenticate, authorize } from '../../../middleware/auth.js';
import { validateComplaint, validateComplaintUpdate } from '../../../middleware/validation.js';
import {
  createComplaint,
  getComplaints,
  getComplaintById,
  updateComplaint,
  deleteComplaint,
  assignComplaint,
  updateComplaintStatus,
} from '../controllers/complaintController.js';

const router = Router();

/**
 * @swagger
 * /complaints:
 *   post:
 *     tags: [Complaints]
 *     summary: Create a new complaint
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - title
 *               - description
 *               - priority
 *               - category
 *             properties:
 *               title:
 *                 type: string
 *               description:
 *                 type: string
 *               priority:
 *                 type: string
 *                 enum: [LOW, MEDIUM, HIGH, URGENT]
 *               category:
 *                 type: string
 *                 enum: [MAINTENANCE, NOISE, UTILITIES, SECURITY, OTHER]
 *               propertyId:
 *                 type: string
 *     responses:
 *       201:
 *         description: Complaint created successfully
 */
router.post('/', authenticate, authorize(['TENANT', 'MANAGER', 'OWNER']), validateComplaint, createComplaint);

/**
 * @swagger
 * /complaints:
 *   get:
 *     tags: [Complaints]
 *     summary: Get all complaints
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: query
 *         name: page
 *         schema:
 *           type: integer
 *           default: 1
 *       - in: query
 *         name: limit
 *         schema:
 *           type: integer
 *           default: 10
 *       - in: query
 *         name: status
 *         schema:
 *           type: string
 *           enum: [OPEN, IN_PROGRESS, RESOLVED, CLOSED]
 *       - in: query
 *         name: priority
 *         schema:
 *           type: string
 *           enum: [LOW, MEDIUM, HIGH, URGENT]
 *     responses:
 *       200:
 *         description: List of complaints
 */
router.get('/', authenticate, authorize(['TENANT', 'MANAGER', 'OWNER', 'SUPER_ADMIN']), getComplaints);

/**
 * @swagger
 * /complaints/{id}:
 *   get:
 *     tags: [Complaints]
 *     summary: Get complaint by ID
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Complaint details
 */
router.get('/:id', authenticate, authorize(['TENANT', 'MANAGER', 'OWNER', 'SUPER_ADMIN']), getComplaintById);

/**
 * @swagger
 * /complaints/{id}:
 *   put:
 *     tags: [Complaints]
 *     summary: Update complaint
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     requestBody:
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               title:
 *                 type: string
 *               description:
 *                 type: string
 *               priority:
 *                 type: string
 *                 enum: [LOW, MEDIUM, HIGH, URGENT]
 *               status:
 *                 type: string
 *                 enum: [OPEN, IN_PROGRESS, RESOLVED, CLOSED]
 *     responses:
 *       200:
 *         description: Complaint updated successfully
 */
router.put('/:id', authenticate, authorize(['TENANT', 'MANAGER', 'OWNER']), validateComplaintUpdate, updateComplaint);

/**
 * @swagger
 * /complaints/{id}:
 *   delete:
 *     tags: [Complaints]
 *     summary: Delete complaint
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       204:
 *         description: Complaint deleted successfully
 */
router.delete('/:id', authenticate, authorize(['MANAGER', 'OWNER', 'SUPER_ADMIN']), deleteComplaint);

/**
 * @swagger
 * /complaints/{id}/assign:
 *   post:
 *     tags: [Complaints]
 *     summary: Assign complaint to manager
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - managerId
 *             properties:
 *               managerId:
 *                 type: string
 *     responses:
 *       200:
 *         description: Complaint assigned successfully
 */
router.post('/:id/assign', authenticate, authorize(['OWNER', 'SUPER_ADMIN']), assignComplaint);

/**
 * @swagger
 * /complaints/{id}/status:
 *   patch:
 *     tags: [Complaints]
 *     summary: Update complaint status
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - status
 *             properties:
 *               status:
 *                 type: string
 *                 enum: [OPEN, IN_PROGRESS, RESOLVED, CLOSED]
 *               resolution:
 *                 type: string
 *     responses:
 *       200:
 *         description: Complaint status updated successfully
 */
router.patch('/:id/status', authenticate, authorize(['MANAGER', 'OWNER', 'SUPER_ADMIN']), updateComplaintStatus);

export default router;

================
File: src/modules/leases/controllers/leaseController.js
================
import prisma from '../../../config/database.js';
import logger from '../../../config/logger.js';
import { sendNotificationToUser } from '../../notifications/services/socketService.js';

export const createLease = async (req, res) => {
  try {
    const {
      tenantId,
      propertyId,
      startDate,
      endDate,
      monthlyRent,
      securityDeposit,
      terms,
      utilities,
    } = req.body;

    // Verify tenant and property exist and check permissions
    const [tenant, property] = await Promise.all([
      prisma.tenant.findUnique({
        where: { id: tenantId },
        include: { user: true },
      }),
      prisma.property.findUnique({
        where: { id: propertyId },
        include: { owner: true },
      }),
    ]);

    if (!tenant) {
      return res.status(404).json({
        error: 'Tenant not found',
        message: 'Tenant with this ID does not exist',
      });
    }

    if (!property) {
      return res.status(404).json({
        error: 'Property not found',
        message: 'Property with this ID does not exist',
      });
    }

    // Check permissions
    const allowedOwnerId = req.user.role === 'OWNER' ? req.user.owner.id : req.user.manager?.ownerId;
    if (property.ownerId !== allowedOwnerId) {
      return res.status(403).json({
        error: 'Forbidden',
        message: 'You can only create leases for your own properties',
      });
    }

    // Check for overlapping active leases
    const existingLease = await prisma.lease.findFirst({
      where: {
        OR: [
          { tenantId, status: 'ACTIVE' },
          {
            propertyId,
            status: 'ACTIVE',
            OR: [
              {
                startDate: { lte: new Date(endDate) },
                endDate: { gte: new Date(startDate) },
              },
            ],
          },
        ],
      },
    });

    if (existingLease) {
      return res.status(400).json({
        error: 'Conflicting lease',
        message: 'Tenant already has an active lease or property has overlapping lease period',
      });
    }

    const lease = await prisma.lease.create({
      data: {
        tenantId,
        propertyId,
        startDate: new Date(startDate),
        endDate: new Date(endDate),
        monthlyRent: parseFloat(monthlyRent),
        securityDeposit: parseFloat(securityDeposit),
        terms,
        utilities,
        status: 'ACTIVE',
      },
      include: {
        tenant: {
          include: {
            user: {
              select: {
                id: true,
                email: true,
              },
            },
          },
        },
        property: {
          select: {
            id: true,
            name: true,
            address: true,
          },
        },
      },
    });

    // Update tenant status
    await prisma.tenant.update({
      where: { id: tenantId },
      data: { isActive: true },
    });

    // Send notification to tenant
    await sendNotificationToUser(tenant.user.id, {
      title: 'New Lease Agreement',
      body: `Your lease for ${property.name} has been created and is now active.`,
      type: 'lease',
      data: { leaseId: lease.id },
    });

    logger.info(`Lease created for tenant ${tenant.user.email} at property ${property.name} by ${req.user.email}`);

    res.status(201).json({
      message: 'Lease created successfully',
      lease,
    });
  } catch (error) {
    logger.error('Error creating lease:', error);
    res.status(500).json({
      error: 'Internal server error',
      message: 'Failed to create lease',
    });
  }
};

export const getLeases = async (req, res) => {
  try {
    const { page = 1, limit = 10, status, propertyId, tenantId } = req.query;
    const skip = (parseInt(page) - 1) * parseInt(limit);

    let where = {};

    // Apply role-based filtering
    if (req.user.role === 'OWNER') {
      where.property = { ownerId: req.user.owner.id };
    } else if (req.user.role === 'MANAGER') {
      where.property = { ownerId: req.user.manager.ownerId };
    } else if (req.user.role === 'TENANT') {
      where.tenantId = req.user.tenant.id;
    }

    // Apply filters
    if (status) where.status = status;
    if (propertyId) where.propertyId = propertyId;
    if (tenantId) where.tenantId = tenantId;

    const [leases, total] = await Promise.all([
      prisma.lease.findMany({
        where,
        skip,
        take: parseInt(limit),
        include: {
          tenant: {
            select: {
              id: true,
              firstName: true,
              lastName: true,
              user: {
                select: {
                  email: true,
                },
              },
            },
          },
          property: {
            select: {
              id: true,
              name: true,
              address: true,
            },
          },
          payments: {
            select: {
              id: true,
              amount: true,
              status: true,
              dueDate: true,
            },
          },
        },
        orderBy: { createdAt: 'desc' },
      }),
      prisma.lease.count({ where }),
    ]);

    res.json({
      leases,
      pagination: {
        total,
        page: parseInt(page),
        limit: parseInt(limit),
        pages: Math.ceil(total / parseInt(limit)),
      },
    });
  } catch (error) {
    logger.error('Error fetching leases:', error);
    res.status(500).json({
      error: 'Internal server error',
      message: 'Failed to fetch leases',
    });
  }
};

export const getLeaseById = async (req, res) => {
  try {
    const { id } = req.params;

    const lease = await prisma.lease.findUnique({
      where: { id },
      include: {
        tenant: {
          include: {
            user: {
              select: {
                id: true,
                email: true,
              },
            },
          },
        },
        property: {
          include: {
            owner: {
              select: {
                id: true,
                companyName: true,
              },
            },
          },
        },
        payments: {
          orderBy: { dueDate: 'desc' },
        },
        documents: true,
      },
    });

    if (!lease) {
      return res.status(404).json({
        error: 'Lease not found',
        message: 'Lease with this ID does not exist',
      });
    }

    // Check permissions
    if (req.user.role === 'OWNER' && lease.property.ownerId !== req.user.owner.id) {
      return res.status(403).json({
        error: 'Forbidden',
        message: 'You can only access leases for your own properties',
      });
    }

    if (req.user.role === 'MANAGER' && lease.property.ownerId !== req.user.manager.ownerId) {
      return res.status(403).json({
        error: 'Forbidden',
        message: 'You can only access leases for properties you manage',
      });
    }

    if (req.user.role === 'TENANT' && lease.tenantId !== req.user.tenant.id) {
      return res.status(403).json({
        error: 'Forbidden',
        message: 'You can only access your own leases',
      });
    }

    res.json(lease);
  } catch (error) {
    logger.error('Error fetching lease:', error);
    res.status(500).json({
      error: 'Internal server error',
      message: 'Failed to fetch lease',
    });
  }
};

export const updateLease = async (req, res) => {
  try {
    const { id } = req.params;
    const { monthlyRent, terms, utilities } = req.body;

    const existingLease = await prisma.lease.findUnique({
      where: { id },
      include: {
        property: true,
        tenant: {
          include: {
            user: true,
          },
        },
      },
    });

    if (!existingLease) {
      return res.status(404).json({
        error: 'Lease not found',
        message: 'Lease with this ID does not exist',
      });
    }

    // Check permissions
    const allowedOwnerId = req.user.role === 'OWNER' ? req.user.owner.id : req.user.manager?.ownerId;
    if (existingLease.property.ownerId !== allowedOwnerId) {
      return res.status(403).json({
        error: 'Forbidden',
        message: 'You can only update leases for your own properties',
      });
    }

    const updatedLease = await prisma.lease.update({
      where: { id },
      data: {
        ...(monthlyRent && { monthlyRent: parseFloat(monthlyRent) }),
        ...(terms && { terms }),
        ...(utilities && { utilities }),
      },
      include: {
        tenant: {
          include: {
            user: {
              select: {
                id: true,
                email: true,
              },
            },
          },
        },
        property: {
          select: {
            id: true,
            name: true,
            address: true,
          },
        },
      },
    });

    // Send notification to tenant if rent was changed
    if (monthlyRent && parseFloat(monthlyRent) !== existingLease.monthlyRent) {
      await sendNotificationToUser(existingLease.tenant.user.id, {
        title: 'Lease Updated',
        body: `Your lease terms have been updated. New monthly rent: $${monthlyRent}`,
        type: 'lease',
        data: { leaseId: id },
      });
    }

    logger.info(`Lease updated: ${id} by ${req.user.email}`);

    res.json({
      message: 'Lease updated successfully',
      lease: updatedLease,
    });
  } catch (error) {
    logger.error('Error updating lease:', error);
    res.status(500).json({
      error: 'Internal server error',
      message: 'Failed to update lease',
    });
  }
};

export const deleteLease = async (req, res) => {
  try {
    const { id } = req.params;

    const lease = await prisma.lease.findUnique({
      where: { id },
      include: {
        property: true,
        payments: true,
      },
    });

    if (!lease) {
      return res.status(404).json({
        error: 'Lease not found',
        message: 'Lease with this ID does not exist',
      });
    }

    // Check permissions
    const allowedOwnerId = req.user.role === 'OWNER' ? req.user.owner.id : req.user.manager?.ownerId;
    if (lease.property.ownerId !== allowedOwnerId) {
      return res.status(403).json({
        error: 'Forbidden',
        message: 'You can only delete leases for your own properties',
      });
    }

    // Check if lease has payments
    if (lease.payments.length > 0) {
      return res.status(400).json({
        error: 'Cannot delete lease',
        message: 'Lease has associated payments. Please handle them first.',
      });
    }

    await prisma.lease.delete({
      where: { id },
    });

    logger.info(`Lease deleted: ${id} by ${req.user.email}`);

    res.json({
      message: 'Lease deleted successfully',
    });
  } catch (error) {
    logger.error('Error deleting lease:', error);
    res.status(500).json({
      error: 'Internal server error',
      message: 'Failed to delete lease',
    });
  }
};

export const terminateLease = async (req, res) => {
  try {
    const { id } = req.params;
    const { terminationDate, reason } = req.body;

    const lease = await prisma.lease.findUnique({
      where: { id },
      include: {
        property: true,
        tenant: {
          include: {
            user: true,
          },
        },
      },
    });

    if (!lease) {
      return res.status(404).json({
        error: 'Lease not found',
        message: 'Lease with this ID does not exist',
      });
    }

    // Check permissions
    const allowedOwnerId = req.user.role === 'OWNER' ? req.user.owner.id : req.user.manager?.ownerId;
    if (lease.property.ownerId !== allowedOwnerId) {
      return res.status(403).json({
        error: 'Forbidden',
        message: 'You can only terminate leases for your own properties',
      });
    }

    if (lease.status === 'TERMINATED') {
      return res.status(400).json({
        error: 'Lease already terminated',
        message: 'This lease has already been terminated',
      });
    }

    const updatedLease = await prisma.lease.update({
      where: { id },
      data: {
        status: 'TERMINATED',
        terminationDate: terminationDate ? new Date(terminationDate) : new Date(),
        terminationReason: reason,
      },
    });

    // Update tenant status
    await prisma.tenant.update({
      where: { id: lease.tenantId },
      data: { isActive: false },
    });

    // Send notification to tenant
    await sendNotificationToUser(lease.tenant.user.id, {
      title: 'Lease Terminated',
      body: `Your lease for ${lease.property.name} has been terminated.`,
      type: 'lease',
      data: { leaseId: id },
    });

    logger.info(`Lease terminated: ${id} by ${req.user.email}`);

    res.json({
      message: 'Lease terminated successfully',
      lease: updatedLease,
    });
  } catch (error) {
    logger.error('Error terminating lease:', error);
    res.status(500).json({
      error: 'Internal server error',
      message: 'Failed to terminate lease',
    });
  }
};

export const renewLease = async (req, res) => {
  try {
    const { id } = req.params;
    const { newEndDate, newMonthlyRent } = req.body;

    const lease = await prisma.lease.findUnique({
      where: { id },
      include: {
        property: true,
        tenant: {
          include: {
            user: true,
          },
        },
      },
    });

    if (!lease) {
      return res.status(404).json({
        error: 'Lease not found',
        message: 'Lease with this ID does not exist',
      });
    }

    // Check permissions
    const allowedOwnerId = req.user.role === 'OWNER' ? req.user.owner.id : req.user.manager?.ownerId;
    if (lease.property.ownerId !== allowedOwnerId) {
      return res.status(403).json({
        error: 'Forbidden',
        message: 'You can only renew leases for your own properties',
      });
    }

    if (lease.status !== 'ACTIVE') {
      return res.status(400).json({
        error: 'Cannot renew lease',
        message: 'Only active leases can be renewed',
      });
    }

    const updatedLease = await prisma.lease.update({
      where: { id },
      data: {
        endDate: new Date(newEndDate),
        ...(newMonthlyRent && { monthlyRent: parseFloat(newMonthlyRent) }),
      },
    });

    // Send notification to tenant
    await sendNotificationToUser(lease.tenant.user.id, {
      title: 'Lease Renewed',
      body: `Your lease for ${lease.property.name} has been renewed until ${new Date(newEndDate).toLocaleDateString()}.`,
      type: 'lease',
      data: { leaseId: id },
    });

    logger.info(`Lease renewed: ${id} by ${req.user.email}`);

    res.json({
      message: 'Lease renewed successfully',
      lease: updatedLease,
    });
  } catch (error) {
    logger.error('Error renewing lease:', error);
    res.status(500).json({
      error: 'Internal server error',
      message: 'Failed to renew lease',
    });
  }
};

export const getLeaseDocuments = async (req, res) => {
  try {
    const { id } = req.params;

    const lease = await prisma.lease.findUnique({
      where: { id },
      include: {
        property: true,
        documents: true,
      },
    });

    if (!lease) {
      return res.status(404).json({
        error: 'Lease not found',
        message: 'Lease with this ID does not exist',
      });
    }

    // Check permissions
    if (req.user.role === 'OWNER' && lease.property.ownerId !== req.user.owner.id) {
      return res.status(403).json({
        error: 'Forbidden',
        message: 'You can only access documents for your own properties',
      });
    }

    if (req.user.role === 'MANAGER' && lease.property.ownerId !== req.user.manager.ownerId) {
      return res.status(403).json({
        error: 'Forbidden',
        message: 'You can only access documents for properties you manage',
      });
    }

    if (req.user.role === 'TENANT' && lease.tenantId !== req.user.tenant.id) {
      return res.status(403).json({
        error: 'Forbidden',
        message: 'You can only access your own lease documents',
      });
    }

    res.json({
      documents: lease.documents,
    });
  } catch (error) {
    logger.error('Error fetching lease documents:', error);
    res.status(500).json({
      error: 'Internal server error',
      message: 'Failed to fetch lease documents',
    });
  }
};

================
File: src/modules/leases/routes/leaseRoutes.js
================
import express from 'express';
import { authenticate, authorize } from '../../../middleware/auth.js';
import {
  createLease,
  getLeases,
  getLeaseById,
  updateLease,
  deleteLease,
  terminateLease,
  renewLease,
  getLeaseDocuments,
} from '../controllers/leaseController.js';

const router = express.Router();

/**
 * @swagger
 * /leases:
 *   post:
 *     summary: Create a new lease
 *     tags: [Leases]
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       201:
 *         description: Lease created successfully
 */
router.post('/', authenticate, authorize(['SUPER_ADMIN', 'OWNER', 'MANAGER']), createLease);

/**
 * @swagger
 * /leases:
 *   get:
 *     summary: Get all leases
 *     tags: [Leases]
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: List of leases
 */
router.get('/', authenticate, getLeases);

/**
 * @swagger
 * /leases/{id}:
 *   get:
 *     summary: Get lease by ID
 *     tags: [Leases]
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: Lease details
 */
router.get('/:id', authenticate, getLeaseById);

/**
 * @swagger
 * /leases/{id}:
 *   put:
 *     summary: Update lease
 *     tags: [Leases]
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: Lease updated successfully
 */
router.put('/:id', authenticate, authorize(['SUPER_ADMIN', 'OWNER', 'MANAGER']), updateLease);

/**
 * @swagger
 * /leases/{id}:
 *   delete:
 *     summary: Delete lease
 *     tags: [Leases]
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: Lease deleted successfully
 */
router.delete('/:id', authenticate, authorize(['SUPER_ADMIN', 'OWNER', 'MANAGER']), deleteLease);

/**
 * @swagger
 * /leases/{id}/terminate:
 *   post:
 *     summary: Terminate lease
 *     tags: [Leases]
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: Lease terminated successfully
 */
router.post('/:id/terminate', authenticate, authorize(['SUPER_ADMIN', 'OWNER', 'MANAGER']), terminateLease);

/**
 * @swagger
 * /leases/{id}/renew:
 *   post:
 *     summary: Renew lease
 *     tags: [Leases]
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: Lease renewed successfully
 */
router.post('/:id/renew', authenticate, authorize(['SUPER_ADMIN', 'OWNER', 'MANAGER']), renewLease);

/**
 * @swagger
 * /leases/{id}/documents:
 *   get:
 *     summary: Get lease documents
 *     tags: [Leases]
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: List of lease documents
 */
router.get('/:id/documents', authenticate, getLeaseDocuments);

export default router;

================
File: src/modules/maintenance/controllers/maintenanceController.js
================
import prisma from '../../../config/database.js';
import logger from '../../../config/logger.js';
import { successResponse, errorResponse } from '../../../utils/responseHelpers.js';
import { sendNotificationToUser } from '../../notifications/services/socketService.js';
import { sendEmail } from '../../notifications/services/emailService.js';

export const createMaintenanceRequest = async (req, res) => {
  try {
    const { title, description, priority, category, propertyId, urgency } = req.body;
    const userId = req.user.userId;

    // Verify property exists
    const property = await prisma.property.findUnique({
      where: { id: propertyId },
      include: {
        owner: {
          include: { user: true },
        },
        managers: {
          include: { user: true },
        },
      },
    });

    if (!property) {
      return errorResponse(res, 'Property not found', 404);
    }

    // Check if user has permission to create maintenance request for this property
    if (req.user.role === 'TENANT') {
      const tenant = await prisma.tenant.findFirst({
        where: {
          userId,
          properties: {
            some: { id: propertyId },
          },
        },
      });

      if (!tenant) {
        return errorResponse(res, 'You can only create maintenance requests for your assigned properties', 403);
      }
    }

    const maintenanceRequest = await prisma.maintenanceRequest.create({
      data: {
        title,
        description,
        priority,
        category,
        urgency,
        propertyId,
        requestedById: userId,
        status: 'OPEN',
      },
      include: {
        requestedBy: {
          select: {
            id: true,
            email: true,
            firstName: true,
            lastName: true,
          },
        },
        property: {
          select: {
            id: true,
            name: true,
            address: true,
          },
        },
      },
    });

    // Notify property owner and managers
    const notificationPromises = [];
    
    if (property.owner) {
      notificationPromises.push(
        sendNotificationToUser(property.owner.userId, {
          title: 'New Maintenance Request',
          body: `New maintenance request: ${title}`,
          type: 'maintenance',
          data: { maintenanceRequestId: maintenanceRequest.id },
        })
      );
    }

    property.managers.forEach((manager) => {
      notificationPromises.push(
        sendNotificationToUser(manager.userId, {
          title: 'New Maintenance Request',
          body: `New maintenance request: ${title}`,
          type: 'maintenance',
          data: { maintenanceRequestId: maintenanceRequest.id },
        })
      );
    });

    await Promise.all(notificationPromises);

    logger.info(`Maintenance request created: ${maintenanceRequest.id} by ${req.user.email}`);

    return successResponse(res, 'Maintenance request created successfully', maintenanceRequest, 201);
  } catch (error) {
    logger.error('Error creating maintenance request:', error);
    return errorResponse(res, 'Failed to create maintenance request');
  }
};

export const getMaintenanceRequests = async (req, res) => {
  try {
    const { page = 1, limit = 10, status, priority, category, propertyId } = req.query;
    const skip = (parseInt(page) - 1) * parseInt(limit);

    const where = {};

    // Apply role-based filtering
    if (req.user.role === 'TENANT') {
      where.requestedById = req.user.userId;
    } else if (req.user.role === 'MANAGER') {
      const managerProperties = await prisma.property.findMany({
        where: {
          managers: {
            some: { userId: req.user.userId },
          },
        },
        select: { id: true },
      });
      where.propertyId = {
        in: managerProperties.map((p) => p.id),
      };
    } else if (req.user.role === 'OWNER') {
      where.property = {
        ownerId: req.user.owner.id,
      };
    }

    // Apply filters
    if (status) where.status = status;
    if (priority) where.priority = priority;
    if (category) where.category = category;
    if (propertyId) where.propertyId = propertyId;

    const [requests, total] = await Promise.all([
      prisma.maintenanceRequest.findMany({
        where,
        skip,
        take: parseInt(limit),
        include: {
          requestedBy: {
            select: {
              id: true,
              email: true,
              firstName: true,
              lastName: true,
            },
          },
          assignedTo: {
            select: {
              id: true,
              email: true,
              firstName: true,
              lastName: true,
            },
          },
          property: {
            select: {
              id: true,
              name: true,
              address: true,
            },
          },
        },
        orderBy: { createdAt: 'desc' },
      }),
      prisma.maintenanceRequest.count({ where }),
    ]);

    return successResponse(res, 'Maintenance requests retrieved successfully', {
      requests,
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total,
        pages: Math.ceil(total / parseInt(limit)),
      },
    });
  } catch (error) {
    logger.error('Error getting maintenance requests:', error);
    return errorResponse(res, 'Failed to retrieve maintenance requests');
  }
};

export const getMaintenanceRequestById = async (req, res) => {
  try {
    const { id } = req.params;

    const request = await prisma.maintenanceRequest.findUnique({
      where: { id },
      include: {
        requestedBy: {
          select: {
            id: true,
            email: true,
            firstName: true,
            lastName: true,
          },
        },
        assignedTo: {
          select: {
            id: true,
            email: true,
            firstName: true,
            lastName: true,
          },
        },
        property: {
          select: {
            id: true,
            name: true,
            address: true,
          },
        },
        updates: {
          include: {
            updatedBy: {
              select: {
                id: true,
                email: true,
                firstName: true,
                lastName: true,
              },
            },
          },
          orderBy: { createdAt: 'desc' },
        },
      },
    });

    if (!request) {
      return errorResponse(res, 'Maintenance request not found', 404);
    }

    // Check permissions
    const hasAccess =
      req.user.role === 'SUPER_ADMIN' ||
      request.requestedById === req.user.userId ||
      (req.user.role === 'OWNER' && request.property.ownerId === req.user.owner?.id) ||
      (req.user.role === 'MANAGER' && request.assignedToId === req.user.userId);

    if (!hasAccess) {
      return errorResponse(res, 'Access denied', 403);
    }

    return successResponse(res, 'Maintenance request retrieved successfully', request);
  } catch (error) {
    logger.error('Error getting maintenance request:', error);
    return errorResponse(res, 'Failed to retrieve maintenance request');
  }
};

export const updateMaintenanceRequest = async (req, res) => {
  try {
    const { id } = req.params;
    const { title, description, priority, category, urgency, status, resolution } = req.body;

    const request = await prisma.maintenanceRequest.findUnique({
      where: { id },
      include: {
        property: {
          include: {
            owner: true,
          },
        },
      },
    });

    if (!request) {
      return errorResponse(res, 'Maintenance request not found', 404);
    }

    // Check permissions
    const canUpdate =
      req.user.role === 'SUPER_ADMIN' ||
      (req.user.role === 'OWNER' && request.property.ownerId === req.user.owner?.id) ||
      (req.user.role === 'MANAGER' && request.assignedToId === req.user.userId);

    if (!canUpdate) {
      return errorResponse(res, 'Access denied', 403);
    }

    const updatedRequest = await prisma.maintenanceRequest.update({
      where: { id },
      data: {
        ...(title && { title }),
        ...(description && { description }),
        ...(priority && { priority }),
        ...(category && { category }),
        ...(urgency && { urgency }),
        ...(status && { status }),
        ...(resolution && { resolution }),
        ...(status === 'COMPLETED' && { completedAt: new Date() }),
      },
      include: {
        requestedBy: {
          select: {
            id: true,
            email: true,
            firstName: true,
            lastName: true,
          },
        },
        property: {
          select: {
            id: true,
            name: true,
            address: true,
          },
        },
      },
    });

    // Create update log
    await prisma.maintenanceUpdate.create({
      data: {
        maintenanceRequestId: id,
        updatedById: req.user.userId,
        changes: req.body,
        description: `Request updated by ${req.user.firstName} ${req.user.lastName}`,
      },
    });

    // Send notification if status changed
    if (status && status !== request.status) {
      await sendNotificationToUser(request.requestedById, {
        title: 'Maintenance Request Updated',
        body: `Your maintenance request status has been updated to: ${status}`,
        type: 'maintenance',
        data: { maintenanceRequestId: id },
      });
    }

    logger.info(`Maintenance request updated: ${id} by ${req.user.email}`);

    return successResponse(res, 'Maintenance request updated successfully', updatedRequest);
  } catch (error) {
    logger.error('Error updating maintenance request:', error);
    return errorResponse(res, 'Failed to update maintenance request');
  }
};

export const assignMaintenanceRequest = async (req, res) => {
  try {
    const { id } = req.params;
    const { assignedToId } = req.body;

    const request = await prisma.maintenanceRequest.findUnique({
      where: { id },
      include: {
        property: {
          include: {
            owner: true,
          },
        },
      },
    });

    if (!request) {
      return errorResponse(res, 'Maintenance request not found', 404);
    }

    // Verify assignee exists and has appropriate role
    const assignee = await prisma.user.findUnique({
      where: { id: assignedToId },
    });

    if (!assignee || !['MANAGER', 'OWNER'].includes(assignee.role)) {
      return errorResponse(res, 'Invalid assignee', 400);
    }

    const updatedRequest = await prisma.maintenanceRequest.update({
      where: { id },
      data: {
        assignedToId,
        status: 'IN_PROGRESS',
        assignedAt: new Date(),
      },
      include: {
        assignedTo: {
          select: {
            id: true,
            email: true,
            firstName: true,
            lastName: true,
          },
        },
      },
    });

    // Send notification to assignee
    await sendNotificationToUser(assignedToId, {
      title: 'Maintenance Request Assigned',
      body: `You have been assigned a maintenance request: ${request.title}`,
      type: 'maintenance',
      data: { maintenanceRequestId: id },
    });

    logger.info(`Maintenance request assigned: ${id} to ${assignee.email} by ${req.user.email}`);

    return successResponse(res, 'Maintenance request assigned successfully', updatedRequest);
  } catch (error) {
    logger.error('Error assigning maintenance request:', error);
    return errorResponse(res, 'Failed to assign maintenance request');
  }
};

export const deleteMaintenanceRequest = async (req, res) => {
  try {
    const { id } = req.params;

    const request = await prisma.maintenanceRequest.findUnique({
      where: { id },
      include: {
        property: {
          include: {
            owner: true,
          },
        },
      },
    });

    if (!request) {
      return errorResponse(res, 'Maintenance request not found', 404);
    }

    // Check permissions
    const canDelete =
      req.user.role === 'SUPER_ADMIN' ||
      (req.user.role === 'OWNER' && request.property.ownerId === req.user.owner?.id) ||
      request.requestedById === req.user.userId;

    if (!canDelete) {
      return errorResponse(res, 'Access denied', 403);
    }

    await prisma.maintenanceRequest.delete({
      where: { id },
    });

    logger.info(`Maintenance request deleted: ${id} by ${req.user.email}`);

    return successResponse(res, 'Maintenance request deleted successfully');
  } catch (error) {
    logger.error('Error deleting maintenance request:', error);
    return errorResponse(res, 'Failed to delete maintenance request');
  }
};

================
File: src/modules/maintenance/routes/maintenanceRoutes.js
================
import { Router } from 'express';
import { authenticate, authorize } from '../../../middleware/auth.js';
import { validateMaintenanceRequest, validateMaintenanceUpdate } from '../../../middleware/validation.js';
import {
  createMaintenanceRequest,
  getMaintenanceRequests,
  getMaintenanceRequestById,
  updateMaintenanceRequest,
  assignMaintenanceRequest,
  deleteMaintenanceRequest,
} from '../controllers/maintenanceController.js';

const router = Router();

/**
 * @swagger
 * components:
 *   schemas:
 *     MaintenanceRequest:
 *       type: object
 *       required:
 *         - title
 *         - description
 *         - priority
 *         - category
 *         - propertyId
 *       properties:
 *         id:
 *           type: string
 *         title:
 *           type: string
 *         description:
 *           type: string
 *         priority:
 *           type: string
 *           enum: [LOW, MEDIUM, HIGH, URGENT]
 *         category:
 *           type: string
 *           enum: [PLUMBING, ELECTRICAL, HVAC, APPLIANCE, STRUCTURAL, OTHER]
 *         urgency:
 *           type: string
 *           enum: [LOW, MEDIUM, HIGH, CRITICAL]
 *         status:
 *           type: string
 *           enum: [OPEN, IN_PROGRESS, COMPLETED, CANCELLED]
 *         propertyId:
 *           type: string
 *         requestedById:
 *           type: string
 *         assignedToId:
 *           type: string
 *         resolution:
 *           type: string
 */

/**
 * @swagger
 * /maintenance:
 *   post:
 *     tags: [Maintenance]
 *     summary: Create a new maintenance request
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/MaintenanceRequest'
 *     responses:
 *       201:
 *         description: Maintenance request created successfully
 */
router.post('/', authenticate, authorize(['TENANT', 'MANAGER', 'OWNER', 'SUPER_ADMIN']), validateMaintenanceRequest, createMaintenanceRequest);

/**
 * @swagger
 * /maintenance:
 *   get:
 *     tags: [Maintenance]
 *     summary: Get all maintenance requests
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: query
 *         name: page
 *         schema:
 *           type: integer
 *           default: 1
 *       - in: query
 *         name: limit
 *         schema:
 *           type: integer
 *           default: 10
 *       - in: query
 *         name: status
 *         schema:
 *           type: string
 *           enum: [OPEN, IN_PROGRESS, COMPLETED, CANCELLED]
 *       - in: query
 *         name: priority
 *         schema:
 *           type: string
 *           enum: [LOW, MEDIUM, HIGH, URGENT]
 *       - in: query
 *         name: category
 *         schema:
 *           type: string
 *           enum: [PLUMBING, ELECTRICAL, HVAC, APPLIANCE, STRUCTURAL, OTHER]
 *     responses:
 *       200:
 *         description: List of maintenance requests
 */
router.get('/', authenticate, authorize(['TENANT', 'MANAGER', 'OWNER', 'SUPER_ADMIN']), getMaintenanceRequests);

/**
 * @swagger
 * /maintenance/{id}:
 *   get:
 *     tags: [Maintenance]
 *     summary: Get maintenance request by ID
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Maintenance request details
 */
router.get('/:id', authenticate, authorize(['TENANT', 'MANAGER', 'OWNER', 'SUPER_ADMIN']), getMaintenanceRequestById);

/**
 * @swagger
 * /maintenance/{id}:
 *   put:
 *     tags: [Maintenance]
 *     summary: Update maintenance request
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/MaintenanceRequest'
 *     responses:
 *       200:
 *         description: Maintenance request updated successfully
 */
router.put('/:id', authenticate, authorize(['MANAGER', 'OWNER', 'SUPER_ADMIN']), validateMaintenanceUpdate, updateMaintenanceRequest);

/**
 * @swagger
 * /maintenance/{id}/assign:
 *   post:
 *     tags: [Maintenance]
 *     summary: Assign maintenance request to user
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - assignedToId
 *             properties:
 *               assignedToId:
 *                 type: string
 *     responses:
 *       200:
 *         description: Maintenance request assigned successfully
 */
router.post('/:id/assign', authenticate, authorize(['OWNER', 'SUPER_ADMIN']), assignMaintenanceRequest);

/**
 * @swagger
 * /maintenance/{id}:
 *   delete:
 *     tags: [Maintenance]
 *     summary: Delete maintenance request
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Maintenance request deleted successfully
 */
router.delete('/:id', authenticate, authorize(['OWNER', 'SUPER_ADMIN']), deleteMaintenanceRequest);

export default router;

================
File: src/modules/managers/controllers/managerController.js
================
import { asyncHandler } from '../../../middleware/errorHandler.js';
import prisma from '../../../config/database.js';
import logger from '../../../config/logger.js';
import { hashPassword, generateRandomPassword } from '../../../utils/helpers.js';
import { sendWelcomeEmail } from '../../notifications/services/emailService.js';

/**
 * @swagger
 * components:
 *   schemas:
 *     Manager:
 *       type: object
 *       properties:
 *         id:
 *           type: string
 *         firstName:
 *           type: string
 *         lastName:
 *           type: string
 *         phone:
 *           type: string
 *         permissions:
 *           type: object
 *         isActive:
 *           type: boolean
 */

/**
 * @swagger
 * /managers:
 *   get:
 *     tags: [Managers]
 *     summary: Get all managers
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: Managers retrieved successfully
 */
export const getManagers = asyncHandler(async (req, res) => {
  const { page = 1, limit = 10, search } = req.query;
  const skip = (parseInt(page) - 1) * parseInt(limit);

  const where = {};

  // Role-based filtering
  if (req.user.role === 'OWNER') {
    where.ownerId = req.user.owner.id;
  }

  if (search) {
    where.OR = [
      { firstName: { contains: search, mode: 'insensitive' } },
      { lastName: { contains: search, mode: 'insensitive' } },
      { phone: { contains: search, mode: 'insensitive' } },
      { user: { email: { contains: search, mode: 'insensitive' } } },
    ];
  }

  const [managers, total] = await Promise.all([
    prisma.manager.findMany({
      where,
      skip,
      take: parseInt(limit),
      include: {
        user: {
          select: {
            id: true,
            email: true,
            isActive: true,
            lastLogin: true,
          },
        },
        owner: {
          select: {
            id: true,
            companyName: true,
          },
        },
        properties: {
          select: {
            id: true,
            name: true,
            address: true,
          },
        },
      },
      orderBy: { createdAt: 'desc' },
    }),
    prisma.manager.count({ where }),
  ]);

  res.json({
    managers,
    pagination: {
      total,
      page: parseInt(page),
      limit: parseInt(limit),
      pages: Math.ceil(total / parseInt(limit)),
    },
  });
});

/**
 * @swagger
 * /managers/{id}:
 *   get:
 *     tags: [Managers]
 *     summary: Get manager by ID
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Manager retrieved successfully
 */
export const getManagerById = asyncHandler(async (req, res) => {
  const { id } = req.params;

  const manager = await prisma.manager.findUnique({
    where: { id },
    include: {
      user: {
        select: {
          id: true,
          email: true,
          isActive: true,
          lastLogin: true,
          createdAt: true,
        },
      },
      owner: {
        select: {
          id: true,
          companyName: true,
          phone: true,
        },
      },
      properties: {
        include: {
          tenants: {
            where: { isActive: true },
            select: {
              id: true,
              firstName: true,
              lastName: true,
            },
          },
          _count: {
            select: {
              tenants: { where: { isActive: true } },
            },
          },
        },
      },
    },
  });

  if (!manager) {
    return res.status(404).json({
      error: 'Manager not found',
      message: 'Manager with this ID does not exist',
    });
  }

  // Check permissions
  if (req.user.role === 'OWNER' && manager.ownerId !== req.user.owner.id) {
    return res.status(403).json({
      error: 'Forbidden',
      message: 'You can only access your own managers',
    });
  }

  if (req.user.role === 'MANAGER' && manager.id !== req.user.manager.id) {
    return res.status(403).json({
      error: 'Forbidden',
      message: 'You can only access your own information',
    });
  }

  res.json({ manager });
});

/**
 * @swagger
 * /managers:
 *   post:
 *     tags: [Managers]
 *     summary: Create a new manager
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - email
 *               - firstName
 *               - lastName
 *             properties:
 *               email:
 *                 type: string
 *                 format: email
 *               firstName:
 *                 type: string
 *               lastName:
 *                 type: string
 *               phone:
 *                 type: string
 *               permissions:
 *                 type: object
 *     responses:
 *       201:
 *         description: Manager created successfully
 */
export const createManager = asyncHandler(async (req, res) => {
  const { email, firstName, lastName, phone, permissions = {} } = req.body;

  // Check if email is already in use
  const existingUser = await prisma.user.findUnique({
    where: { email: email.toLowerCase() },
  });

  if (existingUser) {
    return res.status(409).json({
      error: 'Email already exists',
      message: 'A user with this email already exists',
    });
  }

  // Generate random password
  const password = generateRandomPassword();
  const hashedPassword = await hashPassword(password);

  const ownerId = req.user.owner.id;

  // Create user and manager in transaction
  const result = await prisma.$transaction(async (tx) => {
    const user = await tx.user.create({
      data: {
        email: email.toLowerCase(),
        password: hashedPassword,
        role: 'MANAGER',
      },
    });

    const manager = await tx.manager.create({
      data: {
        userId: user.id,
        ownerId,
        firstName,
        lastName,
        phone,
        permissions,
      },
      include: {
        user: {
          select: {
            id: true,
            email: true,
            isActive: true,
          },
        },
        owner: {
          select: {
            companyName: true,
          },
        },
      },
    });

    return { user, manager };
  });

  // Send welcome email with password
  try {
    await sendWelcomeEmail(email, 'MANAGER', password);
  } catch (error) {
    logger.error('Failed to send manager welcome email:', error);
  }

  logger.info(`Manager created: ${firstName} ${lastName} by user ${req.user.email}`);

  res.status(201).json({
    message: 'Manager created successfully',
    manager: result.manager,
  });
});

/**
 * @swagger
 * /managers/{id}:
 *   put:
 *     tags: [Managers]
 *     summary: Update manager
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Manager updated successfully
 */
export const updateManager = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const { firstName, lastName, phone, permissions } = req.body;

  const existingManager = await prisma.manager.findUnique({
    where: { id },
  });

  if (!existingManager) {
    return res.status(404).json({
      error: 'Manager not found',
      message: 'Manager with this ID does not exist',
    });
  }

  // Check permissions
  if (req.user.role === 'OWNER' && existingManager.ownerId !== req.user.owner.id) {
    return res.status(403).json({
      error: 'Forbidden',
      message: 'You can only update your own managers',
    });
  }

  if (req.user.role === 'MANAGER' && existingManager.id !== req.user.manager.id) {
    // Managers can only update their own basic info, not permissions
    if (permissions) {
      return res.status(403).json({
        error: 'Forbidden',
        message: 'You cannot update your own permissions',
      });
    }
  }

  const updateData = {};
  if (firstName) updateData.firstName = firstName;
  if (lastName) updateData.lastName = lastName;
  if (phone) updateData.phone = phone;
  if (permissions && req.user.role === 'OWNER') updateData.permissions = permissions;

  const manager = await prisma.manager.update({
    where: { id },
    data: updateData,
    include: {
      user: {
        select: {
          id: true,
          email: true,
          isActive: true,
        },
      },
      owner: {
        select: {
          companyName: true,
        },
      },
    },
  });

  logger.info(`Manager updated: ${manager.firstName} ${manager.lastName} by user ${req.user.email}`);

  res.json({
    message: 'Manager updated successfully',
    manager,
  });
});

/**
 * @swagger
 * /managers/{id}:
 *   delete:
 *     tags: [Managers]
 *     summary: Delete manager
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Manager deleted successfully
 */
export const deleteManager = asyncHandler(async (req, res) => {
  const { id } = req.params;

  const existingManager = await prisma.manager.findUnique({
    where: { id },
    include: {
      properties: true,
    },
  });

  if (!existingManager) {
    return res.status(404).json({
      error: 'Manager not found',
      message: 'Manager with this ID does not exist',
    });
  }

  // Check permissions
  if (existingManager.ownerId !== req.user.owner.id) {
    return res.status(403).json({
      error: 'Forbidden',
      message: 'You can only delete your own managers',
    });
  }

  // Remove manager from properties and deactivate user
  await prisma.$transaction([
    prisma.manager.delete({
      where: { id },
    }),
    prisma.user.update({
      where: { id: existingManager.userId },
      data: { isActive: false },
    }),
  ]);

  logger.info(`Manager deleted: ${existingManager.firstName} ${existingManager.lastName} by user ${req.user.email}`);

  res.json({
    message: 'Manager deleted successfully',
  });
});

export const assignPropertyToManager = asyncHandler(async (req, res) => {
  const { id: managerId, propertyId } = req.params;

  // Verify manager exists and belongs to owner
  const manager = await prisma.manager.findUnique({
    where: { id: managerId },
  });

  if (!manager || manager.ownerId !== req.user.owner.id) {
    return res.status(404).json({
      error: 'Manager not found',
      message: 'Manager not found or does not belong to you',
    });
  }

  // Verify property exists and belongs to owner
  const property = await prisma.property.findUnique({
    where: { id: propertyId },
  });

  if (!property || property.ownerId !== req.user.owner.id) {
    return res.status(404).json({
      error: 'Property not found',
      message: 'Property not found or does not belong to you',
    });
  }

  // Add property to manager's properties
  await prisma.manager.update({
    where: { id: managerId },
    data: {
      properties: {
        connect: { id: propertyId },
      },
    },
  });

  logger.info(`Property ${propertyId} assigned to manager ${managerId} by ${req.user.email}`);

  res.json({
    message: 'Property assigned to manager successfully',
  });
});

export const removePropertyFromManager = asyncHandler(async (req, res) => {
  const { id: managerId, propertyId } = req.params;

  // Verify manager exists and belongs to owner
  const manager = await prisma.manager.findUnique({
    where: { id: managerId },
  });

  if (!manager || manager.ownerId !== req.user.owner.id) {
    return res.status(404).json({
      error: 'Manager not found',
      message: 'Manager not found or does not belong to you',
    });
  }

  // Remove property from manager's properties
  await prisma.manager.update({
    where: { id: managerId },
    data: {
      properties: {
        disconnect: { id: propertyId },
      },
    },
  });

  logger.info(`Property ${propertyId} removed from manager ${managerId} by ${req.user.email}`);

  res.json({
    message: 'Property removed from manager successfully',
  });
});

export const getManagerProperties = asyncHandler(async (req, res) => {
  const { id } = req.params;

  const manager = await prisma.manager.findUnique({
    where: { id },
    include: {
      properties: {
        include: {
          tenants: {
            where: { isActive: true },
            select: {
              id: true,
              firstName: true,
              lastName: true,
            },
          },
          _count: {
            select: {
              tenants: { where: { isActive: true } },
              leases: { where: { status: 'ACTIVE' } },
            },
          },
        },
      },
    },
  });

  if (!manager) {
    return res.status(404).json({
      error: 'Manager not found',
      message: 'Manager with this ID does not exist',
    });
  }

  // Check permissions
  if (req.user.role === 'OWNER' && manager.ownerId !== req.user.owner.id) {
    return res.status(403).json({
      error: 'Forbidden',
      message: 'You can only access your own managers',
    });
  }

  if (req.user.role === 'MANAGER' && manager.id !== req.user.manager.id) {
    return res.status(403).json({
      error: 'Forbidden',
      message: 'You can only access your own properties',
    });
  }

  res.json({
    properties: manager.properties,
  });
});

================
File: src/modules/managers/routes/managerRoutes.js
================
import { Router } from 'express';
import { authenticate, authorize } from '../../../middleware/auth.js';
import { validateManager, validateManagerUpdate } from '../../../middleware/validation.js';
import {
  createManager,
  getManagers,
  getManagerById,
  updateManager,
  deleteManager,
  assignPropertyToManager,
  getManagerProperties,
  removePropertyFromManager,
} from '../controllers/managerController.js';

const router = Router();

/**
 * @swagger
 * components:
 *   schemas:
 *     Manager:
 *       type: object
 *       required:
 *         - firstName
 *         - lastName
 *         - email
 *         - phone
 *       properties:
 *         id:
 *           type: string
 *         firstName:
 *           type: string
 *         lastName:
 *           type: string
 *         email:
 *           type: string
 *         phone:
 *           type: string
 *         isActive:
 *           type: boolean
 *         specializations:
 *           type: array
 *           items:
 *             type: string
 */

/**
 * @swagger
 * /managers:
 *   post:
 *     tags: [Managers]
 *     summary: Create a new manager
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/Manager'
 *     responses:
 *       201:
 *         description: Manager created successfully
 */
router.post('/',  validateManager, createManager);

/**
 * @swagger
 * /managers:
 *   get:
 *     tags: [Managers]
 *     summary: Get all managers
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: query
 *         name: page
 *         schema:
 *           type: integer
 *           default: 1
 *       - in: query
 *         name: limit
 *         schema:
 *           type: integer
 *           default: 10
 *     responses:
 *       200:
 *         description: List of managers
 */
router.get('/', authenticate, authorize(['OWNER', 'SUPER_ADMIN']), getManagers);

/**
 * @swagger
 * /managers/{id}:
 *   get:
 *     tags: [Managers]
 *     summary: Get manager by ID
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Manager details
 */
router.get('/:id', authenticate, authorize(['MANAGER', 'OWNER', 'SUPER_ADMIN']), getManagerById);

/**
 * @swagger
 * /managers/{id}:
 *   put:
 *     tags: [Managers]
 *     summary: Update manager
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/Manager'
 *     responses:
 *       200:
 *         description: Manager updated successfully
 */
router.put('/:id', authenticate, authorize(['OWNER', 'SUPER_ADMIN']), validateManagerUpdate, updateManager);

/**
 * @swagger
 * /managers/{id}:
 *   delete:
 *     tags: [Managers]
 *     summary: Delete manager
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Manager deleted successfully
 */
router.delete('/:id', authenticate, authorize(['OWNER', 'SUPER_ADMIN']), deleteManager);

/**
 * @swagger
 * /managers/{id}/properties:
 *   get:
 *     tags: [Managers]
 *     summary: Get properties managed by manager
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: List of managed properties
 */
router.get('/:id/properties', authenticate, authorize(['MANAGER', 'OWNER', 'SUPER_ADMIN']), getManagerProperties);

/**
 * @swagger
 * /managers/{id}/properties/{propertyId}:
 *   post:
 *     tags: [Managers]
 *     summary: Assign property to manager
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *       - in: path
 *         name: propertyId
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Property assigned successfully
 */
router.post('/:id/properties/:propertyId', authenticate, authorize(['OWNER', 'SUPER_ADMIN']), assignPropertyToManager);

/**
 * @swagger
 * /managers/{id}/properties/{propertyId}:
 *   delete:
 *     tags: [Managers]
 *     summary: Unassign property from manager
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *       - in: path
 *         name: propertyId
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Property unassigned successfully
 */
router.delete('/:id/properties/:propertyId', authenticate, authorize(['OWNER', 'SUPER_ADMIN']), removePropertyFromManager);

export default router;

================
File: src/modules/notifications/controllers/notificationController.js
================
import prisma from '../../../config/database.js';
import logger from '../../../config/logger.js';
import { sendNotificationToUser, sendPushNotification } from '../services/socketService.js';
import { sendEmail } from '../services/emailService.js';

export const getNotifications = async (req, res) => {
  try {
    const userId = req.user.userId;
    const { page = 1, limit = 20, unreadOnly = false } = req.query;
    const skip = (parseInt(page) - 1) * parseInt(limit);

    const where = {
      recipientId: userId,
      ...(unreadOnly === 'true' && { isRead: false }),
    };

    const [notifications, total] = await Promise.all([
      prisma.notification.findMany({
        where,
        skip,
        take: parseInt(limit),
        orderBy: { createdAt: 'desc' },
      }),
      prisma.notification.count({ where }),
    ]);

    res.json({
      notifications,
      pagination: {
        total,
        page: parseInt(page),
        limit: parseInt(limit),
        pages: Math.ceil(total / parseInt(limit)),
      },
    });
  } catch (error) {
    logger.error('Error fetching notifications:', error);
    res.status(500).json({
      error: 'Internal server error',
      message: 'Failed to fetch notifications',
    });
  }
};

export const markAsRead = async (req, res) => {
  try {
    const { id } = req.params;
    const userId = req.user.userId;

    const notification = await prisma.notification.findFirst({
      where: {
        id,
        recipientId: userId,
      },
    });

    if (!notification) {
      return res.status(404).json({
        error: 'Notification not found',
        message: 'Notification with this ID does not exist',
      });
    }

    await prisma.notification.update({
      where: { id },
      data: { isRead: true },
    });

    res.json({
      message: 'Notification marked as read',
    });
  } catch (error) {
    logger.error('Error marking notification as read:', error);
    res.status(500).json({
      error: 'Internal server error',
      message: 'Failed to mark notification as read',
    });
  }
};

export const markAllAsRead = async (req, res) => {
  try {
    const userId = req.user.userId;

    await prisma.notification.updateMany({
      where: {
        recipientId: userId,
        isRead: false,
      },
      data: { isRead: true },
    });

    res.json({
      message: 'All notifications marked as read',
    });
  } catch (error) {
    logger.error('Error marking all notifications as read:', error);
    res.status(500).json({
      error: 'Internal server error',
      message: 'Failed to mark all notifications as read',
    });
  }
};

export const deleteNotification = async (req, res) => {
  try {
    const { id } = req.params;
    const userId = req.user.userId;

    const notification = await prisma.notification.findFirst({
      where: {
        id,
        recipientId: userId,
      },
    });

    if (!notification) {
      return res.status(404).json({
        error: 'Notification not found',
        message: 'Notification with this ID does not exist',
      });
    }

    await prisma.notification.delete({
      where: { id },
    });

    res.json({
      message: 'Notification deleted successfully',
    });
  } catch (error) {
    logger.error('Error deleting notification:', error);
    res.status(500).json({
      error: 'Internal server error',
      message: 'Failed to delete notification',
    });
  }
};

export const sendBulkNotification = async (req, res) => {
  try {
    const { title, message, recipients, type = 'IN_APP' } = req.body;

    if (!title || !message || !recipients || !Array.isArray(recipients)) {
      return res.status(400).json({
        error: 'Invalid input',
        message: 'Title, message, and recipients array are required',
      });
    }

    const notifications = recipients.map(recipientId => ({
      recipientId,
      title,
      message,
      type,
      senderId: req.user.userId,
    }));

    await prisma.notification.createMany({
      data: notifications,
    });

    // Send real-time notifications
    for (const recipientId of recipients) {
      sendNotificationToUser(recipientId, {
        title,
        body: message,
        type,
      });

      // Send email if type includes EMAIL
      if (type.includes('EMAIL')) {
        const user = await prisma.user.findUnique({
          where: { id: recipientId },
          select: { email: true },
        });

        if (user) {
          await sendEmail({
            to: user.email,
            subject: title,
            text: message,
          });
        }
      }
    }

    logger.info(`Bulk notification sent to ${recipients.length} users by ${req.user.email}`);

    res.json({
      message: 'Bulk notification sent successfully',
      recipientCount: recipients.length,
    });
  } catch (error) {
    logger.error('Error sending bulk notification:', error);
    res.status(500).json({
      error: 'Internal server error',
      message: 'Failed to send bulk notification',
    });
  }
};

export const getNotificationSettings = async (req, res) => {
  try {
    const userId = req.user.userId;

    let settings = await prisma.notificationSettings.findUnique({
      where: { userId },
    });

    if (!settings) {
      // Create default settings
      settings = await prisma.notificationSettings.create({
        data: {
          userId,
          emailNotifications: true,
          pushNotifications: true,
          smsNotifications: false,
        },
      });
    }

    res.json(settings);
  } catch (error) {
    logger.error('Error fetching notification settings:', error);
    res.status(500).json({
      error: 'Internal server error',
      message: 'Failed to fetch notification settings',
    });
  }
};

export const updateNotificationSettings = async (req, res) => {
  try {
    const userId = req.user.userId;
    const { emailNotifications, pushNotifications, smsNotifications } = req.body;

    const settings = await prisma.notificationSettings.upsert({
      where: { userId },
      update: {
        emailNotifications,
        pushNotifications,
        smsNotifications,
      },
      create: {
        userId,
        emailNotifications: emailNotifications ?? true,
        pushNotifications: pushNotifications ?? true,
        smsNotifications: smsNotifications ?? false,
      },
    });

    res.json({
      message: 'Notification settings updated successfully',
      settings,
    });
  } catch (error) {
    logger.error('Error updating notification settings:', error);
    res.status(500).json({
      error: 'Internal server error',
      message: 'Failed to update notification settings',
    });
  }
};

================
File: src/modules/notifications/routes/notificationRoutes.js
================
import express from 'express';
import { authenticate, authorize } from '../../../middleware/auth.js';
import {
  getNotifications,
  markAsRead,
  markAllAsRead,
  deleteNotification,
  sendBulkNotification,
  getNotificationSettings,
  updateNotificationSettings,
} from '../controllers/notificationController.js';

const router = express.Router();

/**
 * @swagger
 * /notifications:
 *   get:
 *     summary: Get user notifications
 *     tags: [Notifications]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: query
 *         name: page
 *         schema:
 *           type: integer
 *           default: 1
 *       - in: query
 *         name: limit
 *         schema:
 *           type: integer
 *           default: 20
 *       - in: query
 *         name: unreadOnly
 *         schema:
 *           type: boolean
 *           default: false
 *     responses:
 *       200:
 *         description: List of notifications
 */
router.get('/', authenticate, getNotifications);

/**
 * @swagger
 * /notifications/bulk:
 *   post:
 *     summary: Send bulk notification
 *     tags: [Notifications]
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - title
 *               - message
 *               - recipients
 *             properties:
 *               title:
 *                 type: string
 *               message:
 *                 type: string
 *               recipients:
 *                 type: array
 *                 items:
 *                   type: string
 *               type:
 *                 type: string
 *                 enum: [EMAIL, PUSH, IN_APP]
 *     responses:
 *       200:
 *         description: Bulk notification sent successfully
 */
router.post('/bulk', authenticate, authorize(['SUPER_ADMIN', 'OWNER', 'MANAGER']), sendBulkNotification);

/**
 * @swagger
 * /notifications/settings:
 *   get:
 *     summary: Get notification settings
 *     tags: [Notifications]
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: User notification settings
 */
router.get('/settings', authenticate, getNotificationSettings);

/**
 * @swagger
 * /notifications/settings:
 *   put:
 *     summary: Update notification settings
 *     tags: [Notifications]
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               emailNotifications:
 *                 type: boolean
 *               pushNotifications:
 *                 type: boolean
 *               smsNotifications:
 *                 type: boolean
 *     responses:
 *       200:
 *         description: Settings updated successfully
 */
router.put('/settings', authenticate, updateNotificationSettings);

/**
 * @swagger
 * /notifications/mark-all-read:
 *   post:
 *     summary: Mark all notifications as read
 *     tags: [Notifications]
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: All notifications marked as read
 */
router.post('/mark-all-read', authenticate, markAllAsRead);

/**
 * @swagger
 * /notifications/{id}/read:
 *   patch:
 *     summary: Mark notification as read
 *     tags: [Notifications]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Notification marked as read
 */
router.patch('/:id/read', authenticate, markAsRead);

/**
 * @swagger
 * /notifications/{id}:
 *   delete:
 *     summary: Delete notification
 *     tags: [Notifications]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Notification deleted successfully
 */
router.delete('/:id', authenticate, deleteNotification);

export default router;

================
File: src/modules/notifications/services/emailService.js
================
import nodemailer from 'nodemailer';
import logger from '../../../config/logger.js';

// Create transporter
const createTransporter = () => {
  return nodemailer.createTransporter({
    host: process.env.SMTP_HOST,
    port: process.env.SMTP_PORT,
    secure: process.env.SMTP_PORT == 465,
    auth: {
      user: process.env.SMTP_USER,
      pass: process.env.SMTP_PASS,
    },
  });
};

export const sendEmail = async (to, subject, html, attachments = []) => {
  try {
    const transporter = createTransporter();
    
    const mailOptions = {
      from: `"Rental Management System" <${process.env.SMTP_USER}>`,
      to,
      subject,
      html,
      attachments,
    };

    const info = await transporter.sendMail(mailOptions);
    logger.info(`Email sent to ${to}: ${info.messageId}`);
    return info;
  } catch (error) {
    logger.error('Error sending email:', error);
    throw error;
  }
};

export const sendWelcomeEmail = async (email, role, password = null) => {
  const subject = 'Welcome to Rental Management System';
  
  let html = `
    <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
      <h2 style="color: #333;">Welcome to Rental Management System!</h2>
      <p>Your account has been created successfully.</p>
      <div style="background-color: #f5f5f5; padding: 20px; border-radius: 5px; margin: 20px 0;">
        <h3>Account Details:</h3>
        <p><strong>Email:</strong> ${email}</p>
        <p><strong>Role:</strong> ${role}</p>
        ${password ? `<p><strong>Temporary Password:</strong> ${password}</p>` : ''}
      </div>
      ${password ? '<p><strong>Important:</strong> Please change your password after your first login for security purposes.</p>' : ''}
      <p>Thank you for joining our platform!</p>
      <hr style="margin: 30px 0;">
      <p style="font-size: 12px; color: #666;">
        This is an automated email. Please do not reply to this message.
      </p>
    </div>
  `;

  return sendEmail(email, subject, html);
};

export const sendPaymentReminderEmail = async (email, tenantName, amount, dueDate) => {
  const subject = 'Payment Reminder - Rental Management System';
  
  const html = `
    <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
      <h2 style="color: #e74c3c;">Payment Reminder</h2>
      <p>Dear ${tenantName},</p>
      <p>This is a friendly reminder that your rent payment is due.</p>
      <div style="background-color: #f8f9fa; padding: 20px; border-radius: 5px; margin: 20px 0;">
        <h3>Payment Details:</h3>
        <p><strong>Amount Due:</strong> $${amount}</p>
        <p><strong>Due Date:</strong> ${new Date(dueDate).toLocaleDateString()}</p>
      </div>
      <p>Please ensure your payment is made on time to avoid any late fees.</p>
      <p>If you have any questions, please contact your property manager.</p>
      <hr style="margin: 30px 0;">
      <p style="font-size: 12px; color: #666;">
        This is an automated email. Please do not reply to this message.
      </p>
    </div>
  `;

  return sendEmail(email, subject, html);
};

export const sendPaymentConfirmationEmail = async (email, tenantName, amount, receiptUrl) => {
  const subject = 'Payment Confirmation - Rental Management System';
  
  const html = `
    <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
      <h2 style="color: #27ae60;">Payment Confirmed</h2>
      <p>Dear ${tenantName},</p>
      <p>We have successfully received your payment. Thank you!</p>
      <div style="background-color: #d4edda; padding: 20px; border-radius: 5px; margin: 20px 0;">
        <h3>Payment Details:</h3>
        <p><strong>Amount Paid:</strong> $${amount}</p>
        <p><strong>Date:</strong> ${new Date().toLocaleDateString()}</p>
      </div>
      ${receiptUrl ? `<p><a href="${receiptUrl}" style="background-color: #007bff; color: white; padding: 10px 20px; text-decoration: none; border-radius: 5px;">Download Receipt</a></p>` : ''}
      <p>Thank you for your timely payment!</p>
      <hr style="margin: 30px 0;">
      <p style="font-size: 12px; color: #666;">
        This is an automated email. Please do not reply to this message.
      </p>
    </div>
  `;

  return sendEmail(email, subject, html);
};

export const sendLeaseExpiryEmail = async (email, tenantName, propertyName, expiryDate) => {
  const subject = 'Lease Expiry Notice - Rental Management System';
  
  const html = `
    <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
      <h2 style="color: #f39c12;">Lease Expiry Notice</h2>
      <p>Dear ${tenantName},</p>
      <p>This is to inform you that your lease is approaching its expiry date.</p>
      <div style="background-color: #fff3cd; padding: 20px; border-radius: 5px; margin: 20px 0;">
        <h3>Lease Details:</h3>
        <p><strong>Property:</strong> ${propertyName}</p>
        <p><strong>Expiry Date:</strong> ${new Date(expiryDate).toLocaleDateString()}</p>
      </div>
      <p>Please contact your property manager to discuss lease renewal or move-out procedures.</p>
      <hr style="margin: 30px 0;">
      <p style="font-size: 12px; color: #666;">
        This is an automated email. Please do not reply to this message.
      </p>
    </div>
  `;

  return sendEmail(email, subject, html);
};

export const sendOwnerAlertEmail = async (email, ownerName, subject, message) => {
  const emailSubject = `Alert: ${subject}`;
  
  const html = `
    <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
      <h2 style="color: #dc3545;">Property Alert</h2>
      <p>Dear ${ownerName},</p>
      <div style="background-color: #f8d7da; padding: 20px; border-radius: 5px; margin: 20px 0;">
        <h3>${subject}</h3>
        <p>${message}</p>
      </div>
      <p>Please review this alert and take appropriate action if necessary.</p>
      <hr style="margin: 30px 0;">
      <p style="font-size: 12px; color: #666;">
        This is an automated email from the Rental Management System.
      </p>
    </div>
  `;

  return sendEmail(email, emailSubject, html);
};

================
File: src/modules/notifications/services/firebaseService.js
================
import admin from 'firebase-admin';
import logger from '../../../config/logger.js';

// Initialize Firebase Admin SDK
let firebaseApp;

try {
  if (!admin.apps.length) {
    firebaseApp = admin.initializeApp({
      credential: admin.credential.cert({
        projectId: process.env.FIREBASE_PROJECT_ID,
        privateKey: process.env.FIREBASE_PRIVATE_KEY?.replace(/\\n/g, '\n'),
        clientEmail: process.env.FIREBASE_CLIENT_EMAIL,
      }),
    });
  } else {
    firebaseApp = admin.app();
  }
} catch (error) {
  logger.error('Failed to initialize Firebase:', error);
}

export const sendPushNotification = async (token, title, body, data = {}) => {
  try {
    if (!firebaseApp) {
      logger.warn('Firebase not initialized, skipping push notification');
      return null;
    }

    const message = {
      notification: {
        title,
        body,
      },
      data: {
        ...data,
        timestamp: new Date().toISOString(),
      },
      token,
    };

    const response = await admin.messaging().send(message);
    logger.info(`Push notification sent successfully: ${response}`);
    return response;
  } catch (error) {
    logger.error('Error sending push notification:', error);
    throw error;
  }
};

export const sendMultiplePushNotifications = async (tokens, title, body, data = {}) => {
  try {
    if (!firebaseApp) {
      logger.warn('Firebase not initialized, skipping push notifications');
      return null;
    }

    const message = {
      notification: {
        title,
        body,
      },
      data: {
        ...data,
        timestamp: new Date().toISOString(),
      },
      tokens,
    };

    const response = await admin.messaging().sendMulticast(message);
    logger.info(`Batch push notifications sent: ${response.successCount} successful, ${response.failureCount} failed`);
    
    if (response.failureCount > 0) {
      const failedTokens = [];
      response.responses.forEach((resp, idx) => {
        if (!resp.success) {
          failedTokens.push(tokens[idx]);
          logger.error(`Failed to send to token ${tokens[idx]}:`, resp.error);
        }
      });
    }

    return response;
  } catch (error) {
    logger.error('Error sending batch push notifications:', error);
    throw error;
  }
};

export const subscribeToTopic = async (tokens, topic) => {
  try {
    if (!firebaseApp) {
      logger.warn('Firebase not initialized, skipping topic subscription');
      return null;
    }

    const response = await admin.messaging().subscribeToTopic(tokens, topic);
    logger.info(`Subscribed ${response.successCount} tokens to topic ${topic}`);
    return response;
  } catch (error) {
    logger.error('Error subscribing to topic:', error);
    throw error;
  }
};

export const unsubscribeFromTopic = async (tokens, topic) => {
  try {
    if (!firebaseApp) {
      logger.warn('Firebase not initialized, skipping topic unsubscription');
      return null;
    }

    const response = await admin.messaging().unsubscribeFromTopic(tokens, topic);
    logger.info(`Unsubscribed ${response.successCount} tokens from topic ${topic}`);
    return response;
  } catch (error) {
    logger.error('Error unsubscribing from topic:', error);
    throw error;
  }
};

export const sendTopicNotification = async (topic, title, body, data = {}) => {
  try {
    if (!firebaseApp) {
      logger.warn('Firebase not initialized, skipping topic notification');
      return null;
    }

    const message = {
      notification: {
        title,
        body,
      },
      data: {
        ...data,
        timestamp: new Date().toISOString(),
      },
      topic,
    };

    const response = await admin.messaging().send(message);
    logger.info(`Topic notification sent to ${topic}: ${response}`);
    return response;
  } catch (error) {
    logger.error('Error sending topic notification:', error);
    throw error;
  }
};

================
File: src/modules/notifications/services/socketService.js
================
import logger from '../../../config/logger.js';
import { verifyToken } from '../../../utils/helpers.js';
import prisma from '../../../config/database.js';

let io;

export const initializeSocket = (socketIo) => {
  io = socketIo;

  // Authentication middleware for socket connections
  io.use(async (socket, next) => {
    try {
      const token = socket.handshake.auth.token;
      if (!token) {
        return next(new Error('Authentication error'));
      }

      const decoded = verifyToken(token);
      const user = await prisma.user.findUnique({
        where: { id: decoded.userId },
        include: {
          tenant: true,
          owner: true,
          manager: true,
        },
      });

      if (!user || !user.isActive) {
        return next(new Error('Authentication error'));
      }

      socket.userId = user.id;
      socket.userRole = user.role;
      socket.user = user;
      next();
    } catch (error) {
      logger.error('Socket authentication error:', error);
      next(new Error('Authentication error'));
    }
  });

  io.on('connection', (socket) => {
    logger.info(`User connected: ${socket.userId} (${socket.userRole})`);

    // Join user to their personal room
    socket.join(`user_${socket.userId}`);

    // Join role-based rooms
    socket.join(`role_${socket.userRole.toLowerCase()}`);

    // If tenant, join property room
    if (socket.user.tenant) {
      socket.join(`property_${socket.user.tenant.propertyId}`);
    }

    // If owner, join all owned properties
    if (socket.user.owner) {
      prisma.property.findMany({
        where: { ownerId: socket.user.owner.id },
        select: { id: true },
      }).then(properties => {
        properties.forEach(property => {
          socket.join(`property_${property.id}`);
        });
      });
    }

    // Handle joining chat rooms
    socket.on('join_chat', async (data) => {
      const { participantId } = data;
      
      try {
        // Verify user can chat with this participant
        const canChat = await verifychatPermission(socket.userId, participantId);
        if (canChat) {
          const roomId = getChatRoomId(socket.userId, participantId);
          socket.join(roomId);
          logger.info(`User ${socket.userId} joined chat room: ${roomId}`);
        }
      } catch (error) {
        logger.error('Error joining chat:', error);
        socket.emit('error', { message: 'Failed to join chat' });
      }
    });

    // Handle sending messages
    socket.on('send_message', async (data) => {
      try {
        await handleSendMessage(socket, data);
      } catch (error) {
        logger.error('Error sending message:', error);
        socket.emit('error', { message: 'Failed to send message' });
      }
    });

    // Handle message read status
    socket.on('mark_read', async (data) => {
      try {
        await handleMarkRead(socket.userId, data.messageId);
        socket.emit('message_read', { messageId: data.messageId });
      } catch (error) {
        logger.error('Error marking message as read:', error);
      }
    });

    // Handle disconnect
    socket.on('disconnect', () => {
      logger.info(`User disconnected: ${socket.userId}`);
    });
  });

  logger.info('Socket.IO initialized successfully');
};

const verifyChatPermission = async (userId1, userId2) => {
  const user1 = await prisma.user.findUnique({
    where: { id: userId1 },
    include: { tenant: true, owner: true, manager: true },
  });

  const user2 = await prisma.user.findUnique({
    where: { id: userId2 },
    include: { tenant: true, owner: true, manager: true },
  });

  if (!user1 || !user2) return false;

  // Super admin can chat with anyone
  if (user1.role === 'SUPER_ADMIN' || user2.role === 'SUPER_ADMIN') {
    return true;
  }

  // Tenant can chat with their property owner/manager
  if (user1.role === 'TENANT' && user1.tenant) {
    const property = await prisma.property.findUnique({
      where: { id: user1.tenant.propertyId },
      include: { owner: true },
    });

    if (property && property.owner.userId === userId2) {
      return true;
    }

    // Check if user2 is a manager of the property owner
    if (user2.role === 'MANAGER' && user2.manager) {
      return property && property.ownerId === user2.manager.ownerId;
    }
  }

  // Owner can chat with their tenants
  if (user1.role === 'OWNER' && user1.owner) {
    if (user2.role === 'TENANT' && user2.tenant) {
      const property = await prisma.property.findUnique({
        where: { id: user2.tenant.propertyId },
      });
      return property && property.ownerId === user1.owner.id;
    }
  }

  return false;
};

const getChatRoomId = (userId1, userId2) => {
  const sortedIds = [userId1, userId2].sort();
  return `chat_${sortedIds[0]}_${sortedIds[1]}`;
};

const handleSendMessage = async (socket, data) => {
  const { receiverId, content, type = 'TEXT' } = data;

  // Verify permission
  const canChat = await verifychatPermission(socket.userId, receiverId);
  if (!canChat) {
    socket.emit('error', { message: 'You are not authorized to send messages to this user' });
    return;
  }

  // Save message to database
  const message = await prisma.message.create({
    data: {
      senderId: socket.userId,
      receiverId,
      content,
      type,
    },
    include: {
      sender: {
        select: {
          id: true,
          email: true,
          role: true,
        },
      },
    },
  });

  // Send to chat room
  const roomId = getChatRoomId(socket.userId, receiverId);
  io.to(roomId).emit('new_message', {
    id: message.id,
    content: message.content,
    type: message.type,
    createdAt: message.createdAt,
    sender: message.sender,
    isRead: false,
  });

  // Send notification to receiver if not online
  const receiverSockets = await io.in(`user_${receiverId}`).fetchSockets();
  if (receiverSockets.length === 0) {
    // User is offline, send push notification
    await sendPushNotification(receiverId, {
      title: 'New Message',
      body: `You have a new message from ${message.sender.email}`,
      data: {
        type: 'message',
        senderId: socket.userId,
        messageId: message.id,
      },
    });
  }

  logger.info(`Message sent from ${socket.userId} to ${receiverId}`);
};

const handleMarkRead = async (userId, messageId) => {
  await prisma.message.update({
    where: { 
      id: messageId,
      receiverId: userId,
    },
    data: { isRead: true },
  });
};

export const sendNotificationToUser = (userId, notification) => {
  if (io) {
    io.to(`user_${userId}`).emit('notification', notification);
  }
};

export const sendNotificationToRole = (role, notification) => {
  if (io) {
    io.to(`role_${role.toLowerCase()}`).emit('notification', notification);
  }
};

export const sendNotificationToProperty = (propertyId, notification) => {
  if (io) {
    io.to(`property_${propertyId}`).emit('notification', notification);
  }
};

export const sendPushNotification = async (userId, notificationData) => {
  try {
    // Save notification to database
    await prisma.notification.create({
      data: {
        recipientId: userId,
        title: notificationData.title,
        message: notificationData.body,
        type: 'PUSH',
        metadata: notificationData.data || {},
      },
    });

    // Send real-time notification
    sendNotificationToUser(userId, notificationData);

    logger.info(`Push notification sent to user: ${userId}`);
  } catch (error) {
    logger.error('Error sending push notification:', error);
    throw error;
  }
};

================
File: src/modules/owners/controllers/ownerController.js
================
import prisma from '../../../config/database.js';
import logger from '../../../config/logger.js';
import { hashPassword } from '../../../utils/helpers.js';

export const createOwner = async (req, res) => {
  try {
    const { email, password, firstName, lastName, companyName, phone, address } = req.body;

    // Check if user already exists
    const existingUser = await prisma.user.findUnique({
      where: { email },
    });

    if (existingUser) {
      return res.status(400).json({
        error: 'User already exists',
        message: 'A user with this email already exists',
      });
    }

    const hashedPassword = await hashPassword(password);

    const owner = await prisma.user.create({
      data: {
        email,
        password: hashedPassword,
        role: 'OWNER',
        firstName,
        lastName,
        owner: {
          create: {
            companyName,
            phone,
            address,
          },
        },
      },
      include: {
        owner: true,
      },
    });

    // Remove password from response
    const { password: _, ...ownerResponse } = owner;

    logger.info(`Owner created: ${companyName} by ${req.user.email}`);

    res.status(201).json({
      message: 'Owner created successfully',
      owner: ownerResponse,
    });
  } catch (error) {
    logger.error('Error creating owner:', error);
    res.status(500).json({
      error: 'Internal server error',
      message: 'Failed to create owner',
    });
  }
};

export const getOwners = async (req, res) => {
  try {
    const { page = 1, limit = 10, search } = req.query;
    const skip = (parseInt(page) - 1) * parseInt(limit);

    const where = search
      ? {
          OR: [
            { email: { contains: search, mode: 'insensitive' } },
            { owner: { companyName: { contains: search, mode: 'insensitive' } } },
          ],
        }
      : {};

    const [owners, total] = await Promise.all([
      prisma.user.findMany({
        where: {
          role: 'OWNER',
          ...where,
        },
        skip,
        take: parseInt(limit),
        include: {
          owner: {
            include: {
              _count: {
                select: {
                  properties: true,
                  managers: true,
                },
              },
            },
          },
        },
        orderBy: { createdAt: 'desc' },
      }),
      prisma.user.count({
        where: {
          role: 'OWNER',
          ...where,
        },
      }),
    ]);

    // Remove passwords from response
    const ownersResponse = owners.map(owner => {
      const { password, ...ownerData } = owner;
      return ownerData;
    });

    res.json({
      owners: ownersResponse,
      pagination: {
        total,
        page: parseInt(page),
        limit: parseInt(limit),
        pages: Math.ceil(total / parseInt(limit)),
      },
    });
  } catch (error) {
    logger.error('Error fetching owners:', error);
    res.status(500).json({
      error: 'Internal server error',
      message: 'Failed to fetch owners',
    });
  }
};

export const getOwnerById = async (req, res) => {
  try {
    const { id } = req.params;

    // Check permissions
    if (req.user.role === 'OWNER' && req.user.owner.id !== id) {
      return res.status(403).json({
        error: 'Forbidden',
        message: 'You can only access your own information',
      });
    }

    const owner = await prisma.user.findFirst({
      where: {
        role: 'OWNER',
        owner: { id },
      },
      include: {
        owner: {
          include: {
            properties: {
              select: {
                id: true,
                name: true,
                address: true,
                type: true,
                status: true,
              },
            },
            managers: {
              select: {
                id: true,
                firstName: true,
                lastName: true,
                user: {
                  select: {
                    email: true,
                  },
                },
              },
            },
          },
        },
      },
    });

    if (!owner) {
      return res.status(404).json({
        error: 'Owner not found',
        message: 'Owner with this ID does not exist',
      });
    }

    // Remove password from response
    const { password, ...ownerResponse } = owner;

    res.json(ownerResponse);
  } catch (error) {
    logger.error('Error fetching owner:', error);
    res.status(500).json({
      error: 'Internal server error',
      message: 'Failed to fetch owner',
    });
  }
};

export const updateOwner = async (req, res) => {
  try {
    const { id } = req.params;
    const { companyName, phone, address } = req.body;

    // Check permissions
    if (req.user.role === 'OWNER' && req.user.owner.id !== id) {
      return res.status(403).json({
        error: 'Forbidden',
        message: 'You can only update your own information',
      });
    }

    const existingOwner = await prisma.owner.findUnique({
      where: { id },
    });

    if (!existingOwner) {
      return res.status(404).json({
        error: 'Owner not found',
        message: 'Owner with this ID does not exist',
      });
    }

    const updatedOwner = await prisma.owner.update({
      where: { id },
      data: {
        companyName,
        phone,
        address,
      },
      include: {
        user: {
          select: {
            id: true,
            email: true,
            role: true,
          },
        },
      },
    });

    logger.info(`Owner updated: ${updatedOwner.companyName} by ${req.user.email}`);

    res.json({
      message: 'Owner updated successfully',
      owner: updatedOwner,
    });
  } catch (error) {
    logger.error('Error updating owner:', error);
    res.status(500).json({
      error: 'Internal server error',
      message: 'Failed to update owner',
    });
  }
};

export const deleteOwner = async (req, res) => {
  try {
    const { id } = req.params;

    const owner = await prisma.owner.findUnique({
      where: { id },
      include: {
        properties: true,
        managers: true,
      },
    });

    if (!owner) {
      return res.status(404).json({
        error: 'Owner not found',
        message: 'Owner with this ID does not exist',
      });
    }

    // Check if owner has properties or managers
    if (owner.properties.length > 0 || owner.managers.length > 0) {
      return res.status(400).json({
        error: 'Cannot delete owner',
        message: 'Owner has associated properties or managers. Please transfer or delete them first.',
      });
    }

    await prisma.user.delete({
      where: { id: owner.userId },
    });

    logger.info(`Owner deleted: ${owner.companyName} by ${req.user.email}`);

    res.json({
      message: 'Owner deleted successfully',
    });
  } catch (error) {
    logger.error('Error deleting owner:', error);
    res.status(500).json({
      error: 'Internal server error',
      message: 'Failed to delete owner',
    });
  }
};

export const getOwnerProperties = async (req, res) => {
  try {
    const { id } = req.params;
    const { page = 1, limit = 10 } = req.query;
    const skip = (parseInt(page) - 1) * parseInt(limit);

    // Check permissions
    if (req.user.role === 'OWNER' && req.user.owner.id !== id) {
      return res.status(403).json({
        error: 'Forbidden',
        message: 'You can only access your own properties',
      });
    }

    const [properties, total] = await Promise.all([
      prisma.property.findMany({
        where: { ownerId: id },
        skip,
        take: parseInt(limit),
        include: {
          tenants: {
            where: { isActive: true },
            select: {
              id: true,
              firstName: true,
              lastName: true,
            },
          },
          _count: {
            select: {
              tenants: { where: { isActive: true } },
              leases: { where: { status: 'ACTIVE' } },
            },
          },
        },
        orderBy: { createdAt: 'desc' },
      }),
      prisma.property.count({
        where: { ownerId: id },
      }),
    ]);

    res.json({
      properties,
      pagination: {
        total,
        page: parseInt(page),
        limit: parseInt(limit),
        pages: Math.ceil(total / parseInt(limit)),
      },
    });
  } catch (error) {
    logger.error('Error fetching owner properties:', error);
    res.status(500).json({
      error: 'Internal server error',
      message: 'Failed to fetch owner properties',
    });
  }
};

export const getOwnerAnalytics = async (req, res) => {
  try {
    const { id } = req.params;

    // Check permissions
    if (req.user.role === 'OWNER' && req.user.owner.id !== id) {
      return res.status(403).json({
        error: 'Forbidden',
        message: 'You can only access your own analytics',
      });
    }

    const analytics = await prisma.owner.findUnique({
      where: { id },
      include: {
        _count: {
          select: {
            properties: true,
            managers: true,
          },
        },
        properties: {
          include: {
            _count: {
              select: {
                tenants: { where: { isActive: true } },
                leases: { where: { status: 'ACTIVE' } },
              },
            },
          },
        },
      },
    });

    if (!analytics) {
      return res.status(404).json({
        error: 'Owner not found',
        message: 'Owner with this ID does not exist',
      });
    }

    // Calculate analytics
    const totalTenants = analytics.properties.reduce((sum, property) => sum + property._count.tenants, 0);
    const totalLeases = analytics.properties.reduce((sum, property) => sum + property._count.leases, 0);
    const occupancyRate = analytics.properties.length > 0 
      ? ((totalLeases / analytics.properties.length) * 100).toFixed(2)
      : 0;

    res.json({
      totalProperties: analytics._count.properties,
      totalManagers: analytics._count.managers,
      totalTenants,
      totalActiveLeases: totalLeases,
      occupancyRate: parseFloat(occupancyRate),
    });
  } catch (error) {
    logger.error('Error fetching owner analytics:', error);
    res.status(500).json({
      error: 'Internal server error',
      message: 'Failed to fetch owner analytics',
    });
  }
};

================
File: src/modules/owners/routes/ownerRoutes.js
================
import express from 'express';
import { authenticate, authorize } from '../../../middleware/auth.js';
import {
  createOwner,
  getOwners,
  getOwnerById,
  updateOwner,
  deleteOwner,
  getOwnerProperties,
  getOwnerAnalytics,
} from '../controllers/ownerController.js';

const router = express.Router();

/**
 * @swagger
 * /owners:
 *   post:
 *     summary: Create a new owner
 *     tags: [Owners]
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - email
 *               - password
 *               - companyName
 *               - phone
 *             properties:
 *               email:
 *                 type: string
 *               password:
 *                 type: string
 *               companyName:
 *                 type: string
 *               phone:
 *                 type: string
 *               address:
 *                 type: string
 *     responses:
 *       201:
 *         description: Owner created successfully
 */
router.post('/', authenticate,  createOwner);

/**
 * @swagger
 * /owners:
 *   get:
 *     summary: Get all owners
 *     tags: [Owners]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: query
 *         name: page
 *         schema:
 *           type: integer
 *           default: 1
 *       - in: query
 *         name: limit
 *         schema:
 *           type: integer
 *           default: 10
 *     responses:
 *       200:
 *         description: List of owners
 */
router.get('/', authenticate, authorize(['SUPER_ADMIN']), getOwners);

/**
 * @swagger
 * /owners/{id}:
 *   get:
 *     summary: Get owner by ID
 *     tags: [Owners]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Owner details
 */
router.get('/:id', authenticate, getOwnerById);

/**
 * @swagger
 * /owners/{id}:
 *   put:
 *     summary: Update owner
 *     tags: [Owners]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Owner updated successfully
 */
router.put('/:id', authenticate, updateOwner);

/**
 * @swagger
 * /owners/{id}:
 *   delete:
 *     summary: Delete owner
 *     tags: [Owners]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Owner deleted successfully
 */
router.delete('/:id', authenticate, authorize(['SUPER_ADMIN']), deleteOwner);

/**
 * @swagger
 * /owners/{id}/properties:
 *   get:
 *     summary: Get owner properties
 *     tags: [Owners]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: List of owner properties
 */
router.get('/:id/properties', authenticate, getOwnerProperties);

/**
 * @swagger
 * /owners/{id}/analytics:
 *   get:
 *     summary: Get owner analytics
 *     tags: [Owners]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Owner analytics data
 */
router.get('/:id/analytics', authenticate, getOwnerAnalytics);

export default router;

================
File: src/modules/payments/controllers/paymentController.js
================
import { asyncHandler } from '../../../middleware/errorHandler.js';
import prisma from '../../../config/database.js';
import logger from '../../../config/logger.js';
import { generatePaymentReceipt as generatePdf } from '../../../utils/pdfGenerator.js';
import { sendPaymentConfirmationEmail, sendPaymentReminderEmail } from '../../notifications/services/emailService.js';
import { uploadToCloudinary } from '../../../utils/cloudinary.js';
import { successResponse, errorResponse } from '../../../utils/responseHelpers.js';

export const getPayments = asyncHandler(async (req, res) => {
  const { page = 1, limit = 10, status, tenantId, propertyId, startDate, endDate } = req.query;
  const skip = (parseInt(page) - 1) * parseInt(limit);

  const where = {};

  if (req.user.role === 'TENANT') {
    where.tenantId = req.user.tenant.id;
  } else if (req.user.role === 'OWNER') {
    where.lease = {
      property: { ownerId: req.user.owner.id },
    };
  } else if (req.user.role === 'MANAGER') {
    where.lease = {
      property: { ownerId: req.user.manager.ownerId },
    };
  }

  if (status) where.status = status;
  if (tenantId) where.tenantId = tenantId;
  if (propertyId) {
    where.lease = { ...where.lease, propertyId };
  }

  if (startDate || endDate) {
    where.dueDate = {};
    if (startDate) where.dueDate.gte = new Date(startDate);
    if (endDate) where.dueDate.lte = new Date(endDate);
  }

  const [payments, total] = await Promise.all([
    prisma.payment.findMany({
      where,
      skip,
      take: parseInt(limit),
      include: {
        tenant: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            user: {
              select: {
                email: true,
              },
            },
          },
        },
        lease: {
          select: {
            id: true,
            property: {
              select: {
                id: true,
                name: true,
                address: true,
              },
            },
          },
        },
        receipts: {
          select: {
            id: true,
            pdfUrl: true,
            generatedAt: true,
          },
        },
      },
      orderBy: { dueDate: 'desc' },
    }),
    prisma.payment.count({ where }),
  ]);

  return successResponse(res, {
    payments,
    pagination: {
      total,
      page: parseInt(page),
      limit: parseInt(limit),
      pages: Math.ceil(total / parseInt(limit)),
    },
  });
});

export const getPaymentById = asyncHandler(async (req, res) => {
  const { id } = req.params;

  const payment = await prisma.payment.findUnique({
    where: { id },
    include: {
      tenant: {
        include: {
          user: {
            select: {
              email: true,
            },
          },
        },
      },
      lease: {
        include: {
          property: {
            include: {
              owner: {
                select: {
                  companyName: true,
                  user: {
                    select: {
                      email: true,
                    },
                  },
                },
              },
            },
          },
        },
      },
      receipts: true,
    },
  });

  if (!payment) {
    return errorResponse(res, 'Payment not found', 404);
  }

  if (req.user.role === 'TENANT' && payment.tenantId !== req.user.tenant.id) {
    return errorResponse(res, 'You can only access your own payments', 403);
  }

  if (req.user.role === 'OWNER' && payment.lease.property.ownerId !== req.user.owner.id) {
    return errorResponse(res, 'You can only access payments for your properties', 403);
  }

  if (req.user.role === 'MANAGER' && payment.lease.property.ownerId !== req.user.manager.ownerId) {
    return errorResponse(res, 'You can only access payments for properties you manage', 403);
  }

  return successResponse(res, { payment });
});

export const createPayment = asyncHandler(async (req, res) => {
  const { tenantId, leaseId, amount, dueDate, notes } = req.body;

  const lease = await prisma.lease.findUnique({
    where: { id: leaseId },
    include: {
      tenant: true,
      property: true,
    },
  });

  if (!lease) {
    return errorResponse(res, 'Lease not found', 404);
  }

  if (lease.tenantId !== tenantId) {
    return errorResponse(res, 'Tenant is not associated with this lease', 400);
  }

  const allowedOwnerId = req.user.role === 'OWNER' ? req.user.owner.id : req.user.manager.ownerId;
  if (lease.property.ownerId !== allowedOwnerId) {
    return errorResponse(res, 'You can only create payments for your properties', 403);
  }

  const payment = await prisma.payment.create({
    data: {
      tenantId,
      leaseId,
      amount: parseFloat(amount),
      dueDate: new Date(dueDate),
      notes,
    },
  });

  return successResponse(res, payment, 'Payment created successfully', 201);
});

export const updatePayment = asyncHandler(async (req, res) => {
    const { id } = req.params;
    const { amount, dueDate, notes } = req.body;

    const payment = await prisma.payment.findUnique({
        where: { id },
        include: { lease: { select: { property: { select: { ownerId: true } } } } }
    });

    if (!payment) {
        return errorResponse(res, 'Payment not found', 404);
    }
    
    const allowedOwnerId = req.user.role === 'OWNER' ? req.user.owner.id : req.user.manager?.ownerId;
    if (payment.lease.property.ownerId !== allowedOwnerId) {
        return errorResponse(res, 'You are not authorized to update this payment', 403);
    }

    if (payment.status !== 'PENDING') {
        return errorResponse(res, `Cannot update payment with status '${payment.status}'`, 400);
    }

    const updatedPayment = await prisma.payment.update({
        where: { id },
        data: {
            amount: amount ? parseFloat(amount) : undefined,
            dueDate: dueDate ? new Date(dueDate) : undefined,
            notes,
        },
    });

    return successResponse(res, updatedPayment, 'Payment updated successfully');
});

export const deletePayment = asyncHandler(async (req, res) => {
    const { id } = req.params;
    
    const payment = await prisma.payment.findUnique({
        where: { id },
        include: { lease: { select: { property: { select: { ownerId: true } } } } }
    });

    if (!payment) {
        return errorResponse(res, 'Payment not found', 404);
    }

    const allowedOwnerId = req.user.role === 'OWNER' ? req.user.owner.id : req.user.manager?.ownerId;
    if (payment.lease.property.ownerId !== allowedOwnerId) {
        return errorResponse(res, 'You are not authorized to delete this payment', 403);
    }

    if (payment.status === 'PAID') {
        return errorResponse(res, 'Cannot delete a completed payment', 400);
    }

    await prisma.payment.delete({ where: { id } });

    return successResponse(res, null, 'Payment deleted successfully');
});

export const processOnlinePayment = asyncHandler(async (req, res) => {
    const { id } = req.params;
    const { paymentMethodToken } = req.body; 

    if (!paymentMethodToken) {
        return errorResponse(res, 'Payment method token is required.', 400);
    }
    
    const payment = await prisma.payment.findUnique({
        where: { id },
        include: { tenant: { include: { user: true } }, lease: { include: { property: { include: { owner: true } } } } }
    });

    if (!payment) {
        return errorResponse(res, 'Payment not found', 404);
    }
    if (payment.tenant.userId !== req.user.id) {
         return errorResponse(res, 'You can only pay for your own bills.', 403);
    }
    if (payment.status === 'PAID') {
        return errorResponse(res, 'This payment has already been paid.', 400);
    }

    const transactionId = `txn_${new Date().getTime()}`;
    logger.info(`Simulating payment for payment ID ${id} with token ${paymentMethodToken}`);
    
    const updatedPayment = await prisma.payment.update({
        where: { id },
        data: {
            status: 'PAID',
            method: 'ONLINE',
            paidDate: new Date(),
            transactionId,
        },
    });

    try {
        const receiptBuffer = await generatePdf({
            payment: updatedPayment,
            tenant: payment.tenant,
            property: payment.lease.property,
            owner: payment.lease.property.owner
        });
        const uploadResult = await uploadToCloudinary(receiptBuffer, 'receipts', { resource_type: 'raw', format: 'pdf' });
        await prisma.receipt.create({
            data: {
                paymentId: updatedPayment.id,
                pdfUrl: uploadResult.secure_url,
                amount: updatedPayment.amount,
            },
        });
        await sendPaymentConfirmationEmail(payment.tenant.user.email, `${payment.tenant.firstName} ${payment.tenant.lastName}`, updatedPayment.amount, uploadResult.secure_url);
    } catch (error) {
        logger.error(`Failed to generate receipt for payment ${id}:`, error);
    }

    return successResponse(res, updatedPayment, 'Payment processed successfully.');
});

export const downloadPaymentReceipt = asyncHandler(async (req, res) => {
    const { id } = req.params;

    const payment = await prisma.payment.findUnique({
        where: { id },
        include: { tenant: { include: { user: true } }, lease: { include: { property: { include: { owner: true } } } } }
    });
    
    if (!payment) {
        return errorResponse(res, 'Payment not found', 404);
    }
    if (payment.status !== 'PAID') {
        return errorResponse(res, 'Receipt is only available for paid payments', 400);
    }

    const isOwnerOrManager = (req.user.role === 'OWNER' && payment.lease.property.ownerId === req.user.owner.id) ||
                            (req.user.role === 'MANAGER' && payment.lease.property.ownerId === req.user.manager.ownerId);
    const isTenant = req.user.role === 'TENANT' && payment.tenantId === req.user.tenant.id;

    if (!isOwnerOrManager && !isTenant && req.user.role !== 'SUPER_ADMIN') {
        return errorResponse(res, 'You are not authorized to view this receipt', 403);
    }

    const pdfBuffer = await generatePdf({
        payment,
        tenant: payment.tenant,
        property: payment.lease.property,
        owner: payment.lease.property.owner
    });

    res.setHeader('Content-Type', 'application/pdf');
    res.setHeader('Content-Disposition', `attachment; filename=receipt-${payment.id}.pdf`);
    res.send(pdfBuffer);
});

export const getPaymentAnalytics = asyncHandler(async (req, res) => {
    let where = {};
    if (req.user.role === 'OWNER') {
        where = { lease: { property: { ownerId: req.user.owner.id } } };
    } else if (req.user.role === 'MANAGER') {
        where = { lease: { property: { ownerId: req.user.manager.ownerId } } };
    }

    const payments = await prisma.payment.findMany({ where });

    const totalRevenue = payments
        .filter(p => p.status === 'PAID')
        .reduce((sum, p) => sum + Number(p.amount), 0);
        
    const pendingRevenue = payments
        .filter(p => p.status === 'PENDING' || p.status === 'OVERDUE')
        .reduce((sum, p) => sum + Number(p.amount), 0);

    const statusBreakdown = payments.reduce((acc, p) => {
        acc[p.status] = (acc[p.status] || 0) + 1;
        return acc;
    }, {});
    
    const methodBreakdown = payments.filter(p => p.status === 'PAID' && p.method).reduce((acc, p) => {
        acc[p.method] = (acc[p.method] || 0) + 1;
        return acc;
    }, {});

    const analytics = {
        totalRevenue: parseFloat(totalRevenue.toFixed(2)),
        pendingRevenue: parseFloat(pendingRevenue.toFixed(2)),
        statusBreakdown,
        methodBreakdown,
        totalTransactions: payments.length,
    };
    
    return successResponse(res, analytics, "Payment analytics retrieved successfully.");
});

export const getOverduePayments = asyncHandler(async (req, res) => {
  const where = {
    status: 'PENDING',
    dueDate: { lt: new Date() },
  };

  if (req.user.role === 'OWNER') {
    where.lease = {
      property: { ownerId: req.user.owner.id },
    };
  } else if (req.user.role === 'MANAGER') {
    where.lease = {
      property: { ownerId: req.user.manager.ownerId },
    };
  }

  const overduePayments = await prisma.payment.findMany({
    where,
    include: {
      tenant: {
        select: {
          id: true,
          firstName: true,
          lastName: true,
          phone: true,
          user: {
            select: {
              email: true,
            },
          },
        },
      },
      lease: {
        select: {
          property: {
            select: {
              id: true,
              name: true,
              address: true,
            },
          },
        },
      },
    },
    orderBy: { dueDate: 'asc' },
  });

  if (overduePayments.length > 0) {
    const overdueIds = overduePayments.map(p => p.id);
    await prisma.payment.updateMany({
      where: { id: { in: overdueIds } },
      data: { status: 'OVERDUE' },
    });
  }

  return successResponse(res, {
    overduePayments: overduePayments.map(payment => ({
      ...payment,
      status: 'OVERDUE',
      daysOverdue: Math.floor((new Date() - new Date(payment.dueDate)) / (1000 * 60 * 60 * 24)),
    })),
    count: overduePayments.length,
  });
});

================
File: src/modules/payments/routes/paymentRoutes.js
================
import express from 'express';
import { authenticate, authorize } from '../../../middleware/auth.js';
import {
  createPayment,
  getPayments,
  getPaymentById,
  updatePayment,
  deletePayment,
  processOnlinePayment,
  getOverduePayments,
  downloadPaymentReceipt,
  getPaymentAnalytics,
} from '../controllers/paymentController.js';

const router = express.Router();

/**
 * @swagger
 * /payments:
 *   post:
 *     summary: Create a new payment
 *     tags: [Payments]
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - tenantId
 *               - amount
 *               - dueDate
 *               - type
 *             properties:
 *               tenantId:
 *                 type: string
 *               amount:
 *                 type: number
 *               dueDate:
 *                 type: string
 *                 format: date
 *               type:
 *                 type: string
 *                 enum: [RENT, DEPOSIT, UTILITIES, MAINTENANCE, LATE_FEE]
 *               description:
 *                 type: string
 *     responses:
 *       201:
 *         description: Payment created successfully
 *       400:
 *         description: Bad request
 *       401:
 *         description: Unauthorized
 */
router.post('/', authenticate, authorize(['SUPER_ADMIN', 'OWNER', 'MANAGER']), createPayment);

/**
 * @swagger
 * /payments:
 *   get:
 *     summary: Get all payments
 *     tags: [Payments]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: query
 *         name: page
 *         schema:
 *           type: integer
 *           default: 1
 *       - in: query
 *         name: limit
 *         schema:
 *           type: integer
 *           default: 10
 *       - in: query
 *         name: status
 *         schema:
 *           type: string
 *           enum: [PENDING, PAID, OVERDUE, CANCELLED]
 *     responses:
 *       200:
 *         description: List of payments
 */
router.get('/', authenticate, getPayments);

/**
 * @swagger
 * /payments/overdue:
 *   get:
 *     summary: Get overdue payments
 *     tags: [Payments]
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: List of overdue payments
 */
router.get('/overdue', authenticate, authorize(['SUPER_ADMIN', 'OWNER', 'MANAGER']), getOverduePayments);

/**
 * @swagger
 * /payments/analytics:
 *   get:
 *     summary: Get payment analytics
 *     tags: [Payments]
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: Payment analytics data
 */
router.get('/analytics', authenticate, authorize(['SUPER_ADMIN', 'OWNER', 'MANAGER']), getPaymentAnalytics);

/**
 * @swagger
 * /payments/{id}:
 *   get:
 *     summary: Get payment by ID
 *     tags: [Payments]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Payment details
 *       404:
 *         description: Payment not found
 */
router.get('/:id', authenticate, getPaymentById);

/**
 * @swagger
 * /payments/{id}:
 *   put:
 *     summary: Update payment
 *     tags: [Payments]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Payment updated successfully
 */
router.put('/:id', authenticate, authorize(['SUPER_ADMIN', 'OWNER', 'MANAGER']), updatePayment);

/**
 * @swagger
 * /payments/{id}:
 *   delete:
 *     summary: Delete payment
 *     tags: [Payments]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Payment deleted successfully
 */
router.delete('/:id', authenticate, authorize(['SUPER_ADMIN', 'OWNER', 'MANAGER']), deletePayment);

/**
 * @swagger
 * /payments/{id}/process:
 *   post:
 *     summary: Process payment
 *     tags: [Payments]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Payment processed successfully
 */
router.post('/:id/process', authenticate, processOnlinePayment);

/**
 * @swagger
 * /payments/{id}/receipt:
 *   get:
 *     summary: Generate payment receipt
 *     tags: [Payments]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Payment receipt PDF
 */
router.get('/:id/receipt', authenticate, downloadPaymentReceipt);

export default router;

================
File: src/modules/properties/controllers/propertyController.js
================
import { asyncHandler } from '../../../middleware/errorHandler.js';
import prisma from '../../../config/database.js';
import logger from '../../../config/logger.js';
import { uploadToCloudinary, deleteFromCloudinary } from '../../../utils/cloudinary.js';

/**
 * @swagger
 * components:
 *   schemas:
 *     Property:
 *       type: object
 *       properties:
 *         id:
 *           type: string
 *         name:
 *           type: string
 *         description:
 *           type: string
 *         address:
 *           type: string
 *         type:
 *           type: string
 *           enum: [APARTMENT, HOUSE, CONDO, TOWNHOUSE, STUDIO, OTHER]
 *         units:
 *           type: integer
 *         rentAmount:
 *           type: number
 *         status:
 *           type: string
 *           enum: [AVAILABLE, OCCUPIED, MAINTENANCE, UNAVAILABLE]
 *         images:
 *           type: array
 *           items:
 *             type: string
 *         amenities:
 *           type: array
 *           items:
 *             type: string
 */

/**
 * @swagger
 * /properties:
 *   get:
 *     tags: [Properties]
 *     summary: Get all properties
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: query
 *         name: page
 *         schema:
 *           type: integer
 *           default: 1
 *       - in: query
 *         name: limit
 *         schema:
 *           type: integer
 *           default: 10
 *       - in: query
 *         name: status
 *         schema:
 *           type: string
 *           enum: [AVAILABLE, OCCUPIED, MAINTENANCE, UNAVAILABLE]
 *       - in: query
 *         name: type
 *         schema:
 *           type: string
 *           enum: [APARTMENT, HOUSE, CONDO, TOWNHOUSE, STUDIO, OTHER]
 *     responses:
 *       200:
 *         description: Properties retrieved successfully
 */
export const getProperties = asyncHandler(async (req, res) => {
  const { page = 1, limit = 10, status, type, search } = req.query;
  const skip = (parseInt(page) - 1) * parseInt(limit);

  const where = {};

  // Role-based filtering
  if (req.user.role === 'OWNER') {
    where.ownerId = req.user.owner.id;
  } else if (req.user.role === 'MANAGER') {
    where.ownerId = req.user.manager.ownerId;
  }

  if (status) where.status = status;
  if (type) where.type = type;
  if (search) {
    where.OR = [
      { name: { contains: search, mode: 'insensitive' } },
      { address: { contains: search, mode: 'insensitive' } },
      { description: { contains: search, mode: 'insensitive' } },
    ];
  }

  const [properties, total] = await Promise.all([
    prisma.property.findMany({
      where,
      skip,
      take: parseInt(limit),
      include: {
        owner: {
          select: {
            id: true,
            companyName: true,
            user: {
              select: {
                email: true,
              },
            },
          },
        },
        tenants: {
          where: { isActive: true },
          select: {
            id: true,
            firstName: true,
            lastName: true,
            user: {
              select: {
                email: true,
              },
            },
          },
        },
        _count: {
          select: {
            tenants: { where: { isActive: true } },
            leases: { where: { status: 'ACTIVE' } },
          },
        },
      },
      orderBy: { createdAt: 'desc' },
    }),
    prisma.property.count({ where }),
  ]);

  res.json({
    properties,
    pagination: {
      total,
      page: parseInt(page),
      limit: parseInt(limit),
      pages: Math.ceil(total / parseInt(limit)),
    },
  });
});

/**
 * @swagger
 * /properties/{id}:
 *   get:
 *     tags: [Properties]
 *     summary: Get property by ID
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Property retrieved successfully
 *       404:
 *         description: Property not found
 */
export const getPropertyById = asyncHandler(async (req, res) => {
  const { id } = req.params;

  const property = await prisma.property.findUnique({
    where: { id },
    include: {
      owner: {
        select: {
          id: true,
          companyName: true,
          phone: true,
          user: {
            select: {
              email: true,
            },
          },
        },
      },
      tenants: {
        where: { isActive: true },
        include: {
          user: {
            select: {
              email: true,
            },
          },
          leases: {
            where: { status: 'ACTIVE' },
            select: {
              id: true,
              startDate: true,
              endDate: true,
              rentAmount: true,
            },
          },
        },
      },
      leases: {
        include: {
          tenant: {
            select: {
              firstName: true,
              lastName: true,
              user: {
                select: {
                  email: true,
                },
              },
            },
          },
        },
        orderBy: { createdAt: 'desc' },
      },
      complaints: {
        where: { status: { not: 'CLOSED' } },
        select: {
          id: true,
          subject: true,
          status: true,
          priority: true,
          createdAt: true,
        },
        orderBy: { createdAt: 'desc' },
      },
    },
  });

  if (!property) {
    return res.status(404).json({
      error: 'Property not found',
      message: 'Property with this ID does not exist',
    });
  }

  // Check access permissions
  if (req.user.role === 'OWNER' && property.ownerId !== req.user.owner.id) {
    return res.status(403).json({
      error: 'Forbidden',
      message: 'You can only access your own properties',
    });
  }

  if (req.user.role === 'MANAGER' && property.ownerId !== req.user.manager.ownerId) {
    return res.status(403).json({
      error: 'Forbidden',
      message: 'You can only access properties you manage',
    });
  }

  res.json({ property });
});

/**
 * @swagger
 * /properties:
 *   post:
 *     tags: [Properties]
 *     summary: Create a new property
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - name
 *               - address
 *               - rentAmount
 *             properties:
 *               name:
 *                 type: string
 *               description:
 *                 type: string
 *               address:
 *                 type: string
 *               type:
 *                 type: string
 *                 enum: [APARTMENT, HOUSE, CONDO, TOWNHOUSE, STUDIO, OTHER]
 *               units:
 *                 type: integer
 *               rentAmount:
 *                 type: number
 *               amenities:
 *                 type: array
 *                 items:
 *                   type: string
 *     responses:
 *       201:
 *         description: Property created successfully
 */
export const createProperty = asyncHandler(async (req, res) => {
  const {
    name,
    description,
    address,
    type = 'APARTMENT',
    units = 1,
    rentAmount,
    amenities = [],
  } = req.body;

  const ownerId = req.user.role === 'OWNER' ? req.user.owner.id : req.user.manager.ownerId;

  const property = await prisma.property.create({
    data: {
      name,
      description,
      address,
      type,
      units: parseInt(units),
      rentAmount: parseFloat(rentAmount),
      amenities,
      ownerId,
    },
    include: {
      owner: {
        select: {
          companyName: true,
          user: {
            select: {
              email: true,
            },
          },
        },
      },
    },
  });

  logger.info(`Property created: ${property.name} by user ${req.user.email}`);

  res.status(201).json({
    message: 'Property created successfully',
    property,
  });
});

/**
 * @swagger
 * /properties/{id}:
 *   put:
 *     tags: [Properties]
 *     summary: Update property
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               name:
 *                 type: string
 *               description:
 *                 type: string
 *               address:
 *                 type: string
 *               type:
 *                 type: string
 *               units:
 *                 type: integer
 *               rentAmount:
 *                 type: number
 *               status:
 *                 type: string
 *               amenities:
 *                 type: array
 *                 items:
 *                   type: string
 *     responses:
 *       200:
 *         description: Property updated successfully
 */
export const updateProperty = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const updateData = req.body;

  // Check if property exists and user has permission
  const existingProperty = await prisma.property.findUnique({
    where: { id },
  });

  if (!existingProperty) {
    return res.status(404).json({
      error: 'Property not found',
      message: 'Property with this ID does not exist',
    });
  }

  // Check permissions
  const allowedOwnerId = req.user.role === 'OWNER' ? req.user.owner.id : req.user.manager.ownerId;
  if (existingProperty.ownerId !== allowedOwnerId) {
    return res.status(403).json({
      error: 'Forbidden',
      message: 'You can only update your own properties',
    });
  }

  // Convert numeric fields
  if (updateData.units) updateData.units = parseInt(updateData.units);
  if (updateData.rentAmount) updateData.rentAmount = parseFloat(updateData.rentAmount);

  const property = await prisma.property.update({
    where: { id },
    data: updateData,
    include: {
      owner: {
        select: {
          companyName: true,
          user: {
            select: {
              email: true,
            },
          },
        },
      },
    },
  });

  logger.info(`Property updated: ${property.name} by user ${req.user.email}`);

  res.json({
    message: 'Property updated successfully',
    property,
  });
});

/**
 * @swagger
 * /properties/{id}/images:
 *   post:
 *     tags: [Properties]
 *     summary: Upload property images
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     requestBody:
 *       required: true
 *       content:
 *         multipart/form-data:
 *           schema:
 *             type: object
 *             properties:
 *               images:
 *                 type: array
 *                 items:
 *                   type: string
 *                   format: binary
 *     responses:
 *       200:
 *         description: Images uploaded successfully
 */
export const uploadPropertyImages = asyncHandler(async (req, res) => {
  const { id } = req.params;

  if (!req.files || req.files.length === 0) {
    return res.status(400).json({
      error: 'No images provided',
      message: 'Please select at least one image to upload',
    });
  }

  // Check if property exists and user has permission
  const property = await prisma.property.findUnique({
    where: { id },
  });

  if (!property) {
    return res.status(404).json({
      error: 'Property not found',
      message: 'Property with this ID does not exist',
    });
  }

  const allowedOwnerId = req.user.role === 'OWNER' ? req.user.owner.id : req.user.manager.ownerId;
  if (property.ownerId !== allowedOwnerId) {
    return res.status(403).json({
      error: 'Forbidden',
      message: 'You can only upload images for your own properties',
    });
  }

  // Upload images to Cloudinary
  const uploadPromises = req.files.map(file => uploadToCloudinary(file.buffer, 'properties'));
  const uploadResults = await Promise.all(uploadPromises);
  const imageUrls = uploadResults.map(result => result.secure_url);

  // Update property with new images
  const updatedProperty = await prisma.property.update({
    where: { id },
    data: {
      images: [...property.images, ...imageUrls],
    },
  });

  logger.info(`Images uploaded for property: ${property.name} by user ${req.user.email}`);

  res.json({
    message: 'Images uploaded successfully',
    images: imageUrls,
    property: updatedProperty,
  });
});

/**
 * @swagger
 * /properties/{id}:
 *   delete:
 *     tags: [Properties]
 *     summary: Delete property
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Property deleted successfully
 */
export const deleteProperty = asyncHandler(async (req, res) => {
  const { id } = req.params;

  const property = await prisma.property.findUnique({
    where: { id },
    include: {
      tenants: { where: { isActive: true } },
      leases: { where: { status: 'ACTIVE' } },
    },
  });

  if (!property) {
    return res.status(404).json({
      error: 'Property not found',
      message: 'Property with this ID does not exist',
    });
  }

  // Check permissions
  const allowedOwnerId = req.user.role === 'OWNER' ? req.user.owner.id : req.user.manager.ownerId;
  if (property.ownerId !== allowedOwnerId) {
    return res.status(403).json({
      error: 'Forbidden',
      message: 'You can only delete your own properties',
    });
  }

  // Check if property has active tenants or leases
  if (property.tenants.length > 0 || property.leases.length > 0) {
    return res.status(400).json({
      error: 'Cannot delete property',
      message: 'Property has active tenants or leases. Please resolve them first.',
    });
  }

  // Delete images from Cloudinary
  if (property.images.length > 0) {
    const deletePromises = property.images.map(imageUrl => {
      const publicId = imageUrl.split('/').pop().split('.')[0];
      return deleteFromCloudinary(publicId);
    });
    await Promise.allSettled(deletePromises);
  }

  await prisma.property.delete({
    where: { id },
  });

  logger.info(`Property deleted: ${property.name} by user ${req.user.email}`);

  res.json({
    message: 'Property deleted successfully',
  });
});

================
File: src/modules/properties/routes/propertyRoutes.js
================
import express from 'express';
import { authenticate, authorize } from '../../../middleware/auth.js';
import { validateProperty, validatePropertyUpdate } from '../../../middleware/validation.js';
import { upload } from '../../../middleware/upload.js';
import {
  getProperties,
  getPropertyById,
  createProperty,
  updateProperty,
  uploadPropertyImages,
  deleteProperty,
} from '../controllers/propertyController.js';

const router = express.Router();

/**
 * @swagger
 * tags:
 *   name: Properties
 *   description: Property management endpoints
 */

// All routes require authentication
router.use(authenticate);

// Get all properties
router.get('/', authorize('SUPER_ADMIN', 'OWNER', 'MANAGER'), getProperties);

// Get property by ID
router.get('/:id', authorize('SUPER_ADMIN', 'OWNER', 'MANAGER', 'TENANT'), getPropertyById);

// Create new property
router.post('/', authorize('SUPER_ADMIN', 'OWNER', 'MANAGER'), validateProperty, createProperty);

// Update property
router.put('/:id', authorize('SUPER_ADMIN', 'OWNER', 'MANAGER'), validatePropertyUpdate, updateProperty);

// Upload property images
router.post('/:id/images', authorize('SUPER_ADMIN', 'OWNER', 'MANAGER'), upload.array('images', 10), uploadPropertyImages);

// Delete property
router.delete('/:id', authorize('SUPER_ADMIN', 'OWNER'), deleteProperty);

export default router;

================
File: src/modules/reports/controllers/reportController.js
================
import prisma from '../../../config/database.js';
import logger from '../../../config/logger.js';
import { generatePaymentReceipt } from '../../../utils/pdfGenerator.js';
import { successResponse, errorResponse } from '../../../utils/responseHelpers.js';

export const getFinancialReport = async (req, res) => {
  try {
    const { startDate, endDate, propertyId, format = 'json' } = req.query;
    
    let where = {
      createdAt: {
        gte: new Date(startDate),
        lte: new Date(endDate)
      }
    };

    // Apply role-based filtering
    if (req.user.role === 'OWNER') {
      where.lease = {
        property: {
          ownerId: req.user.owner.id
        }
      };
    } else if (req.user.role === 'MANAGER') {
      where.lease = {
        property: {
          ownerId: req.user.manager.ownerId
        }
      };
    }

    if (propertyId) {
      where.lease = {
        ...where.lease,
        propertyId
      };
    }

    const payments = await prisma.payment.findMany({
      where,
      include: {
        lease: {
          include: {
            property: {
              select: {
                id: true,
                name: true,
                address: true
              }
            },
            tenant: {
              select: {
                firstName: true,
                lastName: true
              }
            }
          }
        }
      },
      orderBy: { createdAt: 'desc' }
    });

    const summary = {
      totalRevenue: payments.filter(p => p.status === 'PAID').reduce((sum, p) => sum + p.amount, 0),
      pendingRevenue: payments.filter(p => p.status === 'PENDING').reduce((sum, p) => sum + p.amount, 0),
      overdueRevenue: payments.filter(p => p.status === 'OVERDUE').reduce((sum, p) => sum + p.amount, 0),
      totalPayments: payments.length,
      paidPayments: payments.filter(p => p.status === 'PAID').length,
      pendingPayments: payments.filter(p => p.status === 'PENDING').length,
      overduePayments: payments.filter(p => p.status === 'OVERDUE').length
    };

    const reportData = {
      period: { startDate, endDate },
      summary,
      payments,
      generatedAt: new Date().toISOString()
    };

    if (format === 'pdf') {
      const pdfBuffer = await generatePaymentReceipt(reportData);
      res.setHeader('Content-Type', 'application/pdf');
      res.setHeader('Content-Disposition', 'attachment; filename=financial-report.pdf');
      return res.send(pdfBuffer);
    }

    successResponse(res, reportData, 'Financial report generated successfully');

  } catch (error) {
    logger.error('Error generating financial report:', error);
    errorResponse(res, 'Failed to generate financial report', 500);
  }
};

export const getOccupancyReport = async (req, res) => {
  try {
    const { startDate, endDate, propertyId } = req.query;
    
    let propertyWhere = {};
    
    if (req.user.role === 'OWNER') {
      propertyWhere.ownerId = req.user.owner.id;
    } else if (req.user.role === 'MANAGER') {
      propertyWhere.ownerId = req.user.manager.ownerId;
    }

    if (propertyId) {
      propertyWhere.id = propertyId;
    }

    const properties = await prisma.property.findMany({
      where: propertyWhere,
      include: {
        leases: {
          where: {
            OR: [
              {
                startDate: {
                  lte: new Date(endDate)
                },
                endDate: {
                  gte: new Date(startDate)
                }
              },
              {
                status: 'ACTIVE'
              }
            ]
          },
          include: {
            tenant: {
              select: {
                firstName: true,
                lastName: true
              }
            }
          }
        }
      }
    });

    const occupancyData = properties.map(property => {
      const activeLease = property.leases.find(lease => lease.status === 'ACTIVE');
      const occupancyRate = property.units > 0 ? (activeLease ? 1 : 0) : 0;
      
      return {
        propertyId: property.id,
        propertyName: property.name,
        address: property.address,
        totalUnits: property.units,
        occupiedUnits: activeLease ? 1 : 0,
        occupancyRate: occupancyRate * 100,
        currentTenant: activeLease ? 
          `${activeLease.tenant.firstName} ${activeLease.tenant.lastName}` : null,
        leaseStartDate: activeLease?.startDate,
        leaseEndDate: activeLease?.endDate
      };
    });

    const summary = {
      totalProperties: properties.length,
      occupiedProperties: occupancyData.filter(p => p.occupiedUnits > 0).length,
      vacantProperties: occupancyData.filter(p => p.occupiedUnits === 0).length,
      averageOccupancyRate: occupancyData.reduce((sum, p) => sum + p.occupancyRate, 0) / properties.length
    };

    successResponse(res, {
      period: { startDate, endDate },
      summary,
      properties: occupancyData,
      generatedAt: new Date().toISOString()
    }, 'Occupancy report generated successfully');

  } catch (error) {
    logger.error('Error generating occupancy report:', error);
    errorResponse(res, 'Failed to generate occupancy report', 500);
  }
};

export const getMaintenanceReport = async (req, res) => {
  try {
    const { startDate, endDate, propertyId } = req.query;
    
    let where = {
      createdAt: {
        gte: new Date(startDate),
        lte: new Date(endDate)
      }
    };

    if (req.user.role === 'OWNER') {
      where.property = {
        ownerId: req.user.owner.id
      };
    } else if (req.user.role === 'MANAGER') {
      where.property = {
        ownerId: req.user.manager.ownerId
      };
    }

    if (propertyId) {
      where.propertyId = propertyId;
    }

    const complaints = await prisma.complaint.findMany({
      where,
      include: {
        property: {
          select: {
            id: true,
            name: true,
            address: true
          }
        },
        reporter: {
          select: {
            email: true,
            role: true
          }
        }
      },
      orderBy: { createdAt: 'desc' }
    });

    const summary = {
      totalComplaints: complaints.length,
      openComplaints: complaints.filter(c => c.status === 'OPEN').length,
      inProgressComplaints: complaints.filter(c => c.status === 'IN_PROGRESS').length,
      resolvedComplaints: complaints.filter(c => c.status === 'RESOLVED').length,
      closedComplaints: complaints.filter(c => c.status === 'CLOSED').length,
      byCategory: complaints.reduce((acc, complaint) => {
        acc[complaint.category] = (acc[complaint.category] || 0) + 1;
        return acc;
      }, {}),
      byPriority: complaints.reduce((acc, complaint) => {
        acc[complaint.priority] = (acc[complaint.priority] || 0) + 1;
        return acc;
      }, {})
    };

    successResponse(res, {
      period: { startDate, endDate },
      summary,
      complaints,
      generatedAt: new Date().toISOString()
    }, 'Maintenance report generated successfully');

  } catch (error) {
    logger.error('Error generating maintenance report:', error);
    errorResponse(res, 'Failed to generate maintenance report', 500);
  }
};

================
File: src/modules/reports/routes/reportRoutes.js
================
import { Router } from 'express';
import { authenticate, authorize } from '../../../middleware/auth.js';
import {
  getFinancialReport,
  getOccupancyReport,
  getMaintenanceReport
} from '../controllers/reportController.js';

const router = Router();

/**
 * @swagger
 * /reports/financial:
 *   get:
 *     tags: [Reports]
 *     summary: Generate financial report
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: query
 *         name: startDate
 *         required: true
 *         schema:
 *           type: string
 *           format: date
 *       - in: query
 *         name: endDate
 *         required: true
 *         schema:
 *           type: string
 *           format: date
 *       - in: query
 *         name: propertyId
 *         schema:
 *           type: string
 *       - in: query
 *         name: format
 *         schema:
 *           type: string
 *           enum: [json, pdf]
 *           default: json
 *     responses:
 *       200:
 *         description: Financial report generated successfully
 */
router.get('/financial', authenticate, authorize(['OWNER', 'MANAGER', 'SUPER_ADMIN']), getFinancialReport);

/**
 * @swagger
 * /reports/occupancy:
 *   get:
 *     tags: [Reports]
 *     summary: Generate occupancy report
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: query
 *         name: startDate
 *         required: true
 *         schema:
 *           type: string
 *           format: date
 *       - in: query
 *         name: endDate
 *         required: true
 *         schema:
 *           type: string
 *           format: date
 *       - in: query
 *         name: propertyId
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Occupancy report generated successfully
 */
router.get('/occupancy', authenticate, authorize(['OWNER', 'MANAGER', 'SUPER_ADMIN']), getOccupancyReport);

/**
 * @swagger
 * /reports/maintenance:
 *   get:
 *     tags: [Reports]
 *     summary: Generate maintenance report
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: query
 *         name: startDate
 *         required: true
 *         schema:
 *           type: string
 *           format: date
 *       - in: query
 *         name: endDate
 *         required: true
 *         schema:
 *           type: string
 *           format: date
 *       - in: query
 *         name: propertyId
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Maintenance report generated successfully
 */
router.get('/maintenance', authenticate, authorize(['OWNER', 'MANAGER', 'SUPER_ADMIN']), getMaintenanceReport);

export default router;

================
File: src/modules/tenants/controllers/tenantController.js
================
import { asyncHandler } from '../../../middleware/errorHandler.js';
import prisma from '../../../config/database.js';
import logger from '../../../config/logger.js';
import { createTenantUser } from '../../auth/controllers/authController.js';

/**
 * @swagger
 * components:
 *   schemas:
 *     Tenant:
 *       type: object
 *       properties:
 *         id:
 *           type: string
 *         firstName:
 *           type: string
 *         lastName:
 *           type: string
 *         phone:
 *           type: string
 *         emergencyContact:
 *           type: object
 *         moveInDate:
 *           type: string
 *           format: date
 *         isActive:
 *           type: boolean
 */

/**
 * @swagger
 * /tenants:
 *   get:
 *     tags: [Tenants]
 *     summary: Get all tenants
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: query
 *         name: page
 *         schema:
 *           type: integer
 *           default: 1
 *       - in: query
 *         name: limit
 *         schema:
 *           type: integer
 *           default: 10
 *       - in: query
 *         name: propertyId
 *         schema:
 *           type: string
 *       - in: query
 *         name: isActive
 *         schema:
 *           type: boolean
 *     responses:
 *       200:
 *         description: Tenants retrieved successfully
 */
export const getTenants = asyncHandler(async (req, res) => {
  const { page = 1, limit = 10, propertyId, isActive, search } = req.query;
  const skip = (parseInt(page) - 1) * parseInt(limit);

  const where = {};

  // Role-based filtering
  if (req.user.role === 'OWNER') {
    where.property = { ownerId: req.user.owner.id };
  } else if (req.user.role === 'MANAGER') {
    where.property = { ownerId: req.user.manager.ownerId };
  }

  if (propertyId) where.propertyId = propertyId;
  if (isActive !== undefined) where.isActive = isActive === 'true';
  if (search) {
    where.OR = [
      { firstName: { contains: search, mode: 'insensitive' } },
      { lastName: { contains: search, mode: 'insensitive' } },
      { phone: { contains: search, mode: 'insensitive' } },
      { user: { email: { contains: search, mode: 'insensitive' } } },
    ];
  }

  const [tenants, total] = await Promise.all([
    prisma.tenant.findMany({
      where,
      skip,
      take: parseInt(limit),
      include: {
        user: {
          select: {
            id: true,
            email: true,
            isActive: true,
            lastLogin: true,
          },
        },
        property: {
          select: {
            id: true,
            name: true,
            address: true,
            type: true,
          },
        },
        leases: {
          where: { status: 'ACTIVE' },
          select: {
            id: true,
            startDate: true,
            endDate: true,
            rentAmount: true,
            status: true,
          },
        },
        payments: {
          where: { status: 'OVERDUE' },
          select: {
            id: true,
            amount: true,
            dueDate: true,
          },
        },
      },
      orderBy: { createdAt: 'desc' },
    }),
    prisma.tenant.count({ where }),
  ]);

  res.json({
    tenants,
    pagination: {
      total,
      page: parseInt(page),
      limit: parseInt(limit),
      pages: Math.ceil(total / parseInt(limit)),
    },
  });
});

/**
 * @swagger
 * /tenants/{id}:
 *   get:
 *     tags: [Tenants]
 *     summary: Get tenant by ID
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Tenant retrieved successfully
 *       404:
 *         description: Tenant not found
 */
export const getTenantById = asyncHandler(async (req, res) => {
  const { id } = req.params;

  const tenant = await prisma.tenant.findUnique({
    where: { id },
    include: {
      user: {
        select: {
          id: true,
          email: true,
          isActive: true,
          lastLogin: true,
          createdAt: true,
        },
      },
      property: {
        include: {
          owner: {
            select: {
              companyName: true,
              phone: true,
              user: {
                select: {
                  email: true,
                },
              },
            },
          },
        },
      },
      leases: {
        include: {
          payments: {
            select: {
              id: true,
              amount: true,
              dueDate: true,
              paidDate: true,
              status: true,
            },
            orderBy: { dueDate: 'desc' },
          },
        },
        orderBy: { createdAt: 'desc' },
      },
      payments: {
        select: {
          id: true,
          amount: true,
          dueDate: true,
          paidDate: true,
          status: true,
          method: true,
        },
        orderBy: { dueDate: 'desc' },
        take: 10,
      },
      complaints: {
        select: {
          id: true,
          subject: true,
          status: true,
          priority: true,
          createdAt: true,
        },
        orderBy: { createdAt: 'desc' },
      },
    },
  });

  if (!tenant) {
    return res.status(404).json({
      error: 'Tenant not found',
      message: 'Tenant with this ID does not exist',
    });
  }

  // Check access permissions
  if (req.user.role === 'TENANT' && tenant.userId !== req.user.id) {
    return res.status(403).json({
      error: 'Forbidden',
      message: 'You can only access your own information',
    });
  }

  if (req.user.role === 'OWNER' && tenant.property.ownerId !== req.user.owner.id) {
    return res.status(403).json({
      error: 'Forbidden',
      message: 'You can only access your property tenants',
    });
  }

  if (req.user.role === 'MANAGER' && tenant.property.ownerId !== req.user.manager.ownerId) {
    return res.status(403).json({
      error: 'Forbidden',
      message: 'You can only access tenants you manage',
    });
  }

  res.json({ tenant });
});

/**
 * @swagger
 * /tenants:
 *   post:
 *     tags: [Tenants]
 *     summary: Add a new tenant
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - email
 *               - firstName
 *               - lastName
 *               - phone
 *               - propertyId
 *             properties:
 *               email:
 *                 type: string
 *                 format: email
 *               firstName:
 *                 type: string
 *               lastName:
 *                 type: string
 *               phone:
 *                 type: string
 *               propertyId:
 *                 type: string
 *               emergencyContact:
 *                 type: object
 *               moveInDate:
 *                 type: string
 *                 format: date
 *     responses:
 *       201:
 *         description: Tenant added successfully
 */
export const addTenant = asyncHandler(async (req, res) => {
  const {
    email,
    firstName,
    lastName,
    phone,
    propertyId,
    emergencyContact,
    moveInDate,
  } = req.body;

  // Check if property exists and user has permission
  const property = await prisma.property.findUnique({
    where: { id: propertyId },
  });

  if (!property) {
    return res.status(404).json({
      error: 'Property not found',
      message: 'Property with this ID does not exist',
    });
  }

  const allowedOwnerId = req.user.role === 'OWNER' ? req.user.owner.id : req.user.manager.ownerId;
  if (property.ownerId !== allowedOwnerId) {
    return res.status(403).json({
      error: 'Forbidden',
      message: 'You can only add tenants to your own properties',
    });
  }

  // Check if email is already in use
  const existingUser = await prisma.user.findUnique({
    where: { email: email.toLowerCase() },
  });

  if (existingUser) {
    return res.status(409).json({
      error: 'Email already exists',
      message: 'A user with this email already exists',
    });
  }

  // Create user account for tenant
  const user = await createTenantUser(email, { firstName, lastName });

  // Create tenant record
  const tenant = await prisma.tenant.create({
    data: {
      userId: user.id,
      propertyId,
      firstName,
      lastName,
      phone,
      emergencyContact,
      moveInDate: moveInDate ? new Date(moveInDate) : null,
    },
    include: {
      user: {
        select: {
          id: true,
          email: true,
          isActive: true,
        },
      },
      property: {
        select: {
          id: true,
          name: true,
          address: true,
        },
      },
    },
  });

  logger.info(`Tenant added: ${firstName} ${lastName} by user ${req.user.email}`);

  res.status(201).json({
    message: 'Tenant added successfully',
    tenant,
  });
});

/**
 * @swagger
 * /tenants/{id}:
 *   put:
 *     tags: [Tenants]
 *     summary: Update tenant information
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               firstName:
 *                 type: string
 *               lastName:
 *                 type: string
 *               phone:
 *                 type: string
 *               emergencyContact:
 *                 type: object
 *               moveInDate:
 *                 type: string
 *                 format: date
 *     responses:
 *       200:
 *         description: Tenant updated successfully
 */
export const updateTenant = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const updateData = req.body;

  const existingTenant = await prisma.tenant.findUnique({
    where: { id },
    include: {
      property: true,
    },
  });

  if (!existingTenant) {
    return res.status(404).json({
      error: 'Tenant not found',
      message: 'Tenant with this ID does not exist',
    });
  }

  // Check permissions
  if (req.user.role === 'TENANT' && existingTenant.userId !== req.user.id) {
    return res.status(403).json({
      error: 'Forbidden',
      message: 'You can only update your own information',
    });
  }

  if (req.user.role === 'OWNER' && existingTenant.property.ownerId !== req.user.owner.id) {
    return res.status(403).json({
      error: 'Forbidden',
      message: 'You can only update your property tenants',
    });
  }

  if (req.user.role === 'MANAGER' && existingTenant.property.ownerId !== req.user.manager.ownerId) {
    return res.status(403).json({
      error: 'Forbidden',
      message: 'You can only update tenants you manage',
    });
  }

  // Convert date
  if (updateData.moveInDate) {
    updateData.moveInDate = new Date(updateData.moveInDate);
  }

  const tenant = await prisma.tenant.update({
    where: { id },
    data: updateData,
    include: {
      user: {
        select: {
          id: true,
          email: true,
          isActive: true,
        },
      },
      property: {
        select: {
          id: true,
          name: true,
          address: true,
        },
      },
    },
  });

  logger.info(`Tenant updated: ${tenant.firstName} ${tenant.lastName} by user ${req.user.email}`);

  res.json({
    message: 'Tenant updated successfully',
    tenant,
  });
});

/**
 * @swagger
 * /tenants/{id}/deactivate:
 *   patch:
 *     tags: [Tenants]
 *     summary: Deactivate tenant
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Tenant deactivated successfully
 */
export const deactivateTenant = asyncHandler(async (req, res) => {
  const { id } = req.params;

  const existingTenant = await prisma.tenant.findUnique({
    where: { id },
    include: {
      property: true,
      leases: { where: { status: 'ACTIVE' } },
    },
  });

  if (!existingTenant) {
    return res.status(404).json({
      error: 'Tenant not found',
      message: 'Tenant with this ID does not exist',
    });
  }

  // Check permissions
  const allowedOwnerId = req.user.role === 'OWNER' ? req.user.owner.id : req.user.manager.ownerId;
  if (existingTenant.property.ownerId !== allowedOwnerId) {
    return res.status(403).json({
      error: 'Forbidden',
      message: 'You can only deactivate your property tenants',
    });
  }

  // Check for active leases
  if (existingTenant.leases.length > 0) {
    return res.status(400).json({
      error: 'Cannot deactivate tenant',
      message: 'Tenant has active leases. Please terminate leases first.',
    });
  }

  // Deactivate tenant and user
  await prisma.$transaction([
    prisma.tenant.update({
      where: { id },
      data: { isActive: false },
    }),
    prisma.user.update({
      where: { id: existingTenant.userId },
      data: { isActive: false },
    }),
  ]);

  logger.info(`Tenant deactivated: ${existingTenant.firstName} ${existingTenant.lastName} by user ${req.user.email}`);

  res.json({
    message: 'Tenant deactivated successfully',
  });
});

/**
 * @swagger
 * /tenants/me:
 *   get:
 *     tags: [Tenants]
 *     summary: Get current tenant profile
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: Tenant profile retrieved successfully
 */
export const getTenantProfile = asyncHandler(async (req, res) => {
  if (req.user.role !== 'TENANT') {
    return res.status(403).json({
      error: 'Forbidden',
      message: 'This endpoint is only for tenants',
    });
  }

  const tenant = await prisma.tenant.findUnique({
    where: { userId: req.user.id },
    include: {
      user: {
        select: {
          id: true,
          email: true,
          isActive: true,
          lastLogin: true,
        },
      },
      property: {
        include: {
          owner: {
            select: {
              companyName: true,
              phone: true,
              user: {
                select: {
                  email: true,
                },
              },
            },
          },
        },
      },
      leases: {
        where: { status: 'ACTIVE' },
        include: {
          payments: {
            select: {
              id: true,
              amount: true,
              dueDate: true,
              paidDate: true,
              status: true,
            },
            orderBy: { dueDate: 'desc' },
            take: 5,
          },
        },
      },
      payments: {
        where: { status: { in: ['PENDING', 'OVERDUE'] } },
        select: {
          id: true,
          amount: true,
          dueDate: true,
          status: true,
        },
        orderBy: { dueDate: 'asc' },
      },
    },
  });

  if (!tenant) {
    return res.status(404).json({
      error: 'Tenant profile not found',
      message: 'Your tenant profile could not be found',
    });
  }

  res.json({ tenant });
});

================
File: src/modules/tenants/routes/tenantRoutes.js
================
import express from 'express';
import { authenticate, authorize } from '../../../middleware/auth.js';
import { validateTenant, validateTenantUpdate } from '../../../middleware/validation.js';
import {
  getTenants,
  getTenantById,
  addTenant,
  updateTenant,
  deactivateTenant,
  getTenantProfile,
} from '../controllers/tenantController.js';

const router = express.Router();

/**
 * @swagger
 * tags:
 *   name: Tenants
 *   description: Tenant management endpoints
 */

// All routes require authentication
router.use(authenticate);

// Get current tenant profile
router.get('/me', authorize('TENANT'), getTenantProfile);

// Get all tenants
router.get('/', authorize('SUPER_ADMIN', 'OWNER', 'MANAGER'), getTenants);

// Get tenant by ID
router.get('/:id', getTenantById);

// Add new tenant
router.post('/', authorize('SUPER_ADMIN', 'OWNER', 'MANAGER'), validateTenant, addTenant);

// Update tenant
router.put('/:id', validateTenantUpdate, updateTenant);

// Deactivate tenant
router.patch('/:id/deactivate', authorize('SUPER_ADMIN', 'OWNER', 'MANAGER'), deactivateTenant);

export default router;

================
File: src/services/auditService.js
================
import prisma from '../config/database.js';
import logger from '../config/logger.js';

export const logActivity = async (action, userId, resourceType, resourceId, details = {}) => {
  try {
    const auditLog = await prisma.auditLog.create({
      data: {
        action,
        userId,
        resourceType,
        resourceId,
        details,
        ipAddress: details.ipAddress || null,
        userAgent: details.userAgent || null,
        timestamp: new Date()
      }
    });

    logger.info(`Audit log created: ${action} by user ${userId} on ${resourceType}:${resourceId}`);
    return auditLog;

  } catch (error) {
    logger.error('Error creating audit log:', error);
    throw error;
  }
};

export const getAuditLogs = async (filters = {}) => {
  try {
    const {
      userId,
      resourceType,
      resourceId,
      action,
      startDate,
      endDate,
      page = 1,
      limit = 50
    } = filters;

    const where = {};
    if (userId) where.userId = userId;
    if (resourceType) where.resourceType = resourceType;
    if (resourceId) where.resourceId = resourceId;
    if (action) where.action = action;
    
    if (startDate || endDate) {
      where.timestamp = {};
      if (startDate) where.timestamp.gte = new Date(startDate);
      if (endDate) where.timestamp.lte = new Date(endDate);
    }

    const skip = (parseInt(page) - 1) * parseInt(limit);

    const [logs, total] = await Promise.all([
      prisma.auditLog.findMany({
        where,
        skip,
        take: parseInt(limit),
        include: {
          user: {
            select: {
              id: true,
              email: true,
              role: true
            }
          }
        },
        orderBy: { timestamp: 'desc' }
      }),
      prisma.auditLog.count({ where })
    ]);

    return {
      logs,
      pagination: {
        total,
        page: parseInt(page),
        limit: parseInt(limit),
        pages: Math.ceil(total / parseInt(limit))
      }
    };

  } catch (error) {
    logger.error('Error fetching audit logs:', error);
    throw error;
  }
};

================
File: src/services/backupService.js
================
import { spawn } from 'child_process';
import fs from 'fs/promises';
import path from 'path';
import logger from '../config/logger.js';

export const createDatabaseBackup = async () => {
  try {
    const backupDir = path.join(process.cwd(), 'backups');
    await fs.mkdir(backupDir, { recursive: true });

    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const backupFile = path.join(backupDir, `backup-${timestamp}.sql`);

    const databaseUrl = process.env.DATABASE_URL;
    const urlParts = new URL(databaseUrl);
    
    const pgDumpArgs = [
      '-h', urlParts.hostname,
      '-p', urlParts.port || '5432',
      '-U', urlParts.username,
      '-d', urlParts.pathname.slice(1),
      '-f', backupFile,
      '--verbose',
      '--clean',
      '--no-owner',
      '--no-privileges'
    ];

    return new Promise((resolve, reject) => {
      const pgDump = spawn('pg_dump', pgDumpArgs, {
        env: { ...process.env, PGPASSWORD: urlParts.password }
      });

      pgDump.on('close', (code) => {
        if (code === 0) {
          logger.info(`Database backup created: ${backupFile}`);
          resolve(backupFile);
        } else {
          reject(new Error(`pg_dump exited with code ${code}`));
        }
      });

      pgDump.on('error', (error) => {
        reject(error);
      });
    });

  } catch (error) {
    logger.error('Error creating database backup:', error);
    throw error;
  }
};

export const restoreDatabaseBackup = async (backupFile) => {
  try {
    const databaseUrl = process.env.DATABASE_URL;
    const urlParts = new URL(databaseUrl);
    
    const psqlArgs = [
      '-h', urlParts.hostname,
      '-p', urlParts.port || '5432',
      '-U', urlParts.username,
      '-d', urlParts.pathname.slice(1),
      '-f', backupFile,
      '--verbose'
    ];

    return new Promise((resolve, reject) => {
      const psql = spawn('psql', psqlArgs, {
        env: { ...process.env, PGPASSWORD: urlParts.password }
      });

      psql.on('close', (code) => {
        if (code === 0) {
          logger.info(`Database restored from: ${backupFile}`);
          resolve(true);
        } else {
          reject(new Error(`psql exited with code ${code}`));
        }
      });

      psql.on('error', (error) => {
        reject(error);
      });
    });

  } catch (error) {
    logger.error('Error restoring database backup:', error);
    throw error;
  }
};

export const cleanupOldBackups = async (maxAge = 30) => {
  try {
    const backupDir = path.join(process.cwd(), 'backups');
    const files = await fs.readdir(backupDir);
    
    const cutoffDate = new Date();
    cutoffDate.setDate(cutoffDate.getDate() - maxAge);

    for (const file of files) {
      if (file.endsWith('.sql')) {
        const filePath = path.join(backupDir, file);
        const stats = await fs.stat(filePath);
        
        if (stats.mtime < cutoffDate) {
          await fs.unlink(filePath);
          logger.info(`Deleted old backup: ${file}`);
        }
      }
    }

  } catch (error) {
    logger.error('Error cleaning up old backups:', error);
    throw error;
  }
};

================
File: src/services/cronJobs.js
================
import cron from 'node-cron';
import prisma from '../config/database.js';
import logger from '../config/logger.js';
import { sendPaymentReminderEmail } from '../modules/notifications/services/emailService.js';

// Run every day at 9 AM to check for overdue payments
export const checkOverduePayments = () => {
  cron.schedule('0 9 * * *', async () => {
    try {
      logger.info('Running overdue payments check...');

      const overduePayments = await prisma.payment.updateMany({
        where: {
          status: 'PENDING',
          dueDate: {
            lt: new Date(),
          },
        },
        data: {
          status: 'OVERDUE',
        },
      });

      logger.info(`Updated ${overduePayments.count} payments to overdue status`);

      // Send reminder emails for overdue payments
      const overduePaymentsWithDetails = await prisma.payment.findMany({
        where: {
          status: 'OVERDUE',
          dueDate: {
            gte: new Date(Date.now() - 24 * 60 * 60 * 1000), // Updated today
          },
        },
        include: {
          tenant: {
            include: {
              user: true,
            },
          },
          lease: {
            include: {
              property: true,
            },
          },
        },
      });

      for (const payment of overduePaymentsWithDetails) {
        try {
          await sendPaymentReminderEmail(
            payment.tenant.user.email,
            payment.tenant.firstName,
            payment.amount,
            payment.dueDate,
            payment.lease.property.name
          );
        } catch (error) {
          logger.error(`Failed to send reminder email to ${payment.tenant.user.email}:`, error);
        }
      }

      logger.info(`Sent reminder emails for ${overduePaymentsWithDetails.length} overdue payments`);
    } catch (error) {
      logger.error('Error checking overdue payments:', error);
    }
  });
};

// Run every day at 8 AM to send payment reminders (3 days before due)
export const sendPaymentReminders = () => {
  cron.schedule('0 8 * * *', async () => {
    try {
      logger.info('Running payment reminders check...');

      const threeDaysFromNow = new Date();
      threeDaysFromNow.setDate(threeDaysFromNow.getDate() + 3);

      const upcomingPayments = await prisma.payment.findMany({
        where: {
          status: 'PENDING',
          dueDate: {
            gte: new Date(),
            lte: threeDaysFromNow,
          },
        },
        include: {
          tenant: {
            include: {
              user: true,
            },
          },
          lease: {
            include: {
              property: true,
            },
          },
        },
      });

      for (const payment of upcomingPayments) {
        try {
          await sendPaymentReminderEmail(
            payment.tenant.user.email,
            payment.tenant.firstName,
            payment.amount,
            payment.dueDate,
            payment.lease.property.name
          );
        } catch (error) {
          logger.error(`Failed to send payment reminder to ${payment.tenant.user.email}:`, error);
        }
      }

      logger.info(`Sent payment reminders for ${upcomingPayments.length} upcoming payments`);
    } catch (error) {
      logger.error('Error sending payment reminders:', error);
    }
  });
};

// Run monthly on the 1st at 10 AM to generate monthly reports
export const generateMonthlyReports = () => {
  cron.schedule('0 10 1 * *', async () => {
    try {
      logger.info('Generating monthly reports...');

      const lastMonth = new Date();
      lastMonth.setMonth(lastMonth.getMonth() - 1);

      const startOfMonth = new Date(lastMonth.getFullYear(), lastMonth.getMonth(), 1);
      const endOfMonth = new Date(lastMonth.getFullYear(), lastMonth.getMonth() + 1, 0);

      // Generate analytics for each owner
      const owners = await prisma.owner.findMany({
        include: {
          properties: {
            include: {
              payments: {
                where: {
                  paidDate: {
                    gte: startOfMonth,
                    lte: endOfMonth,
                  },
                },
              },
              leases: {
                where: {
                  status: 'ACTIVE',
                },
              },
            },
          },
        },
      });

      for (const owner of owners) {
        const totalRevenue = owner.properties.reduce((sum, property) => {
          return sum + property.payments.reduce((paymentSum, payment) => paymentSum + payment.amount, 0);
        }, 0);

        const totalProperties = owner.properties.length;
        const occupiedProperties = owner.properties.filter(p => p.leases.length > 0).length;
        const occupancyRate = totalProperties > 0 ? (occupiedProperties / totalProperties) * 100 : 0;

        // Store monthly analytics
        await prisma.analytics.create({
          data: {
            ownerId: owner.id,
            period: 'MONTHLY',
            startDate: startOfMonth,
            endDate: endOfMonth,
            totalRevenue,
            totalProperties,
            occupiedProperties,
            occupancyRate,
            data: {
              properties: owner.properties.map(p => ({
                id: p.id,
                name: p.name,
                revenue: p.payments.reduce((sum, payment) => sum + payment.amount, 0),
                occupancy: p.leases.length > 0,
              })),
            },
          },
        });
      }

      logger.info(`Generated monthly reports for ${owners.length} owners`);
    } catch (error) {
      logger.error('Error generating monthly reports:', error);
    }
  });
};

// Run weekly on Sundays at 11 PM for cleanup tasks
export const cleanupTasks = () => {
  cron.schedule('0 23 * * 0', async () => {
    try {
      logger.info('Running cleanup tasks...');

      // Clean up old login attempts (keep only last 30 days)
      const thirtyDaysAgo = new Date();
      thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);

      const deletedAttempts = await prisma.loginAttempt.deleteMany({
        where: {
          createdAt: {
            lt: thirtyDaysAgo,
          },
        },
      });

      // Clean up old notifications (keep only last 90 days)
      const ninetyDaysAgo = new Date();
      ninetyDaysAgo.setDate(ninetyDaysAgo.getDate() - 90);

      const deletedNotifications = await prisma.notification.deleteMany({
        where: {
          createdAt: {
            lt: ninetyDaysAgo,
          },
          isRead: true,
        },
      });

      logger.info(`Cleanup completed: ${deletedAttempts.count} login attempts, ${deletedNotifications.count} notifications deleted`);
    } catch (error) {
      logger.error('Error running cleanup tasks:', error);
    }
  });
};

// Start all cron jobs
export const startCronJobs = () => {
  logger.info('Starting cron jobs...');
  checkOverduePayments();
  sendPaymentReminders();
  generateMonthlyReports();
  cleanupTasks();
  logger.info('All cron jobs started successfully');
};

================
File: src/services/featureFlags.js
================
import prisma from '../config/database.js';
import logger from '../config/logger.js';

// Default feature flags
const DEFAULT_FLAGS = {
  PAYMENT_PROCESSING: true,
  REAL_TIME_NOTIFICATIONS: true,
  ANALYTICS_DASHBOARD: true,
  MOBILE_PUSH_NOTIFICATIONS: false,
  ADVANCED_REPORTING: false,
  MAINTENANCE_SCHEDULING: false,
  AUTOMATED_RENT_COLLECTION: false,
  TENANT_PORTAL: true,
  DOCUMENT_MANAGEMENT: false,
  VIRTUAL_TOURS: false,
};

class FeatureFlagService {
  constructor() {
    this.flags = { ...DEFAULT_FLAGS };
    this.lastUpdated = null;
    this.cacheTTL = 5 * 60 * 1000; // 5 minutes
  }

  async loadFlags() {
    try {
      const now = Date.now();
      if (this.lastUpdated && (now - this.lastUpdated) < this.cacheTTL) {
        return this.flags;
      }

      const dbFlags = await prisma.featureFlag.findMany({
        where: {
          isActive: true,
        },
      });

      // Update flags from database
      const updatedFlags = { ...DEFAULT_FLAGS };
      dbFlags.forEach(flag => {
        updatedFlags[flag.name] = flag.enabled;
      });

      this.flags = updatedFlags;
      this.lastUpdated = now;

      logger.debug('Feature flags loaded from database');
      return this.flags;
    } catch (error) {
      logger.error('Error loading feature flags:', error);
      return this.flags; // Return cached or default flags
    }
  }

  async isEnabled(flagName, userId = null, userRole = null) {
    try {
      await this.loadFlags();

      // Check if flag exists
      if (!(flagName in this.flags)) {
        logger.warn(`Feature flag '${flagName}' not found, defaulting to false`);
        return false;
      }

      // Get base flag value
      let isEnabled = this.flags[flagName];

      // Check for user-specific or role-specific overrides
      if (userId || userRole) {
        const override = await prisma.featureFlagOverride.findFirst({
          where: {
            flagName,
            OR: [
              { userId },
              { userRole },
            ],
            isActive: true,
          },
          orderBy: [
            { userId: 'desc' }, // User-specific takes precedence
            { createdAt: 'desc' },
          ],
        });

        if (override) {
          isEnabled = override.enabled;
        }
      }

      return isEnabled;
    } catch (error) {
      logger.error(`Error checking feature flag '${flagName}':`, error);
      return false; // Fail closed
    }
  }

  async updateFlag(flagName, enabled, updatedBy) {
    try {
      await prisma.featureFlag.upsert({
        where: { name: flagName },
        create: {
          name: flagName,
          enabled,
          createdBy: updatedBy,
        },
        update: {
          enabled,
          updatedBy,
          updatedAt: new Date(),
        },
      });

      // Clear cache to force reload
      this.lastUpdated = null;

      logger.info(`Feature flag '${flagName}' updated to ${enabled} by user ${updatedBy}`);
      return true;
    } catch (error) {
      logger.error(`Error updating feature flag '${flagName}':`, error);
      return false;
    }
  }

  async setUserOverride(flagName, userId, enabled, updatedBy) {
    try {
      await prisma.featureFlagOverride.upsert({
        where: {
          flagName_userId: {
            flagName,
            userId,
          },
        },
        create: {
          flagName,
          userId,
          enabled,
          createdBy: updatedBy,
        },
        update: {
          enabled,
          updatedBy,
          updatedAt: new Date(),
        },
      });

      logger.info(`Feature flag override '${flagName}' set to ${enabled} for user ${userId}`);
      return true;
    } catch (error) {
      logger.error(`Error setting user override for '${flagName}':`, error);
      return false;
    }
  }

  async setRoleOverride(flagName, userRole, enabled, updatedBy) {
    try {
      await prisma.featureFlagOverride.upsert({
        where: {
          flagName_userRole: {
            flagName,
            userRole,
          },
        },
        create: {
          flagName,
          userRole,
          enabled,
          createdBy: updatedBy,
        },
        update: {
          enabled,
          updatedBy,
          updatedAt: new Date(),
        },
      });

      logger.info(`Feature flag override '${flagName}' set to ${enabled} for role ${userRole}`);
      return true;
    } catch (error) {
      logger.error(`Error setting role override for '${flagName}':`, error);
      return false;
    }
  }

  async getAllFlags() {
    await this.loadFlags();
    return this.flags;
  }

  // Middleware to check feature flags
  requireFeature(flagName) {
    return async (req, res, next) => {
      try {
        const isEnabled = await this.isEnabled(
          flagName,
          req.user?.id,
          req.user?.role
        );

        if (!isEnabled) {
          return res.status(403).json({
            error: 'Feature not available',
            message: `The feature '${flagName}' is not enabled for your account`,
          });
        }

        next();
      } catch (error) {
        logger.error(`Error checking feature flag in middleware:`, error);
        return res.status(500).json({
          error: 'Internal server error',
          message: 'Failed to check feature availability',
        });
      }
    };
  }
}

export default new FeatureFlagService();

================
File: src/services/notificationService.js
================
import { sendEmail } from '../modules/notifications/services/emailService.js';
import { sendPushNotification } from '../modules/notifications/services/firebaseService.js';
import { sendNotificationToUser } from '../modules/notifications/services/socketService.js';
import prisma from '../config/database.js';
import logger from '../config/logger.js';

export const sendMultiChannelNotification = async (userId, notification) => {
  try {
    const user = await prisma.user.findUnique({
      where: { id: userId },
      include: {
        tenant: true,
        owner: true,
        manager: true
      }
    });

    if (!user) {
      throw new Error('User not found');
    }

    // Save notification to database
    const savedNotification = await prisma.notification.create({
      data: {
        title: notification.title,
        body: notification.body,
        type: notification.type || 'general',
        recipientId: userId,
        data: notification.data || {}
      }
    });

    // Send real-time notification via WebSocket
    await sendNotificationToUser(userId, notification);

    // Send email notification
    if (user.email) {
      await sendEmail({
        to: user.email,
        subject: notification.title,
        text: notification.body,
        html: `
          <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
            <h2 style="color: #333;">${notification.title}</h2>
            <p style="color: #666; line-height: 1.6;">${notification.body}</p>
            <div style="margin-top: 20px; padding: 10px; background-color: #f5f5f5; border-radius: 5px;">
              <small style="color: #888;">This is an automated notification from Rental Management System</small>
            </div>
          </div>
        `
      });
    }

    // Send push notification if FCM token exists
    const fcmToken = user.fcmToken;
    if (fcmToken) {
      await sendPushNotification(fcmToken, notification);
    }

    logger.info(`Multi-channel notification sent to user ${userId}: ${notification.title}`);
    return savedNotification;

  } catch (error) {
    logger.error('Error sending multi-channel notification:', error);
    throw error;
  }
};

export const sendBulkNotification = async (userIds, notification) => {
  const results = [];
  
  for (const userId of userIds) {
    try {
      const result = await sendMultiChannelNotification(userId, notification);
      results.push({ userId, success: true, notificationId: result.id });
    } catch (error) {
      results.push({ userId, success: false, error: error.message });
    }
  }

  return results;
};

export const sendRoleBasedNotification = async (roles, notification) => {
  try {
    const users = await prisma.user.findMany({
      where: {
        role: { in: roles }
      },
      select: { id: true }
    });

    const userIds = users.map(user => user.id);
    return await sendBulkNotification(userIds, notification);

  } catch (error) {
    logger.error('Error sending role-based notification:', error);
    throw error;
  }
};

================
File: src/utils/cloudinary.js
================
import { v2 as cloudinary } from 'cloudinary';
import logger from '../config/logger.js';

// Configure Cloudinary
cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET,
});

/**
 * Upload file to Cloudinary
 * @param {Buffer} fileBuffer - File buffer
 * @param {string} folder - Folder name in Cloudinary
 * @param {Object} options - Additional options
 * @returns {Promise<Object>} - Upload result
 */
export const uploadToCloudinary = (fileBuffer, folder = 'rental-management', options = {}) => {
  return new Promise((resolve, reject) => {
    const uploadOptions = {
      resource_type: 'auto',
      folder,
      use_filename: true,
      unique_filename: true,
      ...options,
    };

    cloudinary.uploader.upload_stream(
      uploadOptions,
      (error, result) => {
        if (error) {
          logger.error('Cloudinary upload error:', error);
          reject(error);
        } else {
          logger.info(`File uploaded to Cloudinary: ${result.public_id}`);
          resolve(result);
        }
      }
    ).end(fileBuffer);
  });
};

/**
 * Delete file from Cloudinary
 * @param {string} publicId - Public ID of the file
 * @param {string} resourceType - Resource type (image, video, raw)
 * @returns {Promise<Object>} - Deletion result
 */
export const deleteFromCloudinary = (publicId, resourceType = 'image') => {
  return new Promise((resolve, reject) => {
    cloudinary.uploader.destroy(
      publicId,
      { resource_type: resourceType },
      (error, result) => {
        if (error) {
          logger.error('Cloudinary delete error:', error);
          reject(error);
        } else {
          logger.info(`File deleted from Cloudinary: ${publicId}`);
          resolve(result);
        }
      }
    );
  });
};

/**
 * Generate signed URL for secure access
 * @param {string} publicId - Public ID of the file
 * @param {Object} options - Transformation options
 * @returns {string} - Signed URL
 */
export const generateSignedUrl = (publicId, options = {}) => {
  const defaultOptions = {
    sign_url: true,
    expire_at: Math.floor(Date.now() / 1000) + 3600, // Expire in 1 hour
    ...options,
  };

  return cloudinary.url(publicId, defaultOptions);
};

export default cloudinary;

================
File: src/utils/dateHelpers.js
================
/**
 * Date utility functions for the rental management system
 */

/**
 * Get the start and end dates for a given period
 * @param {string} period - The period type (daily, weekly, monthly, yearly)
 * @param {Date} baseDate - The base date to calculate from
 * @returns {Object} Object containing startDate and endDate
 */
export const getPeriodDates = (period, baseDate = new Date()) => {
  const date = new Date(baseDate);
  let startDate, endDate;

  switch (period) {
    case 'daily':
      startDate = new Date(date.getFullYear(), date.getMonth(), date.getDate());
      endDate = new Date(date.getFullYear(), date.getMonth(), date.getDate() + 1);
      break;
    case 'weekly':
      const dayOfWeek = date.getDay();
      startDate = new Date(date.getFullYear(), date.getMonth(), date.getDate() - dayOfWeek);
      endDate = new Date(date.getFullYear(), date.getMonth(), date.getDate() - dayOfWeek + 7);
      break;
    case 'monthly':
      startDate = new Date(date.getFullYear(), date.getMonth(), 1);
      endDate = new Date(date.getFullYear(), date.getMonth() + 1, 1);
      break;
    case 'yearly':
      startDate = new Date(date.getFullYear(), 0, 1);
      endDate = new Date(date.getFullYear() + 1, 0, 1);
      break;
    default:
      throw new Error('Invalid period type');
  }

  return { startDate, endDate };
};

/**
 * Calculate the number of days between two dates
 * @param {Date} startDate - The start date
 * @param {Date} endDate - The end date
 * @returns {number} Number of days
 */
export const daysBetween = (startDate, endDate) => {
  const oneDay = 24 * 60 * 60 * 1000;
  return Math.round(Math.abs((endDate - startDate) / oneDay));
};

/**
 * Check if a date is overdue
 * @param {Date} dueDate - The due date to check
 * @returns {boolean} True if the date is overdue
 */
export const isOverdue = (dueDate) => {
  return new Date(dueDate) < new Date();
};

/**
 * Get the next due date based on a frequency
 * @param {Date} baseDate - The base date
 * @param {string} frequency - The frequency (monthly, quarterly, yearly)
 * @returns {Date} The next due date
 */
export const getNextDueDate = (baseDate, frequency) => {
  const date = new Date(baseDate);

  switch (frequency) {
    case 'monthly':
      date.setMonth(date.getMonth() + 1);
      break;
    case 'quarterly':
      date.setMonth(date.getMonth() + 3);
      break;
    case 'yearly':
      date.setFullYear(date.getFullYear() + 1);
      break;
    default:
      throw new Error('Invalid frequency type');
  }

  return date;
};

/**
 * Format a date for display
 * @param {Date} date - The date to format
 * @param {string} format - The format type (short, long, time)
 * @returns {string} Formatted date string
 */
export const formatDate = (date, format = 'short') => {
  const options = {
    short: { year: 'numeric', month: 'short', day: 'numeric' },
    long: { year: 'numeric', month: 'long', day: 'numeric' },
    time: { hour: '2-digit', minute: '2-digit' },
    datetime: { 
      year: 'numeric', 
      month: 'short', 
      day: 'numeric', 
      hour: '2-digit', 
      minute: '2-digit' 
    },
  };

  return new Intl.DateTimeFormat('en-US', options[format]).format(new Date(date));
};

/**
 * Get age from date of birth
 * @param {Date} dateOfBirth - The date of birth
 * @returns {number} Age in years
 */
export const calculateAge = (dateOfBirth) => {
  const today = new Date();
  const birthDate = new Date(dateOfBirth);
  let age = today.getFullYear() - birthDate.getFullYear();
  const monthDiff = today.getMonth() - birthDate.getMonth();

  if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birthDate.getDate())) {
    age--;
  }

  return age;
};

/**
 * Check if a lease is expiring soon
 * @param {Date} endDate - The lease end date
 * @param {number} daysThreshold - Number of days to consider "soon" (default: 30)
 * @returns {boolean} True if the lease is expiring soon
 */
export const isLeaseExpiringSoon = (endDate, daysThreshold = 30) => {
  const today = new Date();
  const leaseEnd = new Date(endDate);
  const daysUntilExpiry = Math.ceil((leaseEnd - today) / (1000 * 60 * 60 * 24));
  
  return daysUntilExpiry <= daysThreshold && daysUntilExpiry > 0;
};

================
File: src/utils/encryption.js
================
import crypto from 'crypto';

const algorithm = 'aes-256-gcm';
const secretKey = process.env.ENCRYPTION_KEY || crypto.randomBytes(32);

export const encrypt = (text) => {
  const iv = crypto.randomBytes(16);
  const cipher = crypto.createCipher(algorithm, secretKey, iv);
  
  let encrypted = cipher.update(text, 'utf8', 'hex');
  encrypted += cipher.final('hex');
  
  const authTag = cipher.getAuthTag();
  
  return {
    encrypted,
    iv: iv.toString('hex'),
    authTag: authTag.toString('hex')
  };
};

export const decrypt = (encryptedData) => {
  const { encrypted, iv, authTag } = encryptedData;
  
  const decipher = crypto.createDecipher(algorithm, secretKey, Buffer.from(iv, 'hex'));
  decipher.setAuthTag(Buffer.from(authTag, 'hex'));
  
  let decrypted = decipher.update(encrypted, 'hex', 'utf8');
  decrypted += decipher.final('utf8');
  
  return decrypted;
};

export const hashSensitiveData = (data) => {
  return crypto.createHash('sha256').update(data).digest('hex');
};

================
File: src/utils/helpers.js
================
import bcrypt from 'bcryptjs';
import jwt from 'jsonwebtoken';
import { v4 as uuidv4 } from 'uuid';
import crypto from 'crypto';

export const hashPassword = async (password) => {
  const saltRounds = 12;
  return await bcrypt.hash(password, saltRounds);
};

export const comparePassword = async (password, hashedPassword) => {
  return await bcrypt.compare(password, hashedPassword);
};

export const generateToken = (payload, expiresIn = process.env.JWT_EXPIRES_IN || '7d') => {
  return jwt.sign(payload, process.env.JWT_SECRET, { expiresIn });
};

export const verifyToken = (token) => {
  return jwt.verify(token, process.env.JWT_SECRET);
};

export const generateRandomPassword = (length = 12) => {
  const charset = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*';
  let password = '';
  for (let i = 0; i < length; i++) {
    password += charset.charAt(Math.floor(Math.random() * charset.length));
  }
  return password;
};

export const generateUUID = () => {
  return uuidv4();
};

export const generateSecureToken = () => {
  return crypto.randomBytes(32).toString('hex');
};

export const formatCurrency = (amount, currency = 'USD') => {
  return new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency,
  }).format(amount);
};

export const formatDate = (date, locale = 'en-US') => {
  return new Intl.DateTimeFormat(locale).format(new Date(date));
};

export const isValidEmail = (email) => {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
};

export const isValidPhone = (phone) => {
  const phoneRegex = /^\+?[\d\s\-\(\)]{10,}$/;
  return phoneRegex.test(phone);
};

export const sanitizeFileName = (fileName) => {
  return fileName.replace(/[^a-z0-9\.\-_]/gi, '_').toLowerCase();
};

export const calculateDaysBetween = (startDate, endDate) => {
  const start = new Date(startDate);
  const end = new Date(endDate);
  const diffTime = Math.abs(end - start);
  return Math.ceil(diffTime / (1000 * 60 * 60 * 24));
};

export const isDateExpired = (date) => {
  return new Date(date) < new Date();
};

export const addDays = (date, days) => {
  const result = new Date(date);
  result.setDate(result.getDate() + days);
  return result;
};

export const parseQueryParams = (query) => {
  const params = {};
  
  // Handle pagination
  if (query.page) params.page = parseInt(query.page) || 1;
  if (query.limit) params.limit = Math.min(parseInt(query.limit) || 10, 100);
  
  // Handle sorting
  if (query.sortBy) params.sortBy = query.sortBy;
  if (query.sortOrder) params.sortOrder = query.sortOrder === 'desc' ? 'desc' : 'asc';
  
  // Handle search
  if (query.search) params.search = query.search;
  
  // Handle filters
  if (query.status) params.status = query.status;
  if (query.type) params.type = query.type;
  if (query.startDate) params.startDate = new Date(query.startDate);
  if (query.endDate) params.endDate = new Date(query.endDate);
  
  return params;
};

export const buildPaginationResponse = (data, page, limit, total) => {
  const totalPages = Math.ceil(total / limit);
  
  return {
    data,
    pagination: {
      page,
      limit,
      total,
      totalPages,
      hasNext: page < totalPages,
      hasPrev: page > 1,
    },
  };
};

================
File: src/utils/pdfGenerator.js
================
import PDFDocument from 'pdfkit';
import logger from '../config/logger.js';

/**
 * Generate payment receipt PDF
 * @param {Object} data - Receipt data
 * @returns {Promise<Buffer>} - PDF buffer
 */
export const generatePaymentReceipt = async (data) => {
  return new Promise((resolve, reject) => {
    try {
      const doc = new PDFDocument({ margin: 50 });
      const buffers = [];

      doc.on('data', buffers.push.bind(buffers));
      doc.on('end', () => {
        const pdfBuffer = Buffer.concat(buffers);
        resolve(pdfBuffer);
      });

      // Header
      doc.fontSize(20).text('PAYMENT RECEIPT', { align: 'center' });
      doc.moveDown();

      // Company info
      if (data.owner.companyName) {
        doc.fontSize(16).text(data.owner.companyName, { align: 'center' });
      }
      doc.fontSize(12).text(`Property Management Services`, { align: 'center' });
      doc.moveDown(2);

      // Receipt details
      doc.fontSize(14).text('Receipt Details', { underline: true });
      doc.moveDown(0.5);

      doc.fontSize(12);
      doc.text(`Receipt Number: RCP-${data.payment.id.substring(0, 8).toUpperCase()}`);
      doc.text(`Date Paid: ${new Date(data.payment.paidDate).toLocaleDateString()}`);
      doc.text(`Payment Method: ${data.payment.method}`);
      if (data.payment.transactionId) {
        doc.text(`Transaction ID: ${data.payment.transactionId}`);
      }
      doc.moveDown();

      // Tenant information
      doc.fontSize(14).text('Tenant Information', { underline: true });
      doc.moveDown(0.5);

      doc.fontSize(12);
      doc.text(`Name: ${data.tenant.firstName} ${data.tenant.lastName}`);
      doc.text(`Email: ${data.tenant.user.email}`);
      if (data.tenant.phone) {
        doc.text(`Phone: ${data.tenant.phone}`);
      }
      doc.moveDown();

      // Property information
      doc.fontSize(14).text('Property Information', { underline: true });
      doc.moveDown(0.5);

      doc.fontSize(12);
      doc.text(`Property: ${data.property.name}`);
      doc.text(`Address: ${data.property.address}`);
      doc.moveDown();

      // Payment information
      doc.fontSize(14).text('Payment Information', { underline: true });
      doc.moveDown(0.5);

      doc.fontSize(12);
      doc.text(`Due Date: ${new Date(data.payment.dueDate).toLocaleDateString()}`);
      doc.fontSize(16).text(`Amount Paid: $${parseFloat(data.payment.amount).toFixed(2)}`, { 
        align: 'right',
        continued: false
      });

      if (data.payment.notes) {
        doc.moveDown();
        doc.fontSize(12).text(`Notes: ${data.payment.notes}`);
      }

      // Footer
      doc.moveDown(3);
      doc.fontSize(10).text('Thank you for your payment!', { align: 'center' });
      doc.text(`Generated on: ${new Date().toLocaleString()}`, { align: 'center' });

      // Add a border
      doc.rect(30, 30, doc.page.width - 60, doc.page.height - 60).stroke();

      doc.end();
    } catch (error) {
      logger.error('Error generating PDF receipt:', error);
      reject(error);
    }
  });
};

/**
 * Generate lease agreement PDF
 * @param {Object} data - Lease data
 * @returns {Promise<Buffer>} - PDF buffer
 */
export const generateLeaseAgreement = async (data) => {
  return new Promise((resolve, reject) => {
    try {
      const doc = new PDFDocument({ margin: 50 });
      const buffers = [];

      doc.on('data', buffers.push.bind(buffers));
      doc.on('end', () => {
        const pdfBuffer = Buffer.concat(buffers);
        resolve(pdfBuffer);
      });

      // Header
      doc.fontSize(20).text('LEASE AGREEMENT', { align: 'center' });
      doc.moveDown(2);

      // Agreement details
      doc.fontSize(14).text('Agreement Details', { underline: true });
      doc.moveDown(0.5);

      doc.fontSize(12);
      doc.text(`Lease ID: ${data.lease.id}`);
      doc.text(`Start Date: ${new Date(data.lease.startDate).toLocaleDateString()}`);
      doc.text(`End Date: ${new Date(data.lease.endDate).toLocaleDateString()}`);
      doc.text(`Monthly Rent: $${parseFloat(data.lease.rentAmount).toFixed(2)}`);
      if (data.lease.securityDeposit) {
        doc.text(`Security Deposit: $${parseFloat(data.lease.securityDeposit).toFixed(2)}`);
      }
      doc.moveDown();

      // Property information
      doc.fontSize(14).text('Property Information', { underline: true });
      doc.moveDown(0.5);

      doc.fontSize(12);
      doc.text(`Property: ${data.property.name}`);
      doc.text(`Address: ${data.property.address}`);
      doc.text(`Type: ${data.property.type}`);
      doc.moveDown();

      // Landlord information
      doc.fontSize(14).text('Landlord Information', { underline: true });
      doc.moveDown(0.5);

      doc.fontSize(12);
      if (data.owner.companyName) {
        doc.text(`Company: ${data.owner.companyName}`);
      }
      doc.text(`Email: ${data.owner.user.email}`);
      if (data.owner.phone) {
        doc.text(`Phone: ${data.owner.phone}`);
      }
      doc.moveDown();

      // Tenant information
      doc.fontSize(14).text('Tenant Information', { underline: true });
      doc.moveDown(0.5);

      doc.fontSize(12);
      doc.text(`Name: ${data.tenant.firstName} ${data.tenant.lastName}`);
      doc.text(`Email: ${data.tenant.user.email}`);
      if (data.tenant.phone) {
        doc.text(`Phone: ${data.tenant.phone}`);
      }
      doc.moveDown();

      // Terms and conditions
      if (data.lease.terms) {
        doc.fontSize(14).text('Terms and Conditions', { underline: true });
        doc.moveDown(0.5);
        doc.fontSize(10).text(JSON.stringify(data.lease.terms, null, 2));
        doc.moveDown();
      }

      // Signature section
      doc.addPage();
      doc.fontSize(14).text('Signatures', { underline: true });
      doc.moveDown(2);

      doc.fontSize(12);
      doc.text('Landlord Signature: ________________________    Date: ____________');
      doc.moveDown(2);
      doc.text('Tenant Signature: ________________________    Date: ____________');

      // Footer
      doc.moveDown(3);
      doc.fontSize(10).text(`Generated on: ${new Date().toLocaleString()}`, { align: 'center' });

      doc.end();
    } catch (error) {
      logger.error('Error generating lease agreement PDF:', error);
      reject(error);
    }
  });
};

/**
 * Generates a generic report in PDF format.
 * @param {Array<Object>} data - The array of data objects to display in the table.
 * @param {string} title - The title of the report.
 * @param {Array<{id: string, title: string, path?: string}>} headers - The headers for the table columns.
 * @returns {Promise<Buffer>} - PDF buffer.
 */
export const generatePdfReport = async (data, title, headers) => {
  return new Promise((resolve, reject) => {
    try {
      const doc = new PDFDocument({ layout: 'landscape', margin: 30 });
      const buffers = [];
      doc.on('data', buffers.push.bind(buffers));
      doc.on('end', () => resolve(Buffer.concat(buffers)));

      // Title
      doc.fontSize(18).text(title, { align: 'center' });
      doc.fontSize(10).text(`Generated on: ${new Date().toLocaleDateString()}`, { align: 'center' });
      doc.moveDown(2);

      // Table Header
      const tableTop = doc.y;
      const colWidth = (doc.page.width - 60) / headers.length;
      
      doc.font('Helvetica-Bold');
      headers.forEach((header, i) => {
        doc.text(header.title, 30 + (i * colWidth), tableTop, { width: colWidth, align: 'left' });
      });
      doc.font('Helvetica');
      const headerHeight = doc.y - tableTop;
      doc.moveTo(30, tableTop + headerHeight + 5).lineTo(doc.page.width - 30, tableTop + headerHeight + 5).stroke();
      doc.y = tableTop + headerHeight + 10;
      
      // Table Rows
      data.forEach(item => {
        const rowTop = doc.y;
        let maxHeight = 0;

        // Calculate max height for the row first, to handle multi-line text gracefully
        headers.forEach((header, i) => {
          const value = getNestedValue(item, header.path || header.id) ?? 'N/A';
          const textHeight = doc.heightOfString(String(value), { width: colWidth });
          if(textHeight > maxHeight) maxHeight = textHeight;
        });

        // Check if the new row will fit on the page, otherwise create a new page
        if (doc.y + maxHeight > doc.page.height - 30) {
            doc.addPage();
            doc.y = 30; // Reset y position
        }
        
        // Render the row
        headers.forEach((header, i) => {
          const value = getNestedValue(item, header.path || header.id) ?? 'N/A';
          doc.text(String(value), 30 + (i * colWidth), doc.y, { width: colWidth, align: 'left' });
        });
        
        doc.x = 30; // Reset x position for the next row
        doc.y += maxHeight + 10; // Move y position down based on the tallest cell
      });

      doc.end();
    } catch (error) {
      logger.error('Error generating PDF report:', error);
      reject(error);
    }
  });
};

/**
 * Generates a generic report in CSV format.
 * @param {Array<Object>} data - The array of data objects.
 * @param {Array<{id: string, title: string, path?: string}>} headers - The headers for the CSV columns.
 * @returns {Promise<string>} - CSV content as a string.
 */
export const generateCsvReport = async (data, headers) => {
    try {
        const headerRow = headers.map(h => `"${h.title}"`).join(',');
        const dataRows = data.map(row => {
            return headers.map(header => {
                const value = getNestedValue(row, header.path || header.id) ?? '';
                // Escape quotes by doubling them and enclose in quotes
                return `"${String(value).replace(/"/g, '""')}"`;
            }).join(',');
        });
        return [headerRow, ...dataRows].join('\n');
    } catch (error) {
        logger.error('Error generating CSV report:', error);
        throw error;
    }
};

export default {
  generatePaymentReceipt,
  generateLeaseAgreement,
  generatePdfReport,
  generateCsvReport,
};

================
File: src/utils/responseHelpers.js
================
export const successResponse = (res, data, message = 'Success', statusCode = 200) => {
  return res.status(statusCode).json({
    success: true,
    message,
    data,
    timestamp: new Date().toISOString()
  });
};

export const errorResponse = (res, message = 'Internal Server Error', statusCode = 500, errors = null) => {
  return res.status(statusCode).json({
    success: false,
    message,
    ...(errors && { errors }),
    timestamp: new Date().toISOString()
  });
};

export const paginatedResponse = (res, data, pagination, message = 'Success') => {
  return res.status(200).json({
    success: true,
    message,
    data,
    pagination: {
      ...pagination,
      hasNext: pagination.page < pagination.pages,
      hasPrev: pagination.page > 1
    },
    timestamp: new Date().toISOString()
  });
};

export const validationErrorResponse = (res, errors) => {
  return res.status(400).json({
    success: false,
    message: 'Validation Error',
    errors: errors.array ? errors.array() : errors,
    timestamp: new Date().toISOString()
  });
};

================
File: src/utils/validators.js
================
import validator from 'validator';

export const isValidPhoneNumber = (phone) => {
  const phoneRegex = /^\+?[\d\s\-\(\)]{10,}$/;
  return phoneRegex.test(phone);
};

export const isValidPostalCode = (code, country = 'US') => {
  const patterns = {
    US: /^\d{5}(-\d{4})?$/,
    CA: /^[A-Za-z]\d[A-Za-z] \d[A-Za-z]\d$/,
    UK: /^[A-Z]{1,2}\d[A-Z\d]? \d[A-Z]{2}$/
  };
  
  return patterns[country]?.test(code) || false;
};

export const isStrongPassword = (password) => {
  const strongPasswordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/;
  return strongPasswordRegex.test(password);
};

export const sanitizeInput = (input) => {
  if (typeof input !== 'string') return input;
  return validator.escape(input.trim());
};

export const isValidAmount = (amount) => {
  return typeof amount === 'number' && amount > 0 && Number.isFinite(amount);
};

export const isValidDate = (date) => {
  return date instanceof Date && !isNaN(date.getTime());
};

export const isValidCoordinates = (lat, lng) => {
  return (
    typeof lat === 'number' &&
    typeof lng === 'number' &&
    lat >= -90 && lat <= 90 &&
    lng >= -180 && lng <= 180
  );
};

================
File: src/index.js
================
import express from 'express';
import cors from 'cors';
import helmet from 'helmet';
import compression from 'compression';
import morgan from 'morgan';
import swaggerUi from 'swagger-ui-express';
import { createServer } from 'http';
import { Server } from 'socket.io';
import dotenv from 'dotenv';

// Import configurations
import logger from './config/logger.js';
import swaggerSpecs from './config/swagger.js';
import prisma from './config/database.js';

// Import middleware
import { errorHandler, notFoundHandler } from './middleware/errorHandler.js';
import { apiLimiter, speedLimiter } from './middleware/rateLimiter.js';
import { securityHeaders, preventParameterPollution, sanitizeInput } from './middleware/security.js';

// Import routes
import authRoutes from './modules/auth/routes/authRoutes.js';
import propertyRoutes from './modules/properties/routes/propertyRoutes.js';
import tenantRoutes from './modules/tenants/routes/tenantRoutes.js';
import ownerRoutes from './modules/owners/routes/ownerRoutes.js';
import managerRoutes from './modules/managers/routes/managerRoutes.js';
import leaseRoutes from './modules/leases/routes/leaseRoutes.js';
import paymentRoutes from './modules/payments/routes/paymentRoutes.js';
import complaintRoutes from './modules/complaints/routes/complaintRoutes.js';
import notificationRoutes from './modules/notifications/routes/notificationRoutes.js';
import analyticsRoutes from './modules/analytics/routes/analyticsRoutes.js';
import reportRoutes from './modules/reports/routes/reportRoutes.js';
import maintenanceRoutes from './modules/maintenance/routes/maintenanceRoutes.js';
import adminRoutes from './modules/admin/routes/adminRoutes.js';
import calendarRoutes from './modules/calendar/routes/calendarRoutes.js';

// Import socket handlers
import { initializeSocket } from './modules/notifications/services/socketService.js';
import { startCronJobs } from './services/cronJobs.js';

// Load environment variables
dotenv.config();

const app = express();
const server = createServer(app);
const io = new Server(server, {
  cors: {
    origin: process.env.FRONTEND_URL || "http://localhost:3000",
    methods: ["GET", "POST", "PUT", "DELETE"]
  }
});

// Initialize Socket.IO
initializeSocket(io);

// Security middleware
app.use(securityHeaders);
app.use(cors({
  origin: process.env.FRONTEND_URL || "http://localhost:3000",
  credentials: true,
}));
app.use(preventParameterPollution);
app.use(sanitizeInput);

// General middleware
app.use(compression());
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));
app.use(morgan('combined', { stream: { write: message => logger.info(message.trim()) } }));

// Rate limiting
app.use(apiLimiter);
app.use(speedLimiter);

// Input sanitization
app.use(sanitizeInput);

// Health check endpoint
app.get('/health', (req, res) => {
  res.status(200).json({
    status: 'healthy',
    timestamp: new Date().toISOString(),
    uptime: process.uptime(),
    environment: process.env.NODE_ENV,
  });
});

// API Documentation
app.use('/api-docs', swaggerUi.serve, swaggerUi.setup(swaggerSpecs, {
  explorer: true,
  customCss: '.swagger-ui .topbar { display: none }',
  customSiteTitle: "Rental Management API Documentation"
}));

// API Routes
const API_VERSION = '/api/v1';

app.use(`${API_VERSION}/auth`, authRoutes);
app.use(`${API_VERSION}/properties`, propertyRoutes);
app.use(`${API_VERSION}/tenants`, tenantRoutes);
app.use(`${API_VERSION}/owners`, ownerRoutes);
app.use(`${API_VERSION}/managers`, managerRoutes);
app.use(`${API_VERSION}/leases`, leaseRoutes);
app.use(`${API_VERSION}/payments`, paymentRoutes);
app.use(`${API_VERSION}/complaints`, complaintRoutes);
app.use(`${API_VERSION}/notifications`, notificationRoutes);
app.use(`${API_VERSION}/analytics`, analyticsRoutes);
app.use(`${API_VERSION}/reports`, reportRoutes);
app.use(`${API_VERSION}/maintenance`, maintenanceRoutes);
app.use(`${API_VERSION}/admin`, adminRoutes);
app.use(`${API_VERSION}/calendar`, calendarRoutes);

// 404 handler
app.use(notFoundHandler);

// Error handler
app.use(errorHandler);

const PORT = process.env.PORT || 5000;

// Graceful shutdown
const gracefulShutdown = async (signal) => {
  logger.info(`Received ${signal}. Shutting down gracefully...`);

  server.close(async () => {
    logger.info('HTTP server closed.');

    // Close database connection
    await prisma.$disconnect();
    logger.info('Database connection closed.');

    process.exit(0);
  });

  // Force close after 30 seconds
  setTimeout(() => {
    logger.error('Could not close connections in time, forcefully shutting down');
    process.exit(1);
  }, 30000);
};

process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));
process.on('SIGINT', () => gracefulShutdown('SIGINT'));

// Start cron jobs
startCronJobs();

// Start server
server.listen(PORT, '0.0.0.0', () => {
  logger.info(`Server running on port ${PORT} in ${process.env.NODE_ENV} mode`);
  logger.info(`API Documentation available at http://localhost:${PORT}/api-docs`);
});

export default app;

================
File: tests/admin.test.js
================
import request from 'supertest';
import app from '../src/index.js';
import prisma from '../src/config/database.js';

describe('Admin Routes', () => {
  let adminAuthToken;
  let testUserId;

  beforeAll(async () => {
    // Create test admin user and get auth token
    const loginResponse = await request(app)
      .post('/api/v1/auth/login')
      .send({
        email: 'admin@example.com',
        password: 'admin123',
      });

    adminAuthToken = loginResponse.body.data.token;
  });

  describe('GET /api/v1/admin/dashboard', () => {
    it('should get dashboard statistics', async () => {
      const response = await request(app)
        .get('/api/v1/admin/dashboard')
        .set('Authorization', `Bearer ${adminAuthToken}`);

      expect(response.status).toBe(200);
      expect(response.body.success).toBe(true);
      expect(response.body.data.overview).toBeDefined();
    });

    it('should return 403 for non-admin users', async () => {
      // Test with regular user token
      const userLoginResponse = await request(app)
        .post('/api/v1/auth/login')
        .send({
          email: 'test@example.com',
          password: 'password123',
        });

      const userToken = userLoginResponse.body.data.token;

      const response = await request(app)
        .get('/api/v1/admin/dashboard')
        .set('Authorization', `Bearer ${userToken}`);

      expect(response.status).toBe(403);
    });
  });

  describe('POST /api/v1/admin/users', () => {
    it('should create a new user', async () => {
      const userData = {
        email: 'newuser@example.com',
        password: 'password123',
        firstName: 'New',
        lastName: 'User',
        role: 'TENANT',
        phone: '1234567890',
      };

      const response = await request(app)
        .post('/api/v1/admin/users')
        .set('Authorization', `Bearer ${adminAuthToken}`)
        .send(userData);

      expect(response.status).toBe(201);
      expect(response.body.success).toBe(true);
      expect(response.body.data.email).toBe(userData.email);
      
      testUserId = response.body.data.id;
    });

    it('should return 400 for duplicate email', async () => {
      const userData = {
        email: 'newuser@example.com', // Same email as above
        password: 'password123',
        firstName: 'Another',
        lastName: 'User',
        role: 'TENANT',
      };

      const response = await request(app)
        .post('/api/v1/admin/users')
        .set('Authorization', `Bearer ${adminAuthToken}`)
        .send(userData);

      expect(response.status).toBe(400);
      expect(response.body.success).toBe(false);
    });
  });

  describe('GET /api/v1/admin/users', () => {
    it('should get all users', async () => {
      const response = await request(app)
        .get('/api/v1/admin/users')
        .set('Authorization', `Bearer ${adminAuthToken}`);

      expect(response.status).toBe(200);
      expect(response.body.success).toBe(true);
      expect(Array.isArray(response.body.data.users)).toBe(true);
    });

    it('should filter users by role', async () => {
      const response = await request(app)
        .get('/api/v1/admin/users?role=TENANT')
        .set('Authorization', `Bearer ${adminAuthToken}`);

      expect(response.status).toBe(200);
      expect(response.body.success).toBe(true);
    });
  });

  afterAll(async () => {
    // Cleanup test user
    if (testUserId) {
      await prisma.user.delete({ where: { id: testUserId } }).catch(() => {});
    }
  });
});

================
File: tests/auth.test.js
================
import request from 'supertest';
import app from '../src/index.js';
import prisma from '../src/config/database.js';
import { generateToken } from '../src/utils/helpers.js';

describe('Authentication', () => {
  beforeEach(async () => {
    // Clean up test data
    await prisma.user.deleteMany({
      where: { email: { contains: 'test' } }
    });
  });

  afterAll(async () => {
    await prisma.$disconnect();
  });

  describe('POST /api/v1/auth/register', () => {
    it('should register a new user successfully', async () => {
      const userData = {
        email: 'test@example.com',
        password: 'Password123!',
        role: 'TENANT'
      };

      const response = await request(app)
        .post('/api/v1/auth/register')
        .send(userData)
        .expect(201);

      expect(response.body.success).toBe(true);
      expect(response.body.data.user.email).toBe(userData.email);
      expect(response.body.data.token).toBeDefined();
    });

    it('should fail with invalid email', async () => {
      const userData = {
        email: 'invalid-email',
        password: 'Password123!',
        role: 'TENANT'
      };

      const response = await request(app)
        .post('/api/v1/auth/register')
        .send(userData)
        .expect(400);

      expect(response.body.success).toBe(false);
    });

    it('should fail with weak password', async () => {
      const userData = {
        email: 'test@example.com',
        password: '123',
        role: 'TENANT'
      };

      const response = await request(app)
        .post('/api/v1/auth/register')
        .send(userData)
        .expect(400);

      expect(response.body.success).toBe(false);
    });
  });

  describe('POST /api/v1/auth/login', () => {
    beforeEach(async () => {
      // Create a test user
      await request(app)
        .post('/api/v1/auth/register')
        .send({
          email: 'login-test@example.com',
          password: 'Password123!',
          role: 'TENANT'
        });
    });

    it('should login successfully with valid credentials', async () => {
      const response = await request(app)
        .post('/api/v1/auth/login')
        .send({
          email: 'login-test@example.com',
          password: 'Password123!'
        })
        .expect(200);

      expect(response.body.success).toBe(true);
      expect(response.body.data.token).toBeDefined();
    });

    it('should fail with invalid credentials', async () => {
      const response = await request(app)
        .post('/api/v1/auth/login')
        .send({
          email: 'login-test@example.com',
          password: 'wrongpassword'
        })
        .expect(401);

      expect(response.body.success).toBe(false);
    });
  });
});

================
File: tests/maintenance.test.js
================
import request from 'supertest';
import app from '../src/index.js';
import prisma from '../src/config/database.js';

describe('Maintenance Routes', () => {
  let authToken;
  let tenantId;
  let propertyId;

  beforeAll(async () => {
    // Create test user and get auth token
    const loginResponse = await request(app)
      .post('/api/v1/auth/login')
      .send({
        email: 'test@example.com',
        password: 'password123',
      });

    authToken = loginResponse.body.data.token;
    tenantId = loginResponse.body.data.user.tenant?.id;

    // Create test property
    const property = await prisma.property.create({
      data: {
        name: 'Test Property',
        address: '123 Test St',
        rent: 1200,
        ownerId: 'test-owner-id',
      },
    });
    propertyId = property.id;
  });

  describe('POST /api/v1/maintenance', () => {
    it('should create a maintenance request', async () => {
      const maintenanceData = {
        title: 'Leaky Faucet',
        description: 'The kitchen faucet is leaking',
        category: 'PLUMBING',
        priority: 'MEDIUM',
        propertyId,
      };

      const response = await request(app)
        .post('/api/v1/maintenance')
        .set('Authorization', `Bearer ${authToken}`)
        .send(maintenanceData);

      expect(response.status).toBe(201);
      expect(response.body.success).toBe(true);
      expect(response.body.data.title).toBe(maintenanceData.title);
    });

    it('should return 400 for invalid maintenance request data', async () => {
      const invalidData = {
        title: '',
        description: 'Missing title',
      };

      const response = await request(app)
        .post('/api/v1/maintenance')
        .set('Authorization', `Bearer ${authToken}`)
        .send(invalidData);

      expect(response.status).toBe(400);
      expect(response.body.success).toBe(false);
    });
  });

  describe('GET /api/v1/maintenance', () => {
    it('should get maintenance requests', async () => {
      const response = await request(app)
        .get('/api/v1/maintenance')
        .set('Authorization', `Bearer ${authToken}`);

      expect(response.status).toBe(200);
      expect(response.body.success).toBe(true);
      expect(Array.isArray(response.body.data.requests)).toBe(true);
    });

    it('should filter maintenance requests by status', async () => {
      const response = await request(app)
        .get('/api/v1/maintenance?status=OPEN')
        .set('Authorization', `Bearer ${authToken}`);

      expect(response.status).toBe(200);
      expect(response.body.success).toBe(true);
    });
  });
});

================
File: tests/setup.js
================
import { jest } from '@jest/globals';

// Mock environment variables
process.env.NODE_ENV = 'test';
process.env.DATABASE_URL = 'postgresql://test:test@localhost:5432/rental_test';
process.env.JWT_SECRET = 'test-jwt-secret';
process.env.JWT_EXPIRES_IN = '1h';

// Mock external services
jest.mock('../src/modules/notifications/services/emailService.js', () => ({
  sendEmail: jest.fn().mockResolvedValue(true)
}));

jest.mock('../src/modules/notifications/services/firebaseService.js', () => ({
  sendPushNotification: jest.fn().mockResolvedValue(true)
}));

jest.mock('../src/utils/cloudinary.js', () => ({
  uploadImage: jest.fn().mockResolvedValue({
    public_id: 'test-image',
    secure_url: 'https://test.cloudinary.com/image.jpg'
  }),
  deleteImage: jest.fn().mockResolvedValue(true)
}));

// Global test timeout
jest.setTimeout(30000);

================
File: .env.example
================
# Database
DATABASE_URL="postgresql://user:password@localhost:5432/rental_db"

# JWT
JWT_SECRET="your-super-secret-jwt-key"
JWT_EXPIRES_IN="7d"

# Server
PORT=5000
NODE_ENV="development"

# Email
SMTP_HOST="smtp.gmail.com"
SMTP_PORT=587
SMTP_USER="your-email@gmail.com"
SMTP_PASS="your-app-password"

# Cloudinary
CLOUDINARY_CLOUD_NAME="your-cloud-name"
CLOUDINARY_API_KEY="your-api-key"
CLOUDINARY_API_SECRET="your-api-secret"

# Firebase
FIREBASE_PROJECT_ID="your-project-id"
FIREBASE_PRIVATE_KEY="your-private-key"
FIREBASE_CLIENT_EMAIL="your-client-email"

# Rate Limiting
RATE_LIMIT_WINDOW_MS=900000
RATE_LIMIT_MAX_REQUESTS=100

# Redis
REDIS_URL="redis://localhost:6379"

================
File: .eslintrc.json
================
{
  "env": {
    "node": true,
    "es2022": true
  },
  "extends": ["eslint:recommended"],
  "parserOptions": {
    "ecmaVersion": 2022,
    "sourceType": "module"
  },
  "rules": {
    "no-unused-vars": ["error", { "argsIgnorePattern": "^_" }],
    "no-console": "warn",
    "prefer-const": "error",
    "no-var": "error",
    "object-shorthand": "error",
    "prefer-template": "error"
  }
}

================
File: .prettierrc
================
{
  "semi": true,
  "trailingComma": "es5",
  "singleQuote": true,
  "printWidth": 80,
  "tabWidth": 2,
  "useTabs": false
}

================
File: docker-compose.yml
================
version: '3.8'

services:
  app:
    build: .
    ports:
      - "5000:5000"
    environment:
      - NODE_ENV=production
      - DATABASE_URL=postgresql://postgres:password@db:5432/rental_db
    depends_on:
      - db
      - redis
    volumes:
      - ./uploads:/app/uploads
    restart: unless-stopped
    networks:
      - rental-network

  db:
    image: postgres:15-alpine
    environment:
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=password
      - POSTGRES_DB=rental_db
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./init.sql:/docker-entrypoint-initdb.d/init.sql
    ports:
      - "5432:5432"
    restart: unless-stopped
    networks:
      - rental-network

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    restart: unless-stopped
    networks:
      - rental-network

  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
      - ./ssl:/etc/nginx/ssl
    depends_on:
      - app
    restart: unless-stopped
    networks:
      - rental-network

volumes:
  postgres_data:
  redis_data:

networks:
  rental-network:
    driver: bridge

================
File: Dockerfile
================
# Use Node.js 20 Alpine for smaller image size
FROM node:20-alpine

# Set working directory
WORKDIR /app

# Install system dependencies
RUN apk add --no-cache \
    python3 \
    make \
    g++ \
    cairo-dev \
    jpeg-dev \
    pango-dev \
    musl-dev \
    giflib-dev \
    pixman-dev \
    pangomm-dev \
    libjpeg-turbo-dev \
    freetype-dev

# Copy package files
COPY package*.json ./

# Install dependencies
RUN npm ci --only=production && npm cache clean --force

# Copy application code
COPY . .

# Generate Prisma client
RUN npx prisma generate

# Create non-root user
RUN addgroup -g 1001 -S nodejs
RUN adduser -S nodejs -u 1001

# Change ownership of the app directory
RUN chown -R nodejs:nodejs /app
USER nodejs

# Expose port
EXPOSE 5000

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD node healthcheck.js

# Start the application
CMD ["npm", "start"]

================
File: healthcheck.js
================
import http from 'http';

const options = {
  host: 'localhost',
  port: process.env.PORT || 5000,
  path: '/health',
  timeout: 2000,
};

const request = http.request(options, (res) => {
  console.log(`STATUS: ${res.statusCode}`);
  if (res.statusCode === 200) {
    process.exit(0);
  } else {
    process.exit(1);
  }
});

request.on('error', (err) => {
  console.error('ERROR:', err);
  process.exit(1);
});

request.end();

================
File: jest.config.js
================
export default {
  testEnvironment: 'node',
  transform: {},
  extensionsToTreatAsEsm: ['.js'],
  globals: {
    'ts-jest': {
      useESM: true
    }
  },
  testMatch: [
    '**/tests/**/*.test.js'
  ],
  setupFilesAfterEnv: ['<rootDir>/tests/setup.js'],
  collectCoverageFrom: [
    'src/**/*.js',
    '!src/index.js',
    '!src/config/**',
    '!src/**/*.test.js'
  ],
  coverageDirectory: 'coverage',
  coverageReporters: ['text', 'lcov', 'html'],
  verbose: true
};




================================================================
End of Codebase
================================================================
